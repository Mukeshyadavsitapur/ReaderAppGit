import AsyncStorage from '@react-native-async-storage/async-storage';
import { createAudioPlayer, requestRecordingPermissionsAsync, setAudioModeAsync, useAudioRecorder } from 'expo-audio';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system/legacy';
import * as ImageManipulator from 'expo-image-manipulator';
import * as ImagePicker from 'expo-image-picker';
import { activateKeepAwakeAsync, deactivateKeepAwake } from 'expo-keep-awake';
import { LinearGradient } from 'expo-linear-gradient';
import * as ScreenOrientation from 'expo-screen-orientation';
import * as Sharing from 'expo-sharing';
import * as Speech from 'expo-speech';
import {
    AlertTriangle,
    ArrowLeft,
    ArrowLeftRight,
    ArrowRight,
    Book,
    BookA,
    BookAudio,
    BookOpen,
    BookOpenText,
    Bot,
    BrainCircuit,
    Briefcase,
    Calculator,
    Camera,
    Check,
    CheckCircle,
    CheckSquare,
    ChevronDown,
    ChevronLeft,
    ChevronRight,
    ChevronUp,
    Clapperboard,
    Clock,
    CloudSun,
    Code,
    Coffee,
    Copy,
    Cpu,
    Crown,
    Download,
    DownloadCloud,
    Drama,
    Dumbbell,
    ExternalLink,
    Eye,
    EyeOff,
    Feather,
    FileDown,
    File as FileIcon,
    FileImage,
    Files,
    FileText,
    Flag,
    Flower,
    Gamepad2,
    Gavel,
    Globe,
    GraduationCap,
    Hammer,
    HardDrive,
    Headphones,
    Heart,
    HelpCircle,
    Highlighter,
    History,
    Image as ImageIcon,
    Languages,
    Layers,
    LayoutGrid,
    Leaf,
    Library,
    Lightbulb,
    List,
    Mail,
    Maximize2,
    Megaphone,
    MessageSquare,
    Mic,
    Microscope,
    Minus,
    MonitorCheck,
    Moon,
    MoonStar,
    Music,
    NotebookPen,
    Palette,
    Pause,
    PenLine,
    Pin,
    Plane,
    Play,
    PlayCircle,
    Plus,
    Quote,
    Redo2,
    RefreshCcw,
    Rocket,
    Save,
    ScanText,
    ScrollText,
    Search,
    Settings,
    Share2,
    SkipBack,
    SkipForward,
    Smartphone,
    Smile,
    Sparkles,
    Square,
    Star,
    Stethoscope,
    StickyNote,
    Sun,
    Trash2,
    Trophy,
    Type,
    Undo2,
    Upload,
    User,
    UserPlus,
    Utensils,
    Volume2,
    Wand2,
    Wrench,
    X,
    XCircle,
    Youtube,
    Zap
} from 'lucide-react-native';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
    ActivityIndicator,
    Alert,
    Animated,
    AppState,
    BackHandler,
    DeviceEventEmitter,
    FlatList,
    GestureResponderEvent,
    Image,
    Keyboard,
    KeyboardAvoidingView,
    LayoutChangeEvent,
    Linking,
    LogBox,
    Modal, // Keep for openURL calls
    PanResponder,
    Platform,
    Pressable,
    ScrollView,
    Share,
    StatusBar,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    TouchableWithoutFeedback,
    useWindowDimensions,
    View,
    ViewStyle
} from 'react-native';
import { SafeAreaProvider, SafeAreaView } from 'react-native-safe-area-context';

// TypeScript Components (Consolidated)

// --- TYPE DEFINITIONS ---

export interface Theme {
    id: string;
    bg: string;
    text: string;
    primary: string;
    secondary: string;
    highlight: string;
    uiBg: string;
    buttonBg: string;
    border: string;
    error: string;
    headerBg: string;
    headerText: string;
    badgeBg: string;
    badgeText: string;
    inputBg: string;
    logoBg: string;
    logoText: string;
    toolColor: string[] | null;
    activeWord: string;
    bubbleUser: string;
    bubbleAI: string;
    statusBarStyle: "light-content" | "dark-content";
}

export interface Message {
    role: 'user' | 'assistant' | 'system';
    content: string;
}

export interface Highlight {
    start: number;
    end: number;
    text: string;
    color: string;
    id: string;
}

export interface FlashcardItem {
    id: string;
    word: string;
    definition: string;
    timestamp?: string;
}

export interface ChatSession {
    id: string;
    toolId: string;
    title: string;
    timestamp: string;
    messages: Message[];
    pinned?: boolean;
    hasAudio?: boolean;
    image?: string;
    highlights?: Highlight[];
    items?: FlashcardItem[];
    // Properties used in App but optional in base interface
    images?: string[];
    score?: number;
    attempts?: number;
    completed?: boolean;
    currentIndex?: number;
    quizData?: any[];
    totalQuestions?: number;
    totalTime?: number;
    contentPath?: string;
    partNumber?: number;
    [key: string]: any;
}

export interface SavedQuestion {
    id: string;
    question: string;
    options?: string[];
    correctOptionIndex?: number;
    explanation?: string;
    visualPrompt?: string;
    visualUri?: string;
    timestamp: string;
}

export interface SavedWord {
    word: string;
    definition: string;
    timestamp: string;
    examples?: string[];
}

export interface DisplaySettings {
    theme: string;
    fontSize: number;
    fontFamily: string;
    textStyles: string[];
    language: string;
    voice: string;
    tapToDefine: boolean;
    questionsLimit?: number;
    userName?: string;
    userProfession?: string;
    userGoal?: string;
    userBio?: string;
    ttsRate?: number;
    availableLanguages?: string[];
    primaryLanguage?: string;
    onlineTtsEnabled?: boolean;
    imageGenerationEnabled?: boolean;
    llmProvider?: string;
    groqApiKey?: string;
    hfApiKey?: string;
    modelPriority?: string;
    groqModelPriority?: string;
    groqCustomModel?: string;
    savedGroqCustomModels?: string[];
    showPersonalDictionary?: boolean;
    customTextModel?: string;
    savedCustomModels?: any[];
    preventSleep?: boolean;
    dictionaryLimit?: number;
    libraryLimit?: number;
    keepLabelsEnglish?: boolean;
    nameLocked?: boolean;
    isExamMode?: boolean;
    quizTarget?: string;
    modeLocked?: boolean;
    isOnboarded?: boolean;
}

export interface QuizState {
    questions: SavedQuestion[];
    currentIndex: number;
    selectedOptions: (number | null)[];
    showExplanations: boolean[];
    translations?: Record<number, string>;
}

export interface FlashcardSession {
    items: FlashcardItem[];
    currentIndex: number;
    title?: string;
}

export interface AudioFile {
    id: string;
    name: string;
    uri: string;
    duration?: number;
    timestamp: string;
}

export interface Tool {
    id: string;
    title: string;
    emoji: string;
    prompt: string;
    color?: string;
    category?: string;
}

export interface LibraryGroup {
    id: string;
    isGroup: true;
    toolId?: string;
    title: string;
    items?: ChatSession[];
    chapters?: ChatSession[];
    timestamp: string;
    pinned: boolean;
    hasAudio: boolean;
    image?: string;
    count?: number;
}

export type LibraryItem = ChatSession | LibraryGroup;

export interface ReaderParagraph {
    id: string;
    type: 'text' | 'table' | 'concept-card';
    text?: string;
    rows?: string[];
    title?: string;
    content?: string;
    offset: number;
    initiallyHidden?: boolean;
    toggleLabel?: string;
    chapterName?: string;
}

export interface SpeechRange {
    start: number;
    end: number;
}

export interface StorageStats {
    free: number;
    used: number;
    audio: number;
}

// Component Props Types
export interface SimpleTableProps {
    rows: string[];
    theme: Theme;
    onExpand?: (data: string[]) => void;
    isFullScreen?: boolean;
    initiallyHidden?: boolean;
    toggleLabel?: string;
    fontSize?: number;
    initialCustomWidths?: Record<number, number>;
    onSaveWidths?: (colIndex: number, width: number | null) => void;
}

// OPTIMIZATION: Memoized Library Items to prevent re-renders
interface LibrarySessionItemProps {
    session: any;
    theme: Theme;
    isSelected: boolean;
    isSelectionMode: boolean;
    isLandscape: boolean;
    primaryColor: string;
    onPress: (session: any) => void;
    onLongPress: (id: string) => void;
    styles: any;
}

const LibrarySessionItem = React.memo(({ session, theme, isSelected, isSelectionMode, isLandscape, primaryColor, onPress, onLongPress, styles }: LibrarySessionItemProps) => {
    const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 10 };
    const isSearch = session.toolId === 'quick_search';

    return (
        <TouchableOpacity
            onPress={() => onPress(session)}
            onLongPress={() => onLongPress(session.id)}
            delayLongPress={300}
            activeOpacity={0.8}
            style={[
                styles.historyItem,
                {
                    backgroundColor: isSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.uiBg,
                    borderColor: isSelected ? primaryColor : theme.border,
                    flexDirection: 'row',
                    alignItems: 'center',
                    paddingRight: 10,
                    borderWidth: isSelected ? 2 : 1
                },
                containerStyle
            ]}
        >
            {/* Cover Thumbnail */}
            {session.image ? (
                <Image source={{ uri: session.image }} style={{ width: 50, height: 50, borderRadius: 8, marginRight: 12, backgroundColor: theme.inputBg }} resizeMode="cover" />
            ) : (
                <View style={{ width: 50, height: 50, borderRadius: 8, marginRight: 12, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                    <BookOpenText size={24} color={theme.secondary} />
                </View>
            )}
            <View style={{ flex: 1 }}>
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}>
                    {isSelectionMode && (
                        <View style={{
                            width: 18, height: 18, borderRadius: 9,
                            borderWidth: 2, borderColor: isSelected ? primaryColor : theme.secondary,
                            backgroundColor: isSelected ? primaryColor : 'transparent',
                            alignItems: 'center', justifyContent: 'center'
                        }}>
                            {isSelected && <Check size={10} color="white" />}
                        </View>
                    )}
                    {session.pinned && (
                        <Pin size={14} color={primaryColor} fill={primaryColor} style={{ transform: [{ rotate: '45deg' }] }} />
                    )}
                    <Text style={[styles.historyTitle, { color: theme.text, flex: 1 }]} numberOfLines={1}>{session.title || "Untitled"}</Text>
                </View>
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5, marginLeft: (isSelectionMode ? 24 : 0) + (session.pinned && !isSelectionMode ? 0 : 0) }}>
                    {isSearch && <Globe size={10} color={theme.secondary} style={{ marginRight: 2 }} />}
                    <Text style={{ color: theme.secondary, fontSize: 12 }}>{new Date(session.timestamp).toLocaleDateString()}</Text>
                    {session.hasAudio && (
                        <Volume2 size={14} color={primaryColor} style={{ marginLeft: 5 }} />
                    )}
                </View>
            </View>
        </TouchableOpacity>
    );
}, (prev, next) => {
    return prev.session.id === next.session.id &&
        prev.session.timestamp === next.session.timestamp && // Check timestamp for updates
        prev.session.pinned === next.session.pinned &&
        prev.isSelected === next.isSelected &&
        prev.isSelectionMode === next.isSelectionMode &&
        prev.session.hasAudio === next.session.hasAudio && // Check audio status
        prev.theme.id === next.theme.id &&
        prev.isLandscape === next.isLandscape;
});

interface LibraryGroupItemProps {
    session: any;
    theme: Theme;
    isSelectionMode: boolean;
    selectedLibraryIds: string[];
    isExpanded: boolean;
    isLandscape: boolean;
    primaryColor: string;
    onToggleExpand: (id: string) => void;
    onGroupSelect: (ids: string[]) => void;
    onChildPress: (session: any) => void;
    onChildLongPress: (id: string) => void;
    onGroupLongPress: (ids: string[]) => void;
    styles: any;
    isStoriesTab?: boolean;
}

const LibraryGroupItem = React.memo(({ session, theme, isSelectionMode, selectedLibraryIds, isExpanded, isLandscape, primaryColor, onToggleExpand, onGroupSelect, onChildPress, onChildLongPress, onGroupLongPress, styles, isStoriesTab }: LibraryGroupItemProps) => {
    const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 10 };
    const items = isStoriesTab ? session.chapters : session.items;
    const childIds = items.map((s: any) => s.id);
    const isGroupSelected = childIds.length > 0 && childIds.every((id: string) => selectedLibraryIds.includes(id));

    // Determine Icon (only for journal groups, stories use standard logic)
    let GroupIcon = Bot;
    let groupColor = theme.secondary;

    if (!isStoriesTab) {
        if (session.toolId === 'quick_search') {
            GroupIcon = Globe;
            groupColor = '#0ea5e9';
        } else {
            // We'd need to access allTools/customTools here or pass them. 
            // Simplification: Pass pre-resolved icon/color or just use default.
            // For now, let's just use Bot if we can't resolve easily without passing huge props.
            // OR, better: pass mapped icon/color from parent. 
            // For this generic component, we'll revert to default if not provided.
            // Ideally we shouldn't couple to `customTools` state here.
        }
    }

    return (
        <View style={[{
            borderRadius: 16,
            backgroundColor: isGroupSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.uiBg,
            borderWidth: isGroupSelected ? 2 : 1,
            borderColor: isGroupSelected ? primaryColor : theme.border,
            overflow: 'hidden'
        }, containerStyle]}>
            <TouchableOpacity
                onPress={() => {
                    if (isSelectionMode) {
                        onGroupSelect(childIds);
                    } else {
                        onToggleExpand(session.id);
                    }
                }}
                onLongPress={() => {
                    onGroupLongPress(childIds);
                }}
                activeOpacity={0.8}
                style={{ flexDirection: 'row', alignItems: 'center', padding: 12 }}
            >
                {isSelectionMode && (
                    <View style={{
                        width: 18, height: 18, borderRadius: 9,
                        borderWidth: 2, borderColor: isGroupSelected ? primaryColor : theme.secondary,
                        backgroundColor: isGroupSelected ? primaryColor : 'transparent',
                        alignItems: 'center', justifyContent: 'center',
                        marginRight: 12
                    }}>
                        {isGroupSelected && <Check size={10} color="white" />}
                    </View>
                )}

                {/* Icon / Cover */}
                {isStoriesTab ? (
                    session.image ? (
                        <Image source={{ uri: session.image }} style={{ width: 48, height: 48, borderRadius: 8, marginRight: 12, backgroundColor: theme.inputBg }} resizeMode="cover" />
                    ) : (
                        <View style={{ width: 48, height: 48, borderRadius: 8, marginRight: 12, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                            <Book size={24} color={primaryColor} />
                        </View>
                    )
                ) : (
                    <View style={{ width: 44, height: 44, borderRadius: 12, marginRight: 12, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                        {/* Fallback Icon if we don't pass specific one */}
                        <Bot size={22} color={groupColor} />
                    </View>
                )}

                <View style={{ flex: 1 }}>
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}>
                        {session.pinned && (
                            <Pin size={14} color={primaryColor} fill={primaryColor} style={{ transform: [{ rotate: '45deg' }] }} />
                        )}
                        <Text style={[styles.historyTitle, { color: theme.text, flex: 1, fontSize: 16 }]} numberOfLines={1}>
                            {session.title}
                        </Text>
                    </View>
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5 }}>
                        <Text style={{ color: theme.secondary, fontSize: 12, fontWeight: 'bold' }}>{items.length} {isStoriesTab ? 'Chapters' : 'Items'}</Text>
                        <Text style={{ color: theme.secondary, fontSize: 12 }}>â€¢ Latest: {new Date(session.timestamp).toLocaleDateString()}</Text>
                        {session.hasAudio && (
                            <Volume2 size={14} color={primaryColor} style={{ marginLeft: 5 }} />
                        )}
                    </View>
                </View>

                <TouchableOpacity
                    onPress={() => onToggleExpand(session.id)}
                    style={{ padding: 8 }}
                >
                    <ChevronDown size={20} color={theme.secondary} style={{ transform: [{ rotate: isExpanded ? '180deg' : '0deg' }] }} />
                </TouchableOpacity>
            </TouchableOpacity>

            {isExpanded && (
                <View style={{ borderTopWidth: 1, borderTopColor: theme.border, backgroundColor: theme.bg }}>
                    {items.map((subSession: any, cIdx: number) => {
                        const isSelected = selectedLibraryIds.includes(subSession.id);
                        let subTitle = subSession.title;
                        if (isStoriesTab) {
                            let t = subSession.title.split(':').slice(1).join(':').trim();
                            if (!t) t = subSession.title;
                            if (!t) t = `Chapter ${cIdx + 1}`;
                            subTitle = t;
                        }

                        return (
                            <TouchableOpacity
                                key={subSession.id}
                                onPress={() => onChildPress(subSession)}
                                onLongPress={() => onChildLongPress(subSession.id)}
                                delayLongPress={300}
                                activeOpacity={0.7}
                                style={{
                                    paddingVertical: 14,
                                    paddingHorizontal: 16,
                                    borderBottomWidth: cIdx === items.length - 1 ? 0 : 1,
                                    borderBottomColor: theme.border,
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    backgroundColor: isSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : 'transparent'
                                }}
                            >
                                {isSelectionMode && (
                                    <View style={{
                                        width: 18, height: 18, borderRadius: 9,
                                        borderWidth: 1.5, borderColor: isSelected ? primaryColor : theme.secondary,
                                        backgroundColor: isSelected ? primaryColor : 'transparent',
                                        alignItems: 'center', justifyContent: 'center',
                                        marginRight: 12
                                    }}>
                                        {isSelected && <Check size={10} color="white" />}
                                    </View>
                                )}

                                {isStoriesTab && (
                                    <View style={{
                                        width: 24, height: 24, borderRadius: 12,
                                        backgroundColor: theme.buttonBg,
                                        alignItems: 'center', justifyContent: 'center',
                                        marginRight: 10
                                    }}>
                                        <Text style={{ fontSize: 11, color: theme.secondary, fontWeight: 'bold' }}>{cIdx + 1}</Text>
                                    </View>
                                )}

                                <View style={{ flex: 1 }}>
                                    <Text style={{ color: theme.text, fontSize: 14, fontWeight: '500' }} numberOfLines={1}>{subTitle}</Text>
                                    {!isStoriesTab && <Text style={{ color: theme.secondary, fontSize: 11, marginTop: 2 }}>{new Date(subSession.timestamp).toLocaleDateString()}</Text>}
                                </View>

                                {subSession.hasAudio && <Volume2 size={14} color={primaryColor} />}
                            </TouchableOpacity>
                        );
                    })}
                </View>
            )}
        </View>
    );
}, (prev, next) => {
    // Deep compare relevant props for group
    const prevChildIds = (prev.isStoriesTab ? prev.session.chapters : prev.session.items).map((s: any) => s.id);
    const nextChildIds = (next.isStoriesTab ? next.session.chapters : next.session.items).map((s: any) => s.id);

    // Check if selection changed for any child
    const selectionChanged = prevChildIds.some((id: string) => prev.selectedLibraryIds.includes(id) !== next.selectedLibraryIds.includes(id));

    return prev.session.id === next.session.id &&
        prev.session.timestamp === next.session.timestamp &&
        prev.session.pinned === next.session.pinned &&
        prev.isExpanded === next.isExpanded &&
        !selectionChanged && // Re-render if selection state of children changes
        prev.isSelectionMode === next.isSelectionMode &&
        prev.theme.id === next.theme.id &&
        prev.isLandscape === next.isLandscape;
});

export interface SimpleTableProps {
    rows: string[];
    theme: Theme;
    onExpand?: (data: string[]) => void;
    isFullScreen?: boolean;
    initiallyHidden?: boolean;
    toggleLabel?: string;
    fontSize?: number;
    initialCustomWidths?: Record<number, number>;
    onSaveWidths?: (colIndex: number, width: number | null) => void;
}

export interface ParsedTextProps {
    text: string;
    style?: any;
    theme: Theme;
    onExpand?: (data: string[]) => void;
}

export interface InteractiveTextProps {
    rawText: string;
    onWordPress?: (word: string) => void;
    onLinkPress?: (url: string) => void;
    style?: any;
    activeSentence?: SpeechRange | null;
    paragraphOffset?: number;
    theme: Theme;
    isHighlightMode?: boolean;
    highlights?: Highlight[];
    onHighlightPress?: (highlight: { start: number; end: number; text: string }) => void;
    tapToDefineEnabled?: boolean;
}

export interface ConceptCardProps {
    title?: string;
    subtitle?: string;
    content: string;
    theme: Theme;
    fontSize?: number;
    chapterName?: string;
    onSave?: (flashcard: any) => void;
}

// --- Interfaces ---
// 1. ColumnResizeSlider
// ============================================================================

interface ColumnResizeSliderProps {
    value: number;
    min: number;
    max: number;
    onValueChange: (value: number) => void;
    theme: Theme;
}

const ColumnResizeSlider: React.FC<ColumnResizeSliderProps> = ({ value, min, max, onValueChange, theme }) => {
    const widthRef = useRef(0);
    const activeColor = theme.id === 'day' ? '#2563eb' : theme.primary;

    const panResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponder: () => true,
            onPanResponderGrant: () => { },
            onPanResponderMove: (evt, _) => {
                if (widthRef.current > 0) {
                    const { locationX } = evt.nativeEvent;
                    const clampedX = Math.max(0, Math.min(locationX, widthRef.current));
                    const ratio = clampedX / widthRef.current;
                    const newValue = min + (ratio * (max - min));
                    onValueChange(newValue);
                }
            },
            onPanResponderRelease: (evt, _) => {
                if (widthRef.current > 0) {
                    const { locationX } = evt.nativeEvent;
                    const clampedX = Math.max(0, Math.min(locationX, widthRef.current));
                    const ratio = clampedX / widthRef.current;
                    const newValue = min + (ratio * (max - min));
                    onValueChange(newValue);
                }
            }
        })
    ).current;

    const percentage = Math.min(100, Math.max(0, ((value - min) / (max - min)) * 100));

    return (
        <View
            style={{ flex: 1, height: 40, justifyContent: 'center', marginHorizontal: 10 }}
            onLayout={(e: LayoutChangeEvent) => widthRef.current = e.nativeEvent.layout.width}
            {...panResponder.panHandlers}
        >
            <View style={{ height: 6, backgroundColor: theme.border, borderRadius: 3, width: '100%', overflow: 'hidden' }}>
                <View style={{ width: `${percentage}%`, height: '100%', backgroundColor: activeColor }} />
            </View>
            <View style={{
                position: 'absolute',
                left: `${percentage}%`,
                marginLeft: -12, // Thumb center
                width: 24,
                height: 24,
                borderRadius: 12,
                backgroundColor: 'white',
                borderWidth: 2,
                borderColor: activeColor,
                shadowColor: "#000",
                shadowOffset: { width: 0, height: 1 },
                shadowOpacity: 0.3,
                shadowRadius: 2,
                elevation: 3,
                zIndex: 10
            }} />
        </View>
    );
};

// ============================================================================
// 2. SimpleTable
// ============================================================================



const SimpleTable: React.FC<SimpleTableProps> = ({
    rows = [],
    theme,
    onExpand,
    isFullScreen = false,
    initiallyHidden = false,
    toggleLabel = "Show Answers",
    fontSize = 1.0,
    initialCustomWidths = {},
    onSaveWidths
}) => {
    const { width: windowWidth } = useWindowDimensions();
    const [customWidths, setCustomWidths] = useState<Record<number, number>>(initialCustomWidths);
    const [resizingCol, setResizingCol] = useState<{ index: number; width: number } | null>(null);
    const [isVisible, setIsVisible] = useState(!initiallyHidden);
    const [isTextMode, setIsTextMode] = useState(false);

    const BASE_FONT_SIZE = 16;
    const scaledFontSize = BASE_FONT_SIZE * fontSize;
    const headerFontSize = 11 * fontSize;

    if (!rows || rows.length === 0) return null;

    if (!isVisible) {
        return (
            <TouchableOpacity
                onPress={() => setIsVisible(true)}
                style={{
                    marginVertical: 15,
                    backgroundColor: theme.uiBg,
                    padding: 15,
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: theme.border,
                    flexDirection: 'row',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: 10,
                    borderStyle: 'dashed'
                }}
            >
                <Eye size={20} color={theme.id === 'day' ? '#2563eb' : theme.primary} />
                <Text style={{ color: theme.id === 'day' ? '#2563eb' : theme.primary, fontWeight: 'bold', fontSize: 14 * fontSize }}>{toggleLabel}</Text>
            </TouchableOpacity>
        );
    }

    const parsedRows = rows.map(row => {
        const content = row.trim().replace(/^\||\|$/g, '');
        return content.split('|').map(cell => cell.trim());
    });

    const dataRows = parsedRows.filter(rowCells => {
        const str = rowCells.join('');
        return !/^[\s\-:]+$/.test(str);
    });

    if (dataRows.length === 0) return null;

    let headers: string[] = [];
    let body: string[][] = [];

    if (dataRows.length === 1) {
        headers = dataRows[0].map((_, i) => `Column ${i + 1}`);
        body = dataRows;
    } else {
        headers = dataRows[0];
        body = dataRows.slice(1);
    }

    const colWidths = useMemo(() => {
        if (!Array.isArray(headers) || !Array.isArray(body)) return [];
        const contentWidths = headers.map(() => 0);
        const charPixelWidth = scaledFontSize * 0.6;

        body.forEach(row => {
            row.forEach((cell, idx) => {
                if (idx < contentWidths.length) {
                    const cellWidth = (cell.length * charPixelWidth) + 24;
                    if (cellWidth > contentWidths[idx]) {
                        contentWidths[idx] = cellWidth;
                    }
                }
            });
        });

        const headerWidths = headers.map(h => (h.length * charPixelWidth) + 24);
        const calculatedWidths = contentWidths.map((cWidth, i) => {
            const hWidth = headerWidths[i];
            const maxHeaderInfluence = 110 * fontSize;
            let finalWidth = cWidth;

            if (cWidth < hWidth) {
                finalWidth = Math.max(cWidth, Math.min(hWidth, maxHeaderInfluence));
            }

            const min = isFullScreen ? 80 * fontSize : 70 * fontSize;
            const max = isFullScreen ? 500 * fontSize : 300 * fontSize;
            return Math.max(min, Math.min(finalWidth, max));
        });

        const availableWidth = windowWidth - 40;
        const totalCalculatedWidth = calculatedWidths.reduce((sum, w) => sum + w, 0);
        let finalWidths = calculatedWidths;

        if (totalCalculatedWidth < availableWidth) {
            const extraSpace = availableWidth - totalCalculatedWidth;
            const extraPerCol = extraSpace / calculatedWidths.length;
            finalWidths = calculatedWidths.map(w => w + extraPerCol);
        }

        return finalWidths.map((w, i) => customWidths[i] !== undefined ? customWidths[i] : w);
    }, [headers, body, isFullScreen, windowWidth, customWidths, scaledFontSize, fontSize]);

    const renderCellText = (text: string, isHeader: boolean) => {
        const parts = text.split(/(\*\*.*?\*\*|\$.*?\$|\*[^*]+?\*)/g);
        return (
            <Text style={{ fontSize: scaledFontSize, textAlign: isHeader ? 'center' : 'left', lineHeight: scaledFontSize * 1.4 }}>
                {parts.map((part, index) => {
                    if (part.startsWith('**') && part.endsWith('**') && part.length >= 4) {
                        return <Text key={index} style={{ fontWeight: 'bold', color: theme.id === 'day' ? '#2563eb' : theme.primary }}>{part.slice(2, -2)}</Text>;
                    } else if (part.startsWith('$') && part.endsWith('$') && part.length >= 3) {
                        return <Text key={index} style={{ fontWeight: 'bold', color: theme.id === 'day' ? '#ea580c' : '#fb923c' }}>{part.slice(1, -1)}</Text>;
                    } else if (part.startsWith('*') && part.endsWith('*') && part.length >= 3) {
                        return <Text key={index} style={{ fontStyle: 'italic', color: theme.id === 'day' ? '#9333ea' : '#c084fc' }}>{part.slice(1, -1)}</Text>;
                    }
                    return <Text key={index} style={{ fontWeight: isHeader ? 'bold' : 'normal', color: theme.text }}>{part}</Text>;
                })}
            </Text>
        );
    };

    const handleColumnResize = (delta: number) => {
        if (!resizingCol) return;
        setResizingCol(prev => {
            if (!prev) return null;
            const newWidth = Math.max(50, Math.min(600, prev.width + delta));
            setCustomWidths(cw => {
                const next = { ...cw, [prev.index]: newWidth };
                if (onSaveWidths) onSaveWidths(prev.index, newWidth);
                return next;
            });
            return { ...prev, width: newWidth };
        });
    };

    const handleSliderResize = (val: number) => {
        if (!resizingCol) return;
        const newWidth = Math.round(Math.max(50, Math.min(600, val)));
        setResizingCol(prev => {
            if (!prev || prev.width === newWidth) return prev;
            setCustomWidths(cw => {
                const next = { ...cw, [prev.index]: newWidth };
                if (onSaveWidths) onSaveWidths(prev.index, newWidth);
                return next;
            });
            return { ...prev, width: newWidth };
        });
    };

    const resetColumnWidth = () => {
        if (!resizingCol) return;
        setCustomWidths(cw => {
            const newCw = { ...cw };
            delete newCw[resizingCol.index];
            if (onSaveWidths) onSaveWidths(resizingCol.index, null);
            return newCw;
        });
        setResizingCol(null);
    };

    return (
        <View style={{ marginVertical: isFullScreen ? 0 : 15, flex: isFullScreen ? 1 : 0 }}>
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-end', marginBottom: 5 }}>
                <View style={{ flexDirection: 'row', alignItems: 'center', opacity: 0.7, flex: 1 }}>
                    {!isTextMode && !isFullScreen && (
                        <>
                            <ArrowLeftRight size={12} color={theme.secondary} style={{ marginRight: 4 }} />
                            <Text style={{ fontSize: 10, color: theme.secondary, fontStyle: 'italic' }}>Long press column to resize</Text>
                        </>
                    )}
                </View>
                <View style={{ flexDirection: 'row', gap: 8 }}>
                    <TouchableOpacity
                        onPress={() => setIsTextMode(!isTextMode)}
                        style={{
                            flexDirection: 'row',
                            alignItems: 'center',
                            paddingVertical: 6,
                            paddingHorizontal: 10,
                            backgroundColor: theme.uiBg,
                            borderRadius: 8,
                            borderWidth: 1,
                            borderColor: theme.border,
                        }}
                    >
                        {isTextMode ? (
                            <LayoutGrid size={12} color={theme.secondary} style={{ marginRight: 4 }} />
                        ) : (
                            <List size={12} color={theme.secondary} style={{ marginRight: 4 }} />
                        )}
                        <Text style={{ fontSize: 10, fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase' }}>
                            {isTextMode ? "Grid" : "Cards"}
                        </Text>
                    </TouchableOpacity>
                    {!isFullScreen && (
                        <TouchableOpacity
                            onPress={() => onExpand && onExpand(rows)}
                            style={{
                                flexDirection: 'row',
                                alignItems: 'center',
                                paddingVertical: 6,
                                paddingHorizontal: 10,
                                backgroundColor: theme.uiBg,
                                borderRadius: 8,
                                borderWidth: 1,
                                borderColor: theme.border,
                            }}
                        >
                            <Maximize2 size={12} color={theme.secondary} style={{ marginRight: 4 }} />
                            <Text style={{ fontSize: 10, fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase' }}>Expand</Text>
                        </TouchableOpacity>
                    )}
                </View>
            </View>

            {isTextMode ? (
                <View>
                    {body.length === 0 ? (
                        <View style={{ padding: 20, alignItems: 'center' }}>
                            <Text style={{ color: theme.secondary, fontStyle: 'italic' }}>No data rows to display.</Text>
                        </View>
                    ) : (
                        body.map((row, rowIndex) => (
                            <View key={rowIndex} style={{ backgroundColor: theme.uiBg, borderRadius: 12, padding: 12, borderWidth: 1, borderColor: theme.border, marginBottom: 12 }}>
                                {row.map((cell, cellIndex) => {
                                    const headerText = headers[cellIndex] || "";
                                    const cleanHeader = headerText.replace(/\*\*/g, '').trim();
                                    return (
                                        <View key={cellIndex} style={{ marginBottom: 8 }}>
                                            <Text style={{ fontSize: headerFontSize, color: theme.secondary, fontWeight: '700', textTransform: 'uppercase', marginBottom: 2 }}>
                                                {cleanHeader}
                                            </Text>
                                            {renderCellText(cell, false)}
                                        </View>
                                    );
                                })}
                            </View>
                        ))
                    )}
                </View>
            ) : (
                <ScrollView horizontal showsHorizontalScrollIndicator={true} contentContainerStyle={{ flexGrow: 1 }}>
                    <View style={{
                        borderWidth: 1,
                        borderColor: theme.border,
                        borderRadius: 8,
                        overflow: 'hidden',
                        backgroundColor: theme.bg
                    }}>
                        <View style={{ flexDirection: 'row', backgroundColor: theme.id === 'day' ? '#f1f5f9' : theme.highlight }}>
                            {headers.map((cell, i) => (
                                <TouchableOpacity
                                    key={i}
                                    activeOpacity={0.8}
                                    onLongPress={() => setResizingCol({ index: i, width: colWidths[i] })}
                                    delayLongPress={300}
                                    style={{
                                        padding: 12,
                                        width: colWidths[i],
                                        borderRightWidth: 1,
                                        borderRightColor: theme.border,
                                        borderBottomWidth: 2,
                                        borderBottomColor: theme.border,
                                        justifyContent: 'center',
                                        backgroundColor: theme.id === 'day' ? '#e2e8f0' : theme.highlight
                                    }}
                                >
                                    {renderCellText(cell, true)}
                                </TouchableOpacity>
                            ))}
                        </View>
                        {body.map((row, rowIndex) => (
                            <View key={rowIndex} style={{ flexDirection: 'row', backgroundColor: rowIndex % 2 === 0 ? theme.bg : theme.uiBg }}>
                                {row.map((cell, cellIndex) => (
                                    <TouchableOpacity
                                        key={cellIndex}
                                        activeOpacity={1}
                                        onLongPress={() => setResizingCol({ index: cellIndex, width: colWidths[cellIndex] })}
                                        delayLongPress={300}
                                        style={{
                                            padding: 12,
                                            width: colWidths[cellIndex] || 60,
                                            borderRightWidth: 1,
                                            borderRightColor: theme.border,
                                            borderBottomWidth: 1,
                                            borderBottomColor: theme.border,
                                            justifyContent: 'flex-start'
                                        }}
                                    >
                                        {renderCellText(cell, false)}
                                    </TouchableOpacity>
                                ))}
                            </View>
                        ))}
                    </View>
                </ScrollView>
            )}

            <Modal visible={!!resizingCol} transparent animationType="fade" onRequestClose={() => setResizingCol(null)}>
                <TouchableOpacity
                    style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center' }}
                    activeOpacity={1}
                    onPress={() => setResizingCol(null)}
                >
                    <TouchableWithoutFeedback>
                        <View style={{ backgroundColor: theme.bg, padding: 20, borderRadius: 16, width: '85%', alignItems: 'center', shadowColor: "#000", shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.25, shadowRadius: 3.84, elevation: 5 }}>
                            <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text, marginBottom: 5 }}>Adjust Column Width</Text>
                            <Text style={{ fontSize: 12, color: theme.secondary, marginBottom: 20 }}>Column {resizingCol ? resizingCol.index + 1 : ''}</Text>
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 25, width: '100%' }}>
                                <TouchableOpacity onPress={() => handleColumnResize(-10)} style={{ width: 40, height: 40, borderRadius: 20, backgroundColor: theme.buttonBg, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border }}>
                                    <Minus size={20} color={theme.text} />
                                </TouchableOpacity>
                                <ColumnResizeSlider
                                    value={resizingCol?.width || 100}
                                    min={50}
                                    max={600}
                                    onValueChange={handleSliderResize}
                                    theme={theme}
                                />
                                <TouchableOpacity onPress={() => handleColumnResize(10)} style={{ width: 40, height: 40, borderRadius: 20, backgroundColor: theme.buttonBg, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border }}>
                                    <Plus size={20} color={theme.text} />
                                </TouchableOpacity>
                            </View>
                            <View style={{ flexDirection: 'row', gap: 10, width: '100%' }}>
                                <TouchableOpacity onPress={resetColumnWidth} style={{ flex: 1, padding: 12, borderRadius: 10, backgroundColor: theme.buttonBg, alignItems: 'center' }}>
                                    <Text style={{ color: theme.text, fontWeight: 'bold' }}>Reset Auto</Text>
                                </TouchableOpacity>
                                <TouchableOpacity onPress={() => setResizingCol(null)} style={{ flex: 1, padding: 12, borderRadius: 10, backgroundColor: theme.id === 'day' ? theme.primary : '#22c55e', alignItems: 'center' }}>
                                    <Text style={{ color: 'white', fontWeight: 'bold' }}>Done</Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    </TouchableWithoutFeedback>
                </TouchableOpacity>
            </Modal>
        </View>
    );
};

// ============================================================================
// 3. ParsedText
// ============================================================================



interface ParsedPart {
    type: 'text' | 'table' | 'code' | 'header';
    content: string | string[];
}

const ParsedText: React.FC<ParsedTextProps> = ({ text, style, theme, onExpand }) => {
    const parts = useMemo<ParsedPart[]>(() => {
        if (!text || typeof text !== 'string') return [];
        const lines = text.split('\n');
        const result: ParsedPart[] = [];

        let buffer: string[] = [];
        let state: 'text' | 'table' | 'code' = 'text';

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmed = line.trim();

            if (state === 'text') {
                if (trimmed.startsWith('```')) {
                    if (buffer.length > 0) { result.push({ type: 'text', content: buffer.join('\n') }); buffer = []; }
                    state = 'code';
                } else if (trimmed.startsWith('|')) {
                    if (buffer.length > 0) { result.push({ type: 'text', content: buffer.join('\n') }); buffer = []; }
                    buffer.push(trimmed);
                    state = 'table';
                } else if (trimmed.startsWith('###')) {
                    if (buffer.length > 0) { result.push({ type: 'text', content: buffer.join('\n') }); buffer = []; }
                    result.push({ type: 'header', content: trimmed.replace(/^###\s*/, '') });
                } else {
                    buffer.push(line);
                }
            }
            else if (state === 'code') {
                if (trimmed.startsWith('```')) {
                    result.push({ type: 'code', content: buffer.join('\n') });
                    buffer = [];
                    state = 'text';
                } else {
                    buffer.push(line);
                }
            }
            else if (state === 'table') {
                if (trimmed.startsWith('|')) {
                    buffer.push(trimmed);
                } else {
                    result.push({ type: 'table', content: [...buffer] });
                    buffer = [];
                    state = 'text';
                    if (trimmed.startsWith('```')) state = 'code';
                    else buffer.push(line);
                }
            }
        }

        if (buffer.length > 0) {
            if (state === 'table') result.push({ type: 'table', content: buffer });
            else if (state === 'code') result.push({ type: 'code', content: buffer.join('\n') });
            else result.push({ type: 'text', content: buffer.join('\n') });
        }

        return result;
    }, [text]);

    const renderRichText = (content: string) => {
        const segments = content.split(/(\*\*.*?\*\*|\$.*?\$|\*[^*]+?\*)/g);

        return (
            <Text style={style}>
                {segments.map((part, index) => {
                    if (part.startsWith('**') && part.endsWith('**') && part.length >= 4) {
                        return (
                            <Text
                                key={index}
                                style={{
                                    fontWeight: 'bold',
                                    color: theme.id === 'day' ? '#2563eb' : theme.primary
                                }}
                            >
                                {part.slice(2, -2)}
                            </Text>
                        );
                    } else if (part.startsWith('$') && part.endsWith('$') && part.length >= 3) {
                        return (
                            <Text
                                key={index}
                                style={{
                                    fontWeight: 'bold',
                                    color: theme.id === 'day' ? '#ea580c' : '#fb923c'
                                }}
                            >
                                {part.slice(1, -1)}
                            </Text>
                        );
                    } else if (part.startsWith('*') && part.endsWith('*') && part.length >= 3) {
                        return (
                            <Text
                                key={index}
                                style={{
                                    fontStyle: 'italic',
                                    color: theme.id === 'day' ? '#9333ea' : '#c084fc'
                                }}
                            >
                                {part.slice(1, -1)}
                            </Text>
                        );
                    }
                    return <Text key={index}>{part}</Text>;
                })}
            </Text>
        );
    };

    return (
        <View>
            {parts.map((part, index) => {
                if (part.type === 'text') {
                    const content = typeof part.content === 'string' ? part.content : part.content.join('\n');
                    return <View key={index}>{renderRichText(content)}</View>;
                } else if (part.type === 'header') {
                    const content = typeof part.content === 'string' ? part.content : part.content.join('\n');
                    return (
                        <Text
                            key={index}
                            style={{
                                fontSize: 18,
                                fontWeight: 'bold',
                                color: theme.text,
                                marginTop: 15,
                                marginBottom: 10
                            }}
                        >
                            {content}
                        </Text>
                    );
                } else if (part.type === 'code') {
                    const content = typeof part.content === 'string' ? part.content : part.content.join('\n');
                    return (
                        <View
                            key={index}
                            style={{
                                backgroundColor: theme.id === 'day' ? '#f1f5f9' : theme.highlight,
                                padding: 12,
                                borderRadius: 8,
                                marginVertical: 10,
                                borderLeftWidth: 3,
                                borderLeftColor: theme.primary
                            }}
                        >
                            <Text style={{ fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace', fontSize: 14, color: theme.text }}>
                                {content}
                            </Text>
                        </View>
                    );
                } else if (part.type === 'table') {
                    const rows = Array.isArray(part.content) ? part.content : [part.content];
                    return <SimpleTable key={index} rows={rows} theme={theme} onExpand={onExpand} />;
                }
                return null;
            })}
        </View>
    );
};

// ============================================================================
// 4. ConceptCard
// ============================================================================



const ConceptCard: React.FC<any> = ({
    title,
    subtitle,
    content,
    theme,
    fontSize = 1.0,
    chapterName,
    onSave,
    // NEW: Props for Interaction & TTS
    onWordPress,
    activeSentence,
    offset = 0,
    tapToDefineEnabled = true,
    isHighlightMode = false,
    highlights = [],
    onHighlightPress,
    onLinkPress
}) => {
    // REMOVED: renderStyledText (Replaced by InteractiveText)

    const handleLongPress = async () => {
        try {
            // Clean content for TTS playback (remove markdown formatting)
            const cleanedContent = cleanTextForDisplay(content);

            const existingData = await AsyncStorage.getItem('savedQuestions');
            const savedQuestions = existingData ? JSON.parse(existingData) : [];

            // FIX: Check against cleanedContent, because that is what is stored in 'back'
            const isDuplicate = savedQuestions.some((q: any) => q.back === cleanedContent);
            if (isDuplicate) {
                Alert.alert("Already Saved", "This concept card is already in your flashcards.");
                return;
            }

            let displayFront = "";
            let cleanTitle = title || 'KEY CONCEPT';
            const isAbstactSummary = cleanTitle.toLowerCase().includes('chapter summary');

            if (isAbstactSummary) {
                const effectiveChapter = chapterName || "Chapter";
                displayFront = `${effectiveChapter} Summary`;
            } else {
                displayFront = `${chapterName ? chapterName + '\n\n' : ''}${cleanTitle}${subtitle ? '\n' + subtitle : ''}`;
            }

            const flashcard = {
                id: Date.now().toString(),
                front: displayFront,
                back: cleanedContent,
                timestamp: Date.now(),
                source: 'concept_card',
                question: displayFront,
                explanation: cleanedContent,
                options: []
            };

            const updatedQuestions = [...savedQuestions, flashcard];
            await AsyncStorage.setItem('savedQuestions', JSON.stringify(updatedQuestions));
            DeviceEventEmitter.emit('refreshFlashcards');
            if (onSave) onSave(flashcard);
            Alert.alert("Saved!", "Find it in Library -> Test -> Cards.");
        } catch (error) {
            Alert.alert("Error", "Failed to save flashcard.");
        }
    };

    // Prepare offsets for Title vs Content
    // Parser adds ". " (length 2) after title
    const titleLength = title ? title.length + 2 : 0;
    const contentOffset = offset + titleLength;

    return (
        <Pressable onLongPress={handleLongPress} delayLongPress={500}>
            <View style={{ marginVertical: 12, backgroundColor: theme.bg, borderRadius: 12, borderWidth: 1, borderColor: theme.border, overflow: 'hidden', elevation: 2 }}>
                <View style={{ backgroundColor: theme.headerBg, paddingVertical: 8, paddingHorizontal: 12, borderBottomWidth: 1, borderBottomColor: theme.border, flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                    <View style={{ flex: 1 }}>
                        <InteractiveText
                            rawText={title || 'KEY CONCEPT'}
                            onWordPress={onWordPress}
                            onLinkPress={onLinkPress}
                            activeSentence={activeSentence}
                            paragraphOffset={offset} // Title starts at base offset
                            theme={theme}
                            isHighlightMode={isHighlightMode}
                            highlights={highlights}
                            onHighlightPress={onHighlightPress}
                            tapToDefineEnabled={tapToDefineEnabled}
                            style={{
                                fontSize: 14 * fontSize,
                                fontWeight: '700',
                                color: theme.text,
                                marginBottom: 2
                            }}
                        />
                        {subtitle && <Text style={{ fontSize: 11 * fontSize, color: theme.text, opacity: 0.8, fontStyle: 'italic' }}>{subtitle}</Text>}
                    </View>
                    <View style={{ backgroundColor: theme.badgeBg, paddingHorizontal: 8, paddingVertical: 2, borderRadius: 4, marginLeft: 8 }}>
                        <Text style={{ fontSize: 10 * fontSize, fontWeight: 'bold', color: theme.badgeText }}>{chapterName ? chapterName.toUpperCase() : 'CONCEPT'}</Text>
                    </View>
                </View>
                <View style={{ padding: 12 }}>
                    <InteractiveText
                        rawText={content}
                        onWordPress={onWordPress}
                        onLinkPress={onLinkPress}
                        activeSentence={activeSentence}
                        paragraphOffset={contentOffset} // Content shifted by title length
                        theme={theme}
                        isHighlightMode={isHighlightMode}
                        highlights={highlights}
                        onHighlightPress={onHighlightPress}
                        tapToDefineEnabled={tapToDefineEnabled}
                        style={{
                            fontSize: 15 * fontSize,
                            color: theme.text,
                            lineHeight: 22 * fontSize,
                            textAlign: 'justify'
                        }}
                    />
                    <Text style={{ fontSize: 10, color: theme.secondary, textAlign: 'center', marginTop: 8, fontStyle: 'italic', opacity: 0.7 }}>
                        (Long press to save as flashcard)
                    </Text>
                </View>
            </View>
        </Pressable>
    );
};

// --- COMPATIBILITY FIX: Expo SDK 52+ FileSystem Legacy Support ---
let fs = FileSystem;
try {
    const legacy = require('expo-file-system/legacy');
    if (legacy) {
        fs = legacy;
        console.log("Using expo-file-system/legacy for compatibility");
    }
} catch (e) {
    // Module not found, likely on older SDK or standard workflow.
}

// Ignore Expo AV deprecation warning AND the Keep Awake/Linking warnings
LogBox.ignoreLogs([

    'Unable to activate keep awake',
    'Looks like you have configured linking in multiple places',
    'The action \'REPLACE\' with payload', // Suppress the router navigation error
    'The current activity is no longer available',
    'Error: Unable to activate keep awake' // Add specific string matching
]);

// --- Configuration ---
const APP_TITLE = "ReaderApp";

// Detailed Guide for Missing API Key
const API_KEY_HELP_MARKDOWN = `
# âš ï¸ Connection Error: No API Key / à¤•à¥‹à¤ˆ API Key à¤¨à¤¹à¥€à¤‚

You are currently in **Offline Mode**. To use AI features like Chat, Vision, and Quizzes, you need to connect your own Google Gemini API Key. It is free, private, and takes 2 minutes.

### ðŸ› ï¸ How to Get Your Free Key / à¤…à¤ªà¤¨à¥€ à¤®à¥à¤«à¤¼à¥à¤¤ Key à¤•à¥ˆà¤¸à¥‡ à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¤°à¥‡à¤‚

1. **Tap the Link**: Go to [Google AI Studio](https://aistudio.google.com/app/apikey).
   **(à¤²à¤¿à¤‚à¤• à¤ªà¤° à¤Ÿà¥ˆà¤ª à¤•à¤°à¥‡à¤‚**: [Google AI Studio](https://aistudio.google.com/app/apikey) à¤ªà¤° à¤œà¤¾à¤à¤‚à¥¤)
2. **Sign In**: Use your Google Account.
   **(à¤¸à¤¾à¤‡à¤¨ à¤‡à¤¨ à¤•à¤°à¥‡à¤‚**: à¤…à¤ªà¤¨à¥‡ Google à¤–à¤¾à¤¤à¥‡ à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚à¥¤)
3. **Create Key**: Tap **"Create API Key"** (or "Create API key in new project").
   **(Key à¤¬à¤¨à¤¾à¤à¤‚**: **"Create API Key"** à¤ªà¤° à¤Ÿà¥ˆà¤ª à¤•à¤°à¥‡à¤‚à¥¤)
4. **Copy**: Copy the string there is a copy button near $ sign.
   **(à¤•à¥‰à¤ªà¥€ à¤•à¤°à¥‡à¤‚**: $ à¤¸à¤¾à¤‡à¤¨ à¤•à¥‡ à¤ªà¤¾à¤¸ à¤•à¥‰à¤ªà¥€ à¤¬à¤Ÿà¤¨ à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¤•à¥‡ à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤— à¤•à¥‹ à¤•à¥‰à¤ªà¥€ à¤•à¤°à¥‡à¤‚à¥¤)
5. **Paste**: Return to this app, go to **Settings**, and paste it into the "Cloud API Settings" box.
   **(à¤ªà¥‡à¤¸à¥à¤Ÿ à¤•à¤°à¥‡à¤‚**: à¤‡à¤¸ à¤à¤ª à¤ªà¤° à¤µà¤¾à¤ªà¤¸ à¤†à¤à¤‚, **Settings** à¤®à¥‡à¤‚ à¤œà¤¾à¤à¤‚, à¤”à¤° à¤‡à¤¸à¥‡ "Cloud API Settings" à¤¬à¥‰à¤•à¥à¤¸ à¤®à¥‡à¤‚ à¤ªà¥‡à¤¸à¥à¤Ÿ à¤•à¤°à¥‡à¤‚à¥¤)

> **Privacy Note**: Your key is stored securely on your device and is sent directly to Google servers. It is never shared with us.
>
> **à¤—à¥‹à¤ªà¤¨à¥€à¤¯à¤¤à¤¾ à¤¨à¥‹à¤Ÿ**: à¤†à¤ªà¤•à¥€ Key à¤†à¤ªà¤•à¥‡ à¤¡à¤¿à¤µà¤¾à¤‡à¤¸ à¤ªà¤° à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ à¤°à¥‚à¤ª à¤¸à¥‡ à¤¸à¤‚à¤—à¥à¤°à¤¹à¥€à¤¤ à¤¹à¥ˆ à¤”à¤° à¤¸à¥€à¤§à¥‡ Google à¤¸à¤°à¥à¤µà¤° à¤ªà¤° à¤­à¥‡à¤œà¥€ à¤œà¤¾à¤¤à¥€ à¤¹à¥ˆà¥¤ à¤¯à¤¹ à¤¹à¤®à¤¾à¤°à¥‡ à¤¸à¤¾à¤¥ à¤•à¤­à¥€ à¤¸à¤¾à¤à¤¾ à¤¨à¤¹à¥€à¤‚ à¤•à¥€ à¤œà¤¾à¤¤à¥€ à¤¹à¥ˆà¥¤

**Once saved, all AI features will unlock instantly!**
**à¤à¤• à¤¬à¤¾à¤° à¤¸à¤¹à¥‡à¤œà¤¨à¥‡ à¤•à¥‡ à¤¬à¤¾à¤¦, à¤¸à¤­à¥€ AI à¤¸à¥à¤µà¤¿à¤§à¤¾à¤à¤ à¤¤à¥à¤°à¤‚à¤¤ à¤…à¤¨à¤²à¥‰à¤• à¤¹à¥‹ à¤œà¤¾à¤à¤‚à¤—à¥€!**
`;

const ONBOARDING_GUIDE_MARKDOWN = `
# Welcome to ReaderApp! ðŸ‘‹
# ReaderApp à¤®à¥‡à¤‚ à¤†à¤ªà¤•à¤¾ à¤¸à¥à¤µà¤¾à¤—à¤¤ à¤¹à¥ˆ! ðŸ‘‹

This application depends on **Google Gemini** for its premium online intelligence. Connecting a key unlocks:
à¤¯à¤¹ à¤à¤ªà¥à¤²à¤¿à¤•à¥‡à¤¶à¤¨ à¤…à¤ªà¤¨à¥€ à¤ªà¥à¤°à¥€à¤®à¤¿à¤¯à¤® à¤‘à¤¨à¤²à¤¾à¤‡à¤¨ à¤¸à¥à¤µà¤¿à¤§à¤¾à¤“à¤‚ à¤•à¥‡ à¤²à¤¿à¤ **Google Gemini** à¤ªà¤° à¤¨à¤¿à¤°à¥à¤­à¤° à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆà¥¤ API Key à¤œà¥‹à¤¡à¤¼à¤¨à¥‡ à¤¸à¥‡ à¤…à¤¨à¤²à¥‰à¤• à¤¹à¥‹à¤—à¤¾:

- **AI Chat & Vision**: Discuss images and documents in real-time.
- **AI à¤šà¥ˆà¤Ÿ à¤”à¤° à¤µà¤¿à¤œà¤¼à¤¨**: à¤›à¤µà¤¿à¤¯à¥‹à¤‚ à¤”à¤° à¤¦à¤¸à¥à¤¤à¤¾à¤µà¥‡à¤œà¤¼à¥‹à¤‚ à¤ªà¤° à¤µà¤¾à¤¸à¥à¤¤à¤µà¤¿à¤• à¤¸à¤®à¤¯ à¤®à¥‡à¤‚ à¤šà¤°à¥à¤šà¤¾ à¤•à¤°à¥‡à¤‚à¥¤

- **Smart Storytelling**: Generate personalized stories and journals.
- **à¤¸à¥à¤®à¤¾à¤°à¥à¤Ÿ à¤•à¤¹à¤¾à¤¨à¥€ à¤²à¥‡à¤–à¤¨**: à¤µà¥à¤¯à¤•à¥à¤¤à¤¿à¤—à¤¤ à¤•à¤¹à¤¾à¤¨à¤¿à¤¯à¤¾à¤ à¤”à¤° à¤œà¤°à¥à¤¨à¤² à¤¬à¤¨à¤¾à¤à¤‚à¥¤

- **Intelligent Quizzes**: Create study materials from your own documents.
- **à¤¬à¥à¤¦à¥à¤§à¤¿à¤®à¤¾à¤¨ à¤•à¥à¤µà¤¿à¤œà¤¼**: à¤…à¤ªà¤¨à¥‡ à¤¦à¤¸à¥à¤¤à¤¾à¤µà¥‡à¤œà¤¼à¥‹à¤‚ à¤¸à¥‡ à¤…à¤§à¥à¤¯à¤¯à¤¨ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤¬à¤¨à¤¾à¤à¤‚à¥¤

### ðŸ› ï¸ Need help getting a key?
### ðŸ› ï¸ Key à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¤°à¤¨à¥‡ à¤®à¥‡à¤‚ à¤®à¤¦à¤¦ à¤šà¤¾à¤¹à¤¿à¤?

Use the guide below in this reader to get your free key in 2 minutes.
2 à¤®à¤¿à¤¨à¤Ÿ à¤®à¥‡à¤‚ à¤…à¤ªà¤¨à¥€ à¤®à¥à¤«à¥à¤¤ Key à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¨à¥€à¤šà¥‡ à¤¦à¥€ à¤—à¤ˆ à¤—à¤¾à¤‡à¤¡ à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚à¥¤

---

### ðŸ›¡ï¸ Prefer working Offline?
### ðŸ›¡ï¸ à¤‘à¤«à¤¼à¤²à¤¾à¤‡à¤¨ à¤•à¤¾à¤® à¤•à¤°à¤¨à¤¾ à¤ªà¤¸à¤‚à¤¦ à¤•à¤°à¤¤à¥‡ à¤¹à¥ˆà¤‚?

If you're not ready to connect to Google yet, don't worry! This app is packed with features that work **100% offline**:
à¤¯à¤¦à¤¿ à¤†à¤ª à¤…à¤­à¥€ Google à¤¸à¥‡ à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¤à¥ˆà¤¯à¤¾à¤° à¤¨à¤¹à¥€à¤‚ à¤¹à¥ˆà¤‚, à¤¤à¥‹ à¤šà¤¿à¤‚à¤¤à¤¾ à¤¨ à¤•à¤°à¥‡à¤‚! à¤¯à¤¹ à¤à¤ª **100% à¤‘à¤«à¤¼à¤²à¤¾à¤‡à¤¨** à¤•à¤¾à¤® à¤•à¤°à¤¨à¥‡ à¤µà¤¾à¤²à¥€ à¤¸à¥à¤µà¤¿à¤§à¤¾à¤“à¤‚ à¤¸à¥‡ à¤­à¤°à¤¾ à¤¹à¥ˆ:

- **Personalized Notes**: Capture and organize your thoughts anytime.
- **à¤µà¥à¤¯à¤•à¥à¤¤à¤¿à¤—à¤¤ à¤¨à¥‹à¤Ÿà¥à¤¸**: à¤•à¤­à¥€ à¤­à¥€ à¤…à¤ªà¤¨à¥‡ à¤µà¤¿à¤šà¤¾à¤°à¥‹à¤‚ à¤•à¥‹ à¤•à¥ˆà¤ªà¥à¤šà¤° à¤”à¤° à¤µà¥à¤¯à¤µà¤¸à¥à¤¥à¤¿à¤¤ à¤•à¤°à¥‡à¤‚à¥¤

- **Offline Dictionary**: Tap any word to see definitions instantly.
- **à¤‘à¤«à¤¼à¤²à¤¾à¤‡à¤¨ à¤¶à¤¬à¥à¤¦à¤•à¥‹à¤¶**: à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾à¤à¤ à¤¤à¥à¤°à¤‚à¤¤ à¤¦à¥‡à¤–à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤•à¤¿à¤¸à¥€ à¤­à¥€ à¤¶à¤¬à¥à¤¦ à¤ªà¤° à¤Ÿà¥ˆà¤ª à¤•à¤°à¥‡à¤‚à¥¤

- **Concept Cards**: Review your key learning materials on the go.
- **à¤•à¥‰à¤¨à¥à¤¸à¥‡à¤ªà¥à¤Ÿ à¤•à¤¾à¤°à¥à¤¡à¥à¤¸**: à¤šà¤²à¤¤à¥‡-à¤«à¤¿à¤°à¤¤à¥‡ à¤…à¤ªà¤¨à¥€ à¤ªà¥à¤°à¤®à¥à¤– à¤¸à¥€à¤–à¤¨à¥‡ à¤•à¥€ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤•à¥€ à¤¸à¤®à¥€à¤•à¥à¤·à¤¾ à¤•à¤°à¥‡à¤‚à¥¤

**Feel free to skip setup for now and explore these features!**
**à¤…à¤­à¥€ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¥‡à¤Ÿà¤…à¤ª à¤›à¥‹à¤¡à¤¼à¤¨à¥‡ à¤”à¤° à¤‡à¤¨ à¤¸à¥à¤µà¤¿à¤§à¤¾à¤“à¤‚ à¤•à¤¾ à¤ªà¤¤à¤¾ à¤²à¤—à¤¾à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¥à¤µà¤¤à¤‚à¤¤à¥à¤° à¤®à¤¹à¤¸à¥‚à¤¸ à¤•à¤°à¥‡à¤‚!**

---

### ðŸš€ Get Your Free Gemini API Key
### ðŸš€ à¤…à¤ªà¤¨à¥€ à¤®à¥à¤«à¥à¤¤ Gemini API Key à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¤°à¥‡à¤‚

1. **Visit [Google AI Studio](https://aistudio.google.com/app/apikey)**.
1. **[Google AI Studio](https://aistudio.google.com/app/apikey) à¤ªà¤° à¤œà¤¾à¤à¤‚**à¥¤

2. Sign in with your Google account.
2. à¤…à¤ªà¤¨à¥‡ Google à¤–à¤¾à¤¤à¥‡ à¤¸à¥‡ à¤¸à¤¾à¤‡à¤¨ à¤‡à¤¨ à¤•à¤°à¥‡à¤‚à¥¤

3. Tap **"Create API Key"**.
3. **"Create API Key"** à¤ªà¤° à¤Ÿà¥ˆà¤ª à¤•à¤°à¥‡à¤‚à¥¤

4. **Copy** the key and paste it in the box at the bottom of this screen.
4. Key à¤•à¥‹ **à¤•à¥‰à¤ªà¥€** à¤•à¤°à¥‡à¤‚ à¤”à¤° à¤‡à¤¸ à¤¸à¥à¤•à¥à¤°à¥€à¤¨ à¤•à¥‡ à¤¨à¥€à¤šà¥‡ à¤¦à¤¿à¤ à¤—à¤ à¤¬à¥‰à¤•à¥à¤¸ à¤®à¥‡à¤‚ à¤ªà¥‡à¤¸à¥à¤Ÿ à¤•à¤°à¥‡à¤‚à¥¤

**Everything you see on this screen is the real "Reader Mode". Go ahead and tap words or change themes to see it in action!**
**à¤‡à¤¸ à¤¸à¥à¤•à¥à¤°à¥€à¤¨ à¤ªà¤° à¤†à¤ª à¤œà¥‹ à¤•à¥à¤› à¤­à¥€ à¤¦à¥‡à¤– à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚ à¤µà¤¹ à¤…à¤¸à¤²à¥€ "à¤°à¥€à¤¡à¤° à¤®à¥‹à¤¡" à¤¹à¥ˆà¥¤ à¤¶à¤¬à¥à¤¦à¥‹à¤‚ à¤ªà¤° à¤Ÿà¥ˆà¤ª à¤•à¤°à¥‡à¤‚ à¤¯à¤¾ à¤¥à¥€à¤® à¤¬à¤¦à¤²à¥‡à¤‚ à¤”à¤° à¤‡à¤¸à¥‡ à¤à¤•à¥à¤¶à¤¨ à¤®à¥‡à¤‚ à¤¦à¥‡à¤–à¥‡à¤‚!**
`;

// NEW: Placeholder for Advertisement Image
// FIX: Replaced static image with code-generated gradient banner
// const AD_IMAGE = require("./assets/banner.jpg");

const TEXT_MODELS = [
    "gemini-3.0-ultra",
    "gemini-3.0-pro-exp",
    "gemini-3.0-flash-exp",
    "gemini-2.5-pro",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite",
    "gemini-2.5-flash-preview-09-2025"
];

// Groq free-tier models, newest â†’ oldest
const GROQ_MODELS = [
    "llama-3.3-70b-versatile",    // Quality preset: best free-tier model
    "llama-3.1-70b-versatile",    // Quality fallback
    "gemma2-9b-it",               // Mid fallback
    "llama-3.1-8b-instant",       // Speed preset: fastest free-tier model
    "gemma-7b-it",                // Speed fallback
];

// Cleaned Image Models List - Removed deprecated 404 models
const IMAGE_MODELS = [
    "imagen-4.0-generate-001",
    "imagen-3.0-generate-001"
];

// Cleaned TTS Models List - Removed unavailable 'pro' model to fix 404 errors
// Cleaned TTS Models List - 'gemini-2.0-flash' does not support audio generation
const TTS_MODELS = [
    "gemini-2.5-flash-preview-tts", // Working confirmed
    "gemini-2.5-pro-tts",
    "gemini-2.0-flash-exp"
];

// ... (other code) ...

// NEW: Highlight Colors Definition
const HIGHLIGHT_COLORS = {
    yellow: { day: '#fef08a', night: '#854d0e', code: '#facc15' }, // Yellow-200/800
    green: { day: '#bbf7d0', night: '#14532d', code: '#4ade80' }, // Green-200/800
    blue: { day: '#bfdbfe', night: '#1e3a8a', code: '#60a5fa' }, // Blue-200/800
    pink: { day: '#fbcfe8', night: '#831843', code: '#f472b6' }, // Pink-200/800
    purple: { day: '#ddd6fe', night: '#5b21b6', code: '#a78bfa' }, // Violet-200/800
    orange: { day: '#fed7aa', night: '#7c2d12', code: '#fb923c' }, // Orange-200/800
};

const FEMALE_VOICES: string[] = ["Kore", "Leda", "Aoede", "Zephyr", "Callirrhoe"];
const MALE_VOICES: string[] = ["Fenrir", "Puck", "Charon", "Orus", "Iapetus", "Algenib", "Alnilam"];

// Fallback if Speech.getAvailableVoicesAsync fails or returns empty
const DEFAULT_VOICES: any[] = [];
let AVAILABLE_VOICES: any[] = [];
const initVoices = async () => {
    try {
        const voices = await Speech.getAvailableVoicesAsync();
        if (voices && voices.length > 0) {
            AVAILABLE_VOICES = voices;
        } else {
            AVAILABLE_VOICES = DEFAULT_VOICES;
        }
    } catch (e) {
        console.log("Error fetching voices", e);
        AVAILABLE_VOICES = DEFAULT_VOICES;
    }
};
initVoices();

const apiKey: string = "";

// Module-level TTS state for flashcards (avoids hooks in render function)
let flashcardTTSPlaying: boolean = false;
let flashcardAutoPlay: boolean = false;
let autoPlayTimer: any = null;

// Module-level state for custom audio URIs
let customAudioUris: Record<string, string> = {};
let setCustomAudioUris: (uris: Record<string, string>) => void = () => { };

// Module-level audio player for custom audio playback
let customAudioPlayer: ReturnType<typeof createAudioPlayer> | null = null;
let isCustomAudioPlaying: boolean = false;

// Load custom audio URIs from AsyncStorage on app start
(async () => {
    try {
        const stored = await AsyncStorage.getItem('customAudioUris');
        if (stored) {
            const parsed = JSON.parse(stored);
            Object.assign(customAudioUris, parsed);
        }
    } catch (error) {
        console.error('Failed to load custom audio URIs on startup:', error);
    }
})();

// Notification Handler Setup REMOVED

// Helper map for dynamic icons in custom tools
const ICON_MAP: { [key: string]: any } = {
    'Bot': Bot,
    'Sparkles': Sparkles,
    'GraduationCap': GraduationCap,
    'Code': Code,
    'PenLine': PenLine,
    'Globe': Globe,
    'Briefcase': Briefcase,
    'Lightbulb': Lightbulb,
    'Heart': Heart,
    // NEW ADDITIONS
    'Smile': Smile,
    'Music': Music,
    'Rocket': Rocket,
    'Hammer': Hammer,
    'Wrench': Wrench,
    'Coffee': Coffee,
    'Utensils': Utensils,
    'Dumbbell': Dumbbell,
    'Gavel': Gavel,
    'Stethoscope': Stethoscope,
    'Calculator': Calculator,
    'Gamepad2': Gamepad2,
    'Clapperboard': Clapperboard,
    'Microscope': Microscope,
    'Megaphone': Megaphone,
    'User': User,
    'Plane': Plane,
    'Drama': Drama,
    'Palette': Palette,
    'Leaf': Leaf
};

// Color palette for auto-assignment to custom roles
const AUTO_COLORS: string[][] = [
    ["#8b5cf6", "#7c3aed"], // Violet
    ["#2dd4bf", "#10b981"], // Teal
    ["#34d399", "#22c55e"], // Green
    ["#3b82f6", "#06b6d4"], // Blue
    ["#facc15", "#f97316"], // Yellow
    ["#ec4899", "#be185d"], // Pink
    ["#0ea5e9", "#38bdf8"], // Sky
    ["#f43f5e", "#e11d48"], // Rose
    ["#d946ef", "#c026d3"], // Fuchsia
    ["#f97316", "#ea580c"], // Orange
    ["#6366f1", "#4f46e5"], // Indigo
    ["#14b8a6", "#0d9488"], // Teal Dark
];

// REMOVED CONSTANTS: LIBRARY_ENTRY_LIMIT and RECENT_SEARCH_LIMIT
// These are now controlled via displaySettings state.

const SILENT_WAV: string = "UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==";
const METADATA_SEPARATOR = "\n\n--- METADATA ---\n\n";

// NEW: Fallback models for dictionary definitions (Faster models preferred)
const DICTIONARY_MODELS_FALLBACK = {
    "English": "gemini-1.5-flash",
    "Hindi": "gemini-1.5-flash",
    "Spanish": "gemini-1.5-flash",
    "French": "gemini-1.5-flash",
    "German": "gemini-1.5-flash",
    "Italian": "gemini-1.5-flash",
    "Japanese": "gemini-1.5-flash",
    "Korean": "gemini-1.5-flash",
    "Chinese": "gemini-1.5-flash",
    "Russian": "gemini-1.5-flash",
    "Portuguese": "gemini-1.5-flash",
    "Arabic": "gemini-1.5-flash"
};

// NEW: Certificate HTML Generator (Updated Layout)
const generateCertificateHtml = (userName: string, title: string, score: number, total: number, date: string, attempts: number, quizId: string, timeTaken: string, instructorName: string): string => {
    const percentage: number = Math.round((score / total) * 100);
    const grade: string = percentage >= 90 ? 'A+' : (percentage >= 80 ? 'A' : (percentage >= 70 ? 'B' : (percentage >= 60 ? 'C' : 'Participant')));

    // Helper for ordinal numbers (1st, 2nd, 3rd)
    const getOrdinal = (n: number): string => {
        const s = ["th", "st", "nd", "rd"];
        const v = n % 100;
        return n + (s[(v - 20) % 10] || s[v] || s[0]);
    };

    const ordinalAttempt: string = getOrdinal(attempts);

    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certificate</title>
    <style>
        body {
            font-family: 'Times New Roman', Times, serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .meta-bar {
            width: 100%;
            max-width: 850px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-family: sans-serif;
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 0 5px;
        }
        .meta-link {
            text-decoration: none;
            color: #1e3a8a;
            font-weight: bold;
        }
        .certificate-container {
            width: 100%;
            max-width: 850px;
            background-color: #fff;
            padding: 15px;
            border: 1px solid #ccc;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .border-outer {
            border: 5px double #1e3a8a; /* Dark Blue */
            padding: 5px;
            height: 100%;
        }
        .border-inner {
            border: 2px solid #b8860b; /* Gold */
            padding: 40px 30px; /* Reduced side padding */
            text-align: center;
            position: relative;
            background: radial-gradient(circle, #fffff0 0%, #ffffff 100%);
        }
        .watermark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 150px;
            color: rgba(0,0,0,0.03);
            font-weight: bold;
            z-index: 0;
            pointer-events: none;
        }
        .content {
            position: relative;
            z-index: 1;
        }
        .header-logo {
            font-size: 28px;
            font-weight: bold;
            color: #1e3a8a;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 3px;
            border-bottom: 2px solid #b8860b;
            display: inline-block;
            padding-bottom: 10px;
        }
        .title {
            font-size: 56px;
            font-weight: bold;
            color: #333;
            margin: 25px 0 10px 0;
            font-family: 'Georgia', serif;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 20px;
            font-style: italic;
        }
        .student-name {
            font-size: 42px;
            font-weight: bold;
            color: #1e40af;
            margin: 10px 0 25px 0;
            font-family: 'Brush Script MT', cursive;
            text-decoration: underline;
            text-underline-offset: 8px;
            text-decoration-color: #ccc;
        }
        .description {
            font-size: 18px;
            color: #444;
            margin-bottom: 40px;
            line-height: 1.8;
            max-width: 750px;
            margin-left: auto;
            margin-right: auto;
        }
        .highlight-text {
            color: #000;
            font-weight: bold;
        }
        .footer {
            margin-top: 50px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px; /* Reduced padding to give space for middle stamp */
        }
        .signature-block {
            text-align: center;
            width: 200px;
        }
        .sig-line {
            border-top: 1px solid #333;
            margin-top: 8px;
            padding-top: 5px;
            font-size: 14px;
            font-weight: bold;
            color: #444;
        }
        .sig-img {
            font-family: 'Brush Script MT', cursive;
            font-size: 24px;
            color: #1e3a8a;
            margin-bottom: 5px;
        }
        .stamp-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 20px; /* Buffer spacing */
        }
        .stamp {
            width: 100px;
            height: 100px;
            border: 4px double #dc2626; /* RED STAMP */
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #dc2626; /* RED TEXT */
            transform: rotate(-10deg);
            background-color: rgba(220, 38, 38, 0.03);
            box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.05);
        }
        .stamp-label {
            font-size: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        .stamp-time-rect {
             border: 2px solid #dc2626;
             padding: 4px 8px;
             font-family: 'Courier New', monospace;
             font-size: 14px;
             font-weight: 900;
             background: rgba(255,255,255,0.7);
             letter-spacing: 0px;
        }
        .quiz-id {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 9px;
            color: #aaa;
            font-family: monospace;
        }
        .ad-banner {
            margin-top: 20px;
            width: 100%;
            max-width: 850px;
            padding: 15px;
            background: #fff;
            border: 1px dashed #ccc;
            border-radius: 8px;
            text-align: center;
            font-family: sans-serif;
            color: #555;
            box-sizing: border-box;
        }
        .ad-banner h3 { margin: 0 0 5px 0; font-size: 16px; color: #1e3a8a; }
        .ad-btn {
            display: inline-block;
            background: #1e3a8a;
            color: white;
            padding: 6px 14px;
            border-radius: 4px;
            text-decoration: none;
            font-weight: bold;
            font-size: 12px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="meta-bar">
        <span>ID: ${quizId ? quizId.substring(0, 8).toUpperCase() : 'N/A'}</span>
        <a href="https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp" class="meta-link">GET THE APP</a>
    </div>

    <div class="certificate-container">
        <div class="border-outer">
            <div class="border-inner">
                <div class="watermark">READER</div>
                <div class="content">
                    <div class="header-logo">ReaderApp</div>
                    
                    <div class="title">Certificate</div>
                    
                    <div class="subtitle">This certifies that</div>
                    
                    <div class="student-name">${userName}</div>
                    
                    <div class="description">
                        has successfully completed the interactive assessment module on<br>
                        <span class="highlight-text" style="font-size: 22px;">${title}</span><br><br>
                        with <strong>${percentage}%</strong> (${score}/${total}) in his <strong>${ordinalAttempt} attempt</strong>.
                    </div>

                    <div class="footer">
                        <div class="signature-block">
                            <div class="sig-img">${new Date(date).toLocaleDateString()}</div>
                            <div class="sig-line">Date Issued</div>
                        </div>
                        
                        <div class="stamp-container">
                            <div class="stamp">
                                <div class="stamp-label">TIME TAKEN</div>
                                <div class="stamp-time-rect">${timeTaken}</div>
                            </div>
                        </div>

                        <div class="signature-block">
                            <div class="sig-img">${instructorName}</div>
                            <div class="sig-line">Instructor</div>
                        </div>
                    </div>
                </div>
                <div class="quiz-id">ID: ${quizId ? quizId.substring(0, 8).toUpperCase() : 'N/A'}</div>
            </div>
        </div>
    </div>

    <div class="ad-banner">
        <h3>ðŸŽ“ Generated by ReaderApp</h3>
        <p style="font-size: 12px; margin: 0;">Create your own AI quizzes, stories, and notes. Download for Free today!</p>
        <a href="https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp" class="ad-btn">Download Now</a>
    </div>
</body>
</html>
    `;
};

// ... (Rest of imports and constants remain the same until the error area)

const SPEECH_RECORDING_OPTIONS: any = {
    extension: '.m4a',
    sampleRate: 44100,
    numberOfChannels: 1,
    bitRate: 128000,
    android: {
        extension: '.m4a',
        outputFormat: 'mpeg4', // AndroidOutputFormat.MPEG_4
        audioEncoder: 'aac', // AndroidAudioEncoder.AAC
        sampleRate: 44100,
        numberOfChannels: 1,
        bitRate: 128000,
    },
    ios: {
        extension: '.m4a',
        audioQuality: 96, // IOSAudioQuality.HIGH
        sampleRate: 44100,
        numberOfChannels: 2,
        bitRate: 128000,
        linearPCMBitDepth: 16,
        linearPCMIsBigEndian: false,
        linearPCMIsFloat: false,
    },
    web: {
        mimeType: 'audio/webm',
        bitsPerSecond: 128000,
    },
};

// HELPER: FileSystem Storage for Recent Searches
const getRecentSearchesPath = () => {
    return FileSystem.documentDirectory + 'recentSearches.json';
};

const saveRecentSearchesToFile = async (searches: any[]) => {
    try {
        const path = getRecentSearchesPath();
        await FileSystem.writeAsStringAsync(path, JSON.stringify(searches));
    } catch (e) {
        console.error("Failed to save recent searches to file:", e);
    }
};

const loadRecentSearchesFromFile = async () => {
    try {
        const path = getRecentSearchesPath();
        const info = await FileSystem.getInfoAsync(path);
        if (info.exists) {
            const content = await FileSystem.readAsStringAsync(path);
            const parsed = JSON.parse(content);
            return Array.isArray(parsed) ? parsed : [];
        }
        return [];
    } catch (e) {
        console.error("Failed to load recent searches from file:", e);
        return null;
    }
};

// REMOVED: AMBIENT_SOUNDS constant

const SCHOOL_TOOLS: any[] = [
    // Row 1

    { id: "visual_learner", title: "Vision", Icon: FileImage, role: "Visual Tutor", type: "vision", actionLabel: "Select Image", prompt: "Analyze images.", color: ["#2dd4bf", "#10b981"] },
    { id: "examiner", title: "Quiz", Icon: MonitorCheck, role: "Quiz Examiner", type: "quiz", actionLabel: "Start Quiz", prompt: "You are an examiner.", placeholder: "Enter topic (e.g. 'Hard Math Quiz', 'Grade 5 History')...", color: ["#34d399", "#22c55e"] },
    { id: "ai_tutor", title: "Personal Assistant", Icon: GraduationCap, role: "Personal Tutor", type: "lesson", actionLabel: "Start Learning", prompt: "You are a friendly Personal Assistant. Explain concepts in simple, beginner-friendly language, like easy-to-read study notes. Avoid complex jargon. Use tables, charts, diagrams, and bullet points. Use [[CONCEPT_CARD]] for formulas, code snippets, dates, and key definitions in ANY subject. **STRICTLY MAX 30-50 words per card**. Split complex topics into multiple cards. End with a [[CONCEPT_CARD: CHAPTER SUMMARY]].", placeholder: "Ask for study notes, explanations, or help...", color: ["#3b82f6", "#8b5cf6"] },

    // Row 2





    // Row 3





    // Row 4







    // Row 5

    // NEW: Editorial Tool


    // NEW: Help & Guide Character
];

const APP_GUIDE_TOOL = { id: "help_guide_char", title: "App Guide", Icon: HelpCircle, role: "ReaderApp Guide", type: "chat", actionLabel: "Get Help", prompt: "You are the official guide for ReaderApp. HELP ONLY with these available features: Vision (Image Analysis & Flashcards), Quiz (Create Quizzes), Flashcards (Study Decks), Personal Assistant (Study Notes), Story Mode (Write Novels), Dictionary, Notes, and Library. DO NOT mention or help with removed tools like 'Math Solver', 'ML Tutor', 'Editorial', or games. If asked about missing tools, say they are no longer available. Explicitly mention that Flashcards can be generated via Vision (from images) or Quiz mode.\n\nLATEST FEATURES (Highlight these when relevant):\n1. CUSTOM AUDIO UPLOAD: Users can now upload their own audio files (MP3, M4A, WAV, AAC) for dictionary words. In Dictionary, tap a word, then use the Upload Audio button to add custom pronunciation files. Custom audio is automatically cleaned up when words are deleted.\n\n2. DICTIONARY DRIVE IMPORT: Users can import entire dictionaries from Google Drive links. In Dictionary settings, paste a Google Drive share link containing a JSON dictionary file. Format: [{word, translation, language, timestamp}]. Ensure the Drive link has proper sharing permissions.\n\n3. PERMANENT DELETION: All content (Notes, Library, Stories, Quizzes) is now deleted permanently and immediately. This includes automatic cleanup of associated custom audio files. Note that this action cannot be undone, providing a streamlined and efficient workflow.\n\nWhen users ask about deletion, audio upload, or dictionary import, provide clear step-by-step instructions for these new features.", placeholder: "Ask how to use a feature...", color: ["#f59e0b", "#d97706"] };

// --- NEW: STATIC TEXT DEFINITIONS (The "Array File" equivalent) ---
const STATIC_TEXT: { [key: string]: any } = {
    tabs: {
        story: "Story",
        dictionary: "Dictionary",
        studio: "All Apps",
        notes: "Notes",
        library: "Library",
        settings: "Settings"
    },
    home: {
        welcome: "Hello, Friend!",
        subtitle: "What shall we learn today?",
        searchLib: "Search library...",
        searchOnline: "Ask me anything...",
        searchNotes: "Search saved notes...",
        dictTitle: "Recent Words Flashcards",
        dictSub: "words in history",
        shortcuts: "Shortcuts"
    },
    dictionary: {
        title: "Recent Words Flashcards",
        searchPlaceholder: "Type a word...",
        share: "Share",
        import: "Import",
        export: "Export",
        empty: "Your history is empty.",
        recent: "Recently Searched"
    },
    notes: {
        title: "My Notes",
        edit: "Edit Note",
        create: "Create New Note",
        search: "Search notes...",
        emptyNotes: "No notes yet.",
        save: "Save",
        discard: "Discard",
        vision: "Vision",
        quiz: "Quiz",
        expand: "Expand",
        grammar: "Grammar",
        translate: "Translate"
    },
    library: {
        journals: "Assistant",
        stories: "Stories",
        audio: "Audio",
        test: "Test",
        search: "Search library...",
        emptyJournals: "No assistant data yet.",
        emptyStories: "No stories saved yet.",
        emptyAudio: "No offline audio found.",
        emptyQuizzes: "No quizzes.",
        emptyQuestions: "No saved questions.",
        emptyVocab: "No saved words.",
        startQuiz: "Start a New Quiz",
        createStory: "Write a Story"
    },
    studio: {
        student: "STUDENT HUB",
        creative: "LANGUAGE & CREATIVE",
        professional: "PROFESSIONAL SUITE",
        daily: "DAILY LIFE",
        custom: "MY CUSTOM ROLES",
        input: "INPUT",
        quickIdeas: "QUICK IDEAS",
        start: "Start",
        newRole: "New Role",
        addNew: "Add New"
    },
    quiz: {
        mode: "QUIZ MODE",
        practice: "Practice",
        exam: "Exam",
        instantFeedback: "Instant Feedback",
        resultsEnd: "Results at End",
        questions: "QUESTIONS",
        subject: "SUBJECT",
        quickTopics: "QUICK TOPICS",
        vision: "Vision",
        review: "Review",
        finish: "Finish",
        next: "Next",
        testAgain: "Test Again",
        close: "Close"
    },
    story: {
        title: "Story Generator",
        subtitle: "Write Novels, Epics, & Biographies",
        narrator: "Narrator",
        character: "Live Character",
        bookTitle: "Book Title / Topic",
        chapterTitle: "Chapter Title",
        genre: "Genre / Style",
        generate: "Generate Chapter",
        previous: "Previous",
        nextChapter: "Next Chapter"
    },
    settings: {
        cloud: "CLOUD API SETTINGS",
        getKey: "Get Free Gemini API Key",
        ai: "AI CAPABILITIES",
        priority: "Model Priority",
        tts: "Online TTS",
        images: "AI Images",
        customModel: "Custom Text Model",
        check: "Check Availability",
        language: "LANGUAGE & AUDIO",
        primaryLang: "PRIMARY LANGUAGE",
        female: "FEMALE NARRATORS",
        male: "MALE NARRATORS",
        speed: "READING SPEED",
        sleep: "Prevent Sleep",
        storage: "STORAGE & DATA",
        status: "System Status",
        limits: "DATA LIMITS",
        dictLimit: "Dictionary History",
        libLimit: "Library Limit",
        reset: "Reset All Data",
        backup: "FULL DATA BACKUP",
        backupBtn: "Backup All Data",
        restoreBtn: "Restore Data",
        rate: "Rate & Feedback",
        subscribe: "Subscribe on YouTube"
    },
    common: {
        cancel: "Cancel",
        delete: "Delete",
        error: "Error",
        success: "Success",
        loading: "Thinking..."
    }
};

const VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Analyze Colors", prompt: "Analyze the color palette and artistic style." },
    { label: "Compare Images", prompt: "Compare and contrast the content of these images." },
    { label: "Creative Story", prompt: "Write a short, creative story inspired by these images." },
    { label: "Data Quiz", prompt: "Create a cohesive quiz based on this chart, graph, or arrangement." },
    { label: "Describe Detail", prompt: "Describe these images in detail." },
    { label: "Detect Emotion", prompt: "Analyze the emotions or mood depicted in the image." },
    { label: "Explain Concept", prompt: "Explain the main concept or diagram shown in simple terms." },
    { label: "Extract Text", prompt: "Extract all visible text from these images." },
    { label: "Historical Info", prompt: "Explain the historical context or significance of this image." },
    { label: "Identify Objects", prompt: "List the main objects and elements present." },
    { label: "Quiz Me", prompt: "Create a short quiz based on the content of these images." },
    { label: "Solve Problem", prompt: "Solve the problem or equation shown step-by-step." },
    { label: "Summarize", prompt: "Summarize the key points shown in these images." },
    { label: "To Text Note", prompt: "Convert this image content into a structured text note." },
    { label: "Translate", prompt: "Translate any text in these images to English." }
];

const DOCUMENT_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Action Items", prompt: "List any action items or tasks mentioned." },
    { label: "Critique", prompt: "Provide a constructive critique of the writing." },
    { label: "Describe Details", prompt: "Describe this document in detail." },
    { label: "Draft Email", prompt: "Draft an email summarizing this document." },
    { label: "Explain Concept", prompt: "Explain the main concept described." },
    { label: "Extract Text", prompt: "Extract the raw text from this document." },
    { label: "Key Insights", prompt: "Extract the most important insights and findings." },
    { label: "Quiz Me", prompt: "Create a quiz based on this document's content." },
    { label: "Simplify", prompt: "Explain the content in simple terms." },
    { label: "Summarize", prompt: "Summarize the key points of this document." },
    { label: "To Text Note", prompt: "Convert this document content into a structured text note." },
    { label: "Translate", prompt: "Translate the document content." }
];

const QUIZ_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Generate Quiz", prompt: "Create a comprehensive quiz based on the content of these images." },
    { label: "Similar Questions", prompt: "Create a quiz with questions that follow the same logic/pattern as the ones in the image, but with different values." },
    { label: "Extract Questions", prompt: "Extract the exact questions visible in these images and create a quiz from them." },
    { label: "Harder Version", prompt: "Create a significantly harder version of the quiz shown in these images." },
    { label: "Data Analysis", prompt: "Create a data interpretation quiz based on the charts, graphs, or tables in this image." },
    { label: "Concept Check", prompt: "Identify the core concepts in this image and create a conceptual quiz to test understanding." },
    { label: "True/False", prompt: "Create a True/False quiz based on the facts presented in these images." },
    { label: "Solve These", prompt: "Create a quiz where I have to solve the specific problems shown in the image." }
];

const QUIZ_DOCUMENT_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Generate Quiz", prompt: "Create a comprehensive quiz based on the content of this document." },
    { label: "Mock Exam", prompt: "Create a mock exam based on the content covered in this document." },
    { label: "Extract Questions", prompt: "Extract the exact questions found in this document and create a quiz from them." },
    { label: "Reading Comp", prompt: "Create reading comprehension questions based on the text." },
    { label: "Key Concepts", prompt: "Identify the core concepts in this document and create a conceptual quiz." },
    { label: "True/False", prompt: "Create a True/False quiz based on the facts presented in this document." },
    { label: "Vocabulary", prompt: "Create a quiz testing definitions of key terms found in this document." },
    { label: "Summarize First", prompt: "Summarize the key points of the document, then create a quiz based on them." }
];

const STORY_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Write Story", prompt: "Write a creative story inspired by these images." },
    { label: "Describe Scene", prompt: "Describe the scene in detail for a book chapter." },
    { label: "Character Bio", prompt: "Create a character biography based on the person in this image." },
    { label: "Autobiography", prompt: "Write an autobiography from the perspective of the main subject in this image/document." },
    { label: "Fantasy Lore", prompt: "Create a fantasy lore and backstory based on this visual." },
    { label: "Mystery Plot", prompt: "Write a mystery plot hook based on the details in this image." },
    { label: "Sci-Fi Concept", prompt: "Develop a sci-fi concept or technology description based on this image." },
    { label: "Dialogue", prompt: "Write a dialogue between the characters visible in this image." },
    { label: "Expand Story", prompt: "Use the content of this image/document as a base and expand it into a full narrative." },
    { label: "Complete Story", prompt: "Use the provided visual/text context as the beginning and write a complete ending to the story." },
    { label: "Detailed Story", prompt: "Analyze the visual elements and provide a detailed storytelling description of what is happening." },
    { label: "Extract Text", prompt: "Extract all visible text from this image." },
    { label: "Translate", prompt: "Translate any text in this image." }
];

const SEARCH_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Identify", prompt: "Identify the main object, product, or landmark in this image and provide detailed information." },
    { label: "Solve Problem", prompt: "Solve the math problem or logic puzzle shown in this image step-by-step." },
    { label: "Translate", prompt: "Translate any visible text in this image to [Target Language]." },
    { label: "Extract Text", prompt: "Extract and output all visible text from this image." },
    { label: "Explain", prompt: "Explain the diagram, chart, or concept shown in this image simply." },
    { label: "Product Info", prompt: "Identify this product and list its key features, price range, and likely use cases." },
    { label: "Summary", prompt: "Summarize the content or scene shown in this image." },
    { label: "Landmark Info", prompt: "Identify this place or landmark and tell me its history and location." },
    { label: "Plant/Animal", prompt: "Identify the plant or animal species in this picture." },
    { label: "Read Handwriting", prompt: "Transcribe the handwritten text in this image." }
];

const SEARCH_DOCUMENT_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Summarize", prompt: "Summarize the key points of this document." },
    { label: "Explain Concept", prompt: "Explain the main concept described in this document in simple terms." },
    { label: "Key Insights", prompt: "Extract the most important insights and findings from this text." },
    { label: "Action Items", prompt: "List any action items or tasks mentioned in this document." },
    { label: "Translate", prompt: "Translate the document content." },
    { label: "Simplify", prompt: "Rewrite the content in simple, easy-to-understand language." },
    { label: "Extract Text", prompt: "Extract the raw text from this document." }
];

const STORY_DOCUMENT_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Summarize Story", prompt: "Summarize the narrative or story present in this document." },
    { label: "Continue Story", prompt: "Continue the story from where this document ends." },
    { label: "Rewrite Ending", prompt: "Rewrite the ending of the story found in this document." },
    { label: "Character Study", prompt: "Analyze the main characters described in this text." },
    { label: "Modern Retelling", prompt: "Retell the story in this document in a modern setting." },
    { label: "To Script", prompt: "Convert the narrative in this document into a screenplay/script format." },
    { label: "Change Tone", prompt: "Rewrite the content of this document with a darker or more humorous tone." },
    { label: "First Person", prompt: "Rewrite this text from a first-person perspective." },
    { label: "Extract Text", prompt: "Extract all text from this document." },
    { label: "Translate", prompt: "Translate the document content." }
];




















const EDITORIAL_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Social Commentary", prompt: "Write a social commentary about the issue depicted." },
    { label: "Opinion Piece", prompt: "Write a strong opinion piece based on this image." },
    { label: "Critique", prompt: "Provide a critical analysis of the subject shown." },
    { label: "Satire", prompt: "Write a satirical take on the situation in this image." },
    { label: "Investigative", prompt: "Write an investigative report hypothesis based on these visual clues." },
    { label: "Debate Topic", prompt: "Formulate a debate topic derived from this image and argue for one side." }
];

const CUSTOM_ROLE_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Analyze", prompt: "Analyze this content strictly from the perspective of a [ROLE]." },
    { label: "Opinion", prompt: "What is your professional opinion on this as a [ROLE]?" },
    { label: "Advice", prompt: "Based on this, what advice would you give as a [ROLE]?" },
    { label: "Explain", prompt: "Explain this using your persona as a [ROLE]." },
    { label: "Critique", prompt: "Critique this based on the standards of a [ROLE]." },
    { label: "Identify", prompt: "Identify key elements relevant to your expertise as a [ROLE]." },
    { label: "Solve/Help", prompt: "Help me with the problem shown here, acting as a [ROLE]." },
    { label: "Step-by-Step", prompt: "Guide me through this visual step-by-step in your style." }
];

const MATH_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Solve", prompt: "Solve this math problem step-by-step and provide the final answer." },
    { label: "Step-by-Step", prompt: "Break down the solution into clear, numbered steps." },
    { label: "Explain Logic", prompt: "Explain the mathematical concept and logic behind this problem." },
    { label: "Identify Formula", prompt: "Identify the formula or theorem used in this problem." },
    { label: "Geometry", prompt: "Solve for the missing angles or side lengths in this geometry problem." },
    { label: "Word Problem", prompt: "Extract the data from this word problem and solve it." },
    { label: "Graph Analysis", prompt: "Analyze this graph and interpret the function or data shown." },
    { label: "Simplify", prompt: "Simplify the expression shown in the image." }
];

const WRITER_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Analyze Style", prompt: "Analyze the writing style and tone of this text." },
    { label: "Improve Flow", prompt: "Suggest improvements to the flow and readability." },
    { label: "Proofread", prompt: "Check for grammar and spelling errors." },
    { label: "Summarize", prompt: "Provide a concise summary of the content." },
];

const WRITER_DOCUMENT_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Critique", prompt: "Provide a constructive critique of this document." },
    { label: "Edit", prompt: "Suggest edits to improve clarity and impact." },
    { label: "Expand", prompt: "Expand on the key points mentioned in the document." },
    { label: "Format", prompt: "Suggest formatting improvements for better readability." },
];

const DOCTOR_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Identify Symptoms", prompt: "Identify any visible symptoms or conditions." },
    { label: "Medical Advice", prompt: "Provide general medical advice based on the image (Disclaimer: Consult a doctor)." },
    { label: "Analyze Report", prompt: "Explain the medical report or chart shown." },
];

const DOCTOR_DOCUMENT_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Explain Terms", prompt: "Explain any complex medical terms found in the document." },
    { label: "Summarize Report", prompt: "Summarize the key findings of this medical report." },
    { label: " Drug Info", prompt: "Provide information about any medications mentioned." },
];

const EMAIL_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Draft Reply", prompt: "Draft a professional reply to this email screenshot." },
    { label: "Extract Info", prompt: "Extract key contact information and dates." },
    { label: "Summarize", prompt: "Summarize the main points of the email." },
];

const ORGANIZER_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Create Task List", prompt: "Create a task list based on the visual information." },
    { label: "Schedule Event", prompt: "Extract event details for scheduling." },
    { label: "Categorize", prompt: "Categorize the items or information shown." },
];

const GREETINGS_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Identify Occasion", prompt: "Identify the occasion or event shown." },
    { label: "Suggest Greeting", prompt: "Suggest an appropriate greeting or message for this image." },
];

const WORD_HELP_VISION_QUICK_ACTIONS: { label: string; prompt: string }[] = [
    { label: "Identify Words", prompt: "Identify any difficult words in the image." },
    { label: "Define", prompt: "Provide definitions for prominent words." },
    { label: "Synonyms", prompt: "Suggest synonyms for key words in the text." },
];

const SUBJECT_QUICK_PROMPTS: { [key: string]: { label: string; prompt: string }[] } = {
    "General": [
        { label: "Animals", prompt: "Animal Kingdom Trivia" },
        { label: "Current Affairs", prompt: "Current World Events" },
        { label: "General Knowledge", prompt: "General Knowledge Trivia" },
        { label: "Inventions", prompt: "Famous Inventions" },
        { label: "Logic", prompt: "Logic Puzzles & Riddles" },
        { label: "Movies", prompt: "Cinema & Movies" },
        { label: "Personalities", prompt: "Famous Historical Figures" },
        { label: "Pop Culture", prompt: "Pop Culture & Entertainment" },
        { label: "Sports", prompt: "Sports & Athletics" },
        { label: "World Records", prompt: "Guinness World Records" }
    ],
    "English": [
        { label: "Active/Passive", prompt: "Active & Passive Voice" },
        { label: "Articles", prompt: "Articles (A, An, The)" },
        { label: "Cloze Test", prompt: "Cloze Test (Fill in the blanks)" },
        { label: "Conjunctions", prompt: "Conjunctions & Connectors" },
        { label: "Direct/Indirect", prompt: "Direct & Indirect Speech" },
        { label: "Error Spotting", prompt: "Spotting Grammatical Errors" },
        { label: "Figures of Speech", prompt: "Figures of Speech (Simile, Metaphor)" },
        { label: "Grammar", prompt: "English Grammar Rules" },
        { label: "Homophones", prompt: "Homophones & Homonyms" },
        { label: "Idioms", prompt: "Idioms & Phrases" },
        { label: "One Word", prompt: "One Word Substitution" },
        { label: "Para Jumbles", prompt: "Para Jumbles (Sentence Rearrangement)" },
        { label: "Phrasal Verbs", prompt: "Phrasal Verbs" },
        { label: "Prepositions", prompt: "Prepositions" },
        { label: "Reading Comp", prompt: "Reading Comprehension" },
        { label: "Sentence Imp.", prompt: "Sentence Improvement" },
        { label: "Spellings", prompt: "Spelling Correction" },
        { label: "Synonyms", prompt: "Synonyms & Antonyms" },
        { label: "Tenses", prompt: "Verb Tenses" },
        { label: "Unseen Passage", prompt: "Unseen Paragraph and Questions" },
        { label: "Vocabulary", prompt: "Advanced Vocabulary" }
    ],
    "Reasoning": [
        { label: "Analogies", prompt: "Verbal Analogies" },
        { label: "Blood Relations", prompt: "Blood Relations Logic" },
        { label: "Cause & Effect", prompt: "Cause and Effect Reasoning" },
        { label: "Classification", prompt: "Odd One Out Classification" },
        { label: "Clocks/Calendars", prompt: "Clocks and Calendars Problems" },
        { label: "Coding", prompt: "Coding & Decoding Patterns" },
        { label: "Critical", prompt: "Statement & Conclusion" },
        { label: "Data Sufficiency", prompt: "Data Sufficiency" },
        { label: "Decision Making", prompt: "Decision Making Logic" },
        { label: "Dice & Cubes", prompt: "Dice and Cubes Visualization" },
        { label: "Directions", prompt: "Direction Sense Test" },
        { label: "Inequalities", prompt: "Mathematical Inequalities" },
        { label: "Input-Output", prompt: "Machine Input-Output Logic" },
        { label: "Mirror Images", prompt: "Mirror and Water Images" },
        { label: "Number Series", prompt: "Number Series & Sequences" },
        { label: "Puzzles", prompt: "Logical Puzzles" },
        { label: "Ranking", prompt: "Ordering & Ranking" },
        { label: "Seating", prompt: "Seating Arrangement (Circular/Linear)" },
        { label: "Syllogism", prompt: "Syllogism & Logic" },
        { label: "Venn Diagrams", prompt: "Venn Diagrams & Set Logic" }
    ],
    "Art": [
        { label: "Art History", prompt: "History of Art & Movements" },
        { label: "Famous Artists", prompt: "Famous Artists & Their Works" },
        { label: "Modern Art", prompt: "Modern & Contemporary Art" },
        { label: "Painting", prompt: "Painting Techniques & Styles" },
        { label: "Sculptures", prompt: "Famous Sculptures & Sculptors" }
    ],
    "Basic Computer": [
        { label: "Hardware", prompt: "Computer Hardware Components" },
        { label: "Software", prompt: "Types of Software & Operating Systems" },
        { label: "Networking", prompt: "Basics of Computer Networking" },
        { label: "Internet", prompt: "Internet, Web Browsers & Email" },
        { label: "Shortcuts", prompt: "Common Keyboard Shortcuts" },
        { label: "Security", prompt: "Cybersecurity & Viruses" },
        { label: "MS Office", prompt: "Microsoft Office (Word, Excel, PPT)" }
    ],
    "Biology": [
        { label: "Cell Biology", prompt: "Cell Structure & Function" },
        { label: "Genetics", prompt: "DNA, RNA & Inheritance" },
        { label: "Human Anatomy", prompt: "Human Body Systems" },
        { label: "Botany", prompt: "Plant Life & Photosynthesis" },
        { label: "Zoology", prompt: "Animal Kingdom & Physiology" },
        { label: "Evolution", prompt: "Theory of Evolution & Selection" }
    ],
    "Chemistry": [
        { label: "Periodic Table", prompt: "Elements & Periodic Trends" },
        { label: "Organic", prompt: "Organic Chemistry & Carbon Compounds" },
        { label: "Reactions", prompt: "Chemical Reactions & Equations" },
        { label: "Acids & Bases", prompt: "pH Scale, Acids & Bases" },
        { label: "Matter", prompt: "States of Matter & Properties" }
    ],
    "Computer Science": [
        { label: "Algorithms", prompt: "Sorting & Searching Algorithms" },
        { label: "Data Structures", prompt: "Arrays, Lists, Trees & Graphs" },
        { label: "OS", prompt: "Operating System Concepts" },
        { label: "Networking", prompt: "TCP/IP & Network Protocols" },
        { label: "DBMS", prompt: "Database Management Systems" },
        { label: "Cybersecurity", prompt: "Network Security & Cryptography" }
    ],
    "Geography": [
        { label: "World Map", prompt: "Countries, Capitals & Borders" },
        { label: "Topography", prompt: "Mountains, Rivers & Deserts" },
        { label: "Climate", prompt: "Weather Patterns & Climate Zones" },
        { label: "Continents", prompt: "Facts about the Seven Continents" },
        { label: "Oceanography", prompt: "Oceans, Currents & Marine Life" }
    ],
    "History": [
        { label: "Ancient", prompt: "Ancient Civilizations (Egypt, Indus, etc.)" },
        { label: "Medieval", prompt: "Medieval History & Kingdoms" },
        { label: "World Wars", prompt: "World War I & World War II" },
        { label: "Renaissance", prompt: "The Renaissance & Scientific Revolution" },
        { label: "Modern", prompt: "Colonization & Independence Movements" }
    ],
    "Literature": [
        { label: "Classics", prompt: "Classical Literature & Epics" },
        { label: "Authors", prompt: "Famous Authors & Their Biographies" },
        { label: "Poetry", prompt: "Poetic Devices & Famous Poems" },
        { label: "Shakespeare", prompt: "Plays & Sonnets of Shakespeare" },
        { label: "Modern Fiction", prompt: "Contemporary Novels & Styles" }
    ],
    "Machine Learning": [
        { label: "Supervised", prompt: "Regression & Classification" },
        { label: "Unsupervised", prompt: "Clustering & Association" },
        { label: "Deep Learning", prompt: "Neural Networks & Architectures" },
        { label: "NLP", prompt: "Natural Language Processing" },
        { label: "Computer Vision", prompt: "Image Processing & Analysis" },
        { label: "Reinforcement", prompt: "Agent-based Learning & RL" }
    ],
    "Mathematics": [
        { label: "Algebra", prompt: "Equations, Expressions & Variables" },
        { label: "Calculus", prompt: "Limits, Derivatives & Integrals" },
        { label: "Geometry", prompt: "Shapes, Angles & Theorems" },
        { label: "Trigonometry", prompt: "Triangles & Trigonometric Functions" },
        { label: "Statistics", prompt: "Probability, Mean, Median & Mode" }
    ],
    "Physics": [
        { label: "Mechanics", prompt: "Newton's Laws & Motion" },
        { label: "Thermodynamics", prompt: "Heat, Energy & Entropy" },
        { label: "Optics", prompt: "Light, Lenses & Mirrors" },
        { label: "Electricity", prompt: "Circuits & Electromagnetism" },
        { label: "Quantum", prompt: "Atomic Theory & Particle Physics" }
    ],
    "Science": [
        { label: "Space Science", prompt: "Astronomy & Cosmology" },
        { label: "Environmental", prompt: "Ecology & Sustainability" },
        { label: "Forensics", prompt: "Crime Scene Science" },
        { label: "Microbiology", prompt: "Bacteria, Viruses & Fungi" }
    ],
};


const DEFAULT_VOCABULARY: { word: string; definition: string; partOfSpeech: string; phonetic: string; simple: { definition: string; examples: string[] } }[] = [
    { word: "Altruism", definition: "The belief in or practice of disinterested and selfless concern for the well-being of others.", partOfSpeech: "Noun", phonetic: "/ËˆÃ¦l.tru.Éª.zÉ™m/", simple: { definition: "Selfless helping of others.", examples: ["Donating anonymously is an act of altruism."] } } // Decrease preloaded dictionary word only 1 word.
];

const TOOL_QUICK_PROMPTS: { [key: string]: { label: string; prompt: string }[] | { [key: string]: { label: string; prompt: string }[] } } = {
    "teacher": [
        { label: "Algebra", prompt: "Explain the basics of Algebra." },
        { label: "Black Holes", prompt: "Explain Black Holes simply." },
        { label: "Blockchain", prompt: "Explain how Blockchain works." },
        { label: "Calculus", prompt: "Explain the fundamental theorem of Calculus." },
        { label: "Chemistry", prompt: "Explain the Periodic Table trends." },
        { label: "Critical Thinking", prompt: "Teach me how to think critically." },
        { label: "Democracy", prompt: "Explain the concept of Democracy." },
        { label: "Economics", prompt: "Explain Supply and Demand." },
        { label: "Evolution", prompt: "Explain the Theory of Evolution." },
        { label: "Feynman Technique", prompt: "Explain the Feynman Technique for learning." },
        { label: "Financial Lit", prompt: "Explain Compound Interest." },
        { label: "Genetics", prompt: "Explain DNA and Genetics." },
        { label: "Gravity", prompt: "Explain Newton's Law of Gravity." },
        { label: "Mental Math", prompt: "Teach me tricks for fast mental calculation." },
        { label: "Negotiation", prompt: "Teach me basic negotiation skills." },
        { label: "Philosophy", prompt: "Explain Stoicism." },
        { label: "Photosynthesis", prompt: "Explain Photosynthesis." },
        { label: "Psychology", prompt: "Explain Cognitive Dissonance." },
        { label: "Public Speaking", prompt: "Teach me how to give a good speech." },
        { label: "Quantum Physics", prompt: "Explain the basics of Quantum Physics." },
        { label: "Shakespeare", prompt: "Explain the significance of Hamlet." },
        { label: "Statistics", prompt: "Explain Mean, Median, and Mode." },
        { label: "Time Mgmt", prompt: "Teach me the Pomodoro technique." },
        { label: "World War II", prompt: "Explain the causes of World War II." }
    ],
    "ai_for_everyone": [
        { label: "Agriculture", prompt: "How does AI help farmers monitor crops?" },
        { label: "Algorithms", prompt: "How do social media algorithms know what I like?" },
        { label: "Art", prompt: "How do AI art generators create images from text?" },
        { label: "Autonomous Cars", prompt: "How do self-driving cars see the road?" },
        { label: "Banking", prompt: "How does AI detect fraud in banking?" },
        { label: "Customer Service", prompt: "How do AI chatbots understand my problems?" },
        { label: "E-Commerce", prompt: "How do online stores recommend products?" },
        { label: "Education", prompt: "How is AI personalizing learning for students?" },
        { label: "Email", prompt: "How do spam filters work?" },
        { label: "Face ID", prompt: "How does Facial Recognition work on my phone?" },
        { label: "Finance", prompt: "How does AI predict stock market trends?" },
        { label: "Gaming", prompt: "How is AI used in video games for NPCs?" },
        { label: "Healthcare", prompt: "How does AI help doctors diagnose diseases?" },
        { label: "Language", prompt: "How does AI help in learning new languages?" },
        { label: "Manufacturing", prompt: "How are robots using AI in factories?" },
        { label: "Navigation", prompt: "How does Google Maps predict traffic?" },
        { label: "Photography", prompt: "How does my phone camera enhance photos automatically?" },
        { label: "Security", prompt: "How does AI analyze security camera footage?" },
        { label: "Smart Home", prompt: "How do smart thermostats learn my schedule?" },
        { label: "Social Media", prompt: "How does AI filter harmful content online?" },
        { label: "Streaming", prompt: "How does Netflix know what movies I'll like?" },
        { label: "Translation", prompt: "How does Google Translate work instantly?" },
        { label: "Transportation", prompt: "How do ride-sharing apps optimize routes?" },
        { label: "Voice Assistants", prompt: "How do Siri and Alexa understand me?" },
        { label: "Weather", prompt: "How does AI improve weather forecasting?" }
    ],
    "ml_tutor": [
        // Level 1: Foundations
        { label: "History of AI", prompt: "Summarize the History of Artificial Intelligence." },
        { label: "ML Basics", prompt: "Explain the fundamental paradigms of Machine Learning. Use [[CONCEPT_CARD]] for key definitions." },
        { label: "Supervised", prompt: "Explain Supervised Learning algorithms (Regression, Classification)." },
        { label: "Unsupervised", prompt: "Explain Unsupervised Learning and Dimensionality Reduction." },
        { label: "Reinforcement", prompt: "Explain Reinforcement Learning (RL) and Q-Learning. Use [[CONCEPT_CARD]] for the Bellman equation." },
        { label: "Overfitting", prompt: "Explain Overfitting, Underfitting, and Regularization." },
        { label: "Gradient Descent", prompt: "Explain Gradient Descent optimization and its variants (Adam, SGD). Use [[CONCEPT_CARD]] for the update rule." },
        { label: "Bias & Ethics", prompt: "Explain Bias, Fairness, and Ethics in AI systems." },
        // Level 2: Core Algorithms & Neural Networks
        { label: "Clustering", prompt: "Explain K-Means and Hierarchical Clustering algorithms." },
        { label: "SVMs", prompt: "Explain Support Vector Machines (SVMs). Use [[CONCEPT_CARD]] for the hyperplane formula." },
        { label: "Neural Networks", prompt: "Explain the anatomy and math of Neural Networks. Use [[CONCEPT_CARD]] for activation functions." },
        { label: "Backprop", prompt: "Explain the Backpropagation algorithm in Neural Networks. Use [[CONCEPT_CARD]] for chain rule." },
        { label: "Deep Learning", prompt: "Explain Deep Learning fundamentals and how it differs from ML." },
        { label: "CNNs", prompt: "Explain Convolutional Neural Networks (CNNs) and their layers." },
        { label: "RNNs", prompt: "Explain Recurrent Neural Networks (RNNs)." },
        { label: "LSTM/GRU", prompt: "Explain LSTMs and GRUs for sequence modeling." },
        // Level 3: Advanced Architectures & NLP
        { label: "NLP", prompt: "Explain Natural Language Processing (NLP) core tasks." },
        { label: "Embeddings", prompt: "Explain Vector Embeddings and semantic search." },
        { label: "Transformers", prompt: "Explain the Transformer architecture (Encoder/Decoder). Use [[CONCEPT_CARD]] for Attention mechanism." },
        { label: "Attention", prompt: "Explain the Self-Attention mechanism in Transformers. Use [[CONCEPT_CARD]] for Q, K, V formulas." },
        { label: "LLMs", prompt: "Explain the architecture and training of Large Language Models." },
        { label: "RAG", prompt: "Explain Retrieval-Augmented Generation (RAG) systems." },
        { label: "Fine-Tuning", prompt: "Explain Fine-Tuning, PEFT, and LoRA techniques." },
        { label: "Prompt Eng.", prompt: "Explain detailed Prompt Engineering strategies for developers." },
        // Level 4: Generative AI & Specialized
        { label: "Computer Vision", prompt: "Explain the core concepts and tasks in Computer Vision." },
        { label: "GANs", prompt: "Explain Generative Adversarial Networks (GANs) architecture. Use [[CONCEPT_CARD]] for loss functions." },
        { label: "Diffusion", prompt: "Explain how Diffusion Models (like Stable Diffusion) work." },
        { label: "Data Augmentation", prompt: "Explain Data Augmentation techniques for image and text." },
        { label: "Agents", prompt: "Explain Autonomous AI Agents and their architectures." },
        { label: "XAI", prompt: "Explain Explainable AI (XAI) and interpretability tools (SHAP, LIME)." },
        { label: "Model Deploy", prompt: "Explain ML Model Deployment strategies (ONNX, Docker, Serving)." }
    ],
    "ai_usage": [
        { label: "Brainstorming", prompt: "How to use AI to generate creative ideas for a project?" },
        { label: "Budgeting", prompt: "How to use AI to create a monthly budget plan?" },
        { label: "Conflict Resolution", prompt: "How to use AI to roleplay difficult conversations?" },
        { label: "Cooking", prompt: "How to use AI for meal planning based on ingredients I have?" },
        { label: "DIY Projects", prompt: "How to use AI to get step-by-step DIY instructions?" },
        { label: "Emails", prompt: "How to use AI to write and refine professional emails?" },
        { label: "Entertainment", prompt: "How to use AI to find movies similar to my favorites?" },
        { label: "Fitness", prompt: "How to use AI to create a personalized workout plan?" },
        { label: "Gardening", prompt: "How to use AI to identify plants and care for them?" },
        { label: "Gift Ideas", prompt: "How to use AI to find the perfect gift based on interests?" },
        { label: "Interview", prompt: "How to use AI to simulate a job interview?" },
        { label: "Learning", prompt: "How to use AI as a personal language tutor?" },
        { label: "Mental Health", prompt: "How to use AI for daily journaling and reflection?" },
        { label: "Negotiation", prompt: "How to use AI to practice salary negotiation?" },
        { label: "Scheduling", prompt: "How to use AI to organize my daily schedule?" },
        { label: "Shopping", prompt: "How to use AI to compare products and find deals?" },
        { label: "Study", prompt: "How to use AI to summarize long PDFs or articles?" },
        { label: "Time Mgmt", prompt: "How to use AI to prioritize tasks using the Eisenhower Matrix?" },
        { label: "Travel", prompt: "How to use AI to plan a complete vacation itinerary?" },
        { label: "Writing", prompt: "How to use AI to overcome writer's block?" }
    ],
    "prompt_engineer": [
        // Level 1: Fundamentals
        { label: "Zero-Shot", prompt: "Explain Zero-Shot Prompting." },
        { label: "Persona", prompt: "Explain Persona/Role-based prompting." },
        { label: "Context", prompt: "Explain the importance of Context in prompting." },
        { label: "Delimiters", prompt: "How to use delimiters (like triple quotes or XML tags) to structure prompts?" },
        { label: "Format Output", prompt: "How to force specific output formats (JSON/CSV)?" },

        // Level 2: Core Techniques
        { label: "Few-Shot", prompt: "Explain Few-Shot Prompting with examples." },
        { label: "Chain of Thought", prompt: "Explain Chain of Thought (CoT) prompting." },
        { label: "Step-by-Step", prompt: "Why does 'Let's think step by step' work?" },
        { label: "Constraints", prompt: "How to effectively use constraints in prompts?" },
        { label: "Iterative Refinement", prompt: "Explain the iterative prompting process for better results." },

        // Level 3: Advanced Strategies
        { label: "Self-Consistency", prompt: "Explain Self-Consistency prompting." },
        { label: "Tree of Thoughts", prompt: "Explain Tree of Thoughts (ToT) prompting." },
        { label: "Generated Knowledge", prompt: "Explain Generated Knowledge Prompting." },
        { label: "Least-to-Most", prompt: "Explain Least-to-Most prompting technique." },
        { label: "Meta-Prompting", prompt: "What is Meta-Prompting and how to use it?" },

        // Level 4: System & Optimization
        { label: "System Prompts", prompt: "What are System Prompts and how do they differ from User prompts?" },
        { label: "Temperature", prompt: "Explain the 'Temperature' parameter in LLMs." },
        { label: "Hallucinations", prompt: "Techniques to reduce AI hallucinations." },
        { label: "Multi-Persona", prompt: "How to use Multi-Persona prompting for debate or critique?" },
        { label: "Refine Prompt", prompt: "Refine this prompt: 'Write a blog post about coffee'." }
    ],
    "grammar_guide": [
        // Unit 1: The Basics (Parts of Speech)
        { label: "Nouns", prompt: "Explain Countable vs Uncountable Nouns." },
        { label: "Pronouns", prompt: "Explain Subject and Object Pronouns." },
        { label: "Verbs", prompt: "Explain Regular vs Irregular Verbs." },
        { label: "Adjectives", prompt: "Explain Order of Adjectives" },
        { label: "Adverbs", prompt: "Explain the function and placement of Adverbs." },
        // Unit 2: Sentence Structure
        { label: "Articles", prompt: "Explain the use of A, An, and The." },
        { label: "Prepositions", prompt: "Explain Prepositions of Place" },
        { label: "Conjunctions", prompt: "Explain Coordinating and Subordinating Conjunctions." },
        { label: "Subject-Verb", prompt: "Explain Subject-Verb Agreement rules." },
        // Unit 3: Tenses & Modes
        { label: "Tenses", prompt: "Explain Past Perfect Tense" },
        { label: "Modals", prompt: "Explain Modal Verbs (Can, Could, Should)." },
        { label: "Passive Voice", prompt: "Explain Passive vs Active Voice" },
        { label: "Gerunds", prompt: "Explain Gerunds vs Infinitives." },
        // Unit 4: Advanced Composition
        { label: "Conditionals", prompt: "Explain Zero and First Conditionals" },
        { label: "Punctuation", prompt: "Explain the use of Semicolons" }
    ],
    "idiom_guide": [
        { label: "Business", prompt: "Teach me 3 popular business idioms used in the workplace." },
        { label: "Emotions", prompt: "Teach me 3 idioms used to describe strong emotions." },
        { label: "Animals", prompt: "Teach me 3 funny idioms involving animals." },
        { label: "Time", prompt: "Teach me 3 useful idioms related to time." },
        { label: "Weather", prompt: "Teach me 3 common idioms related to weather." },
        { label: "Food", prompt: "Teach me 3 interesting idioms involving food." },
        { label: "Colors", prompt: "Teach me 3 idioms related to colors." },
        { label: "Relationships", prompt: "Teach me 3 idioms about friendship and relationships." },
        { label: "Success", prompt: "Teach me 3 idioms about success and failure." },
        { label: "Random", prompt: "Teach me 3 random, interesting English idioms." },
        { label: "Body Parts", prompt: "Teach me 3 idioms involving body parts (e.g., 'Cold feet')." },
        { label: "Sports", prompt: "Teach me 3 idioms that originated from sports." },
        { label: "Music", prompt: "Teach me 3 idioms related to music." },
        { label: "Travel", prompt: "Teach me 3 idioms related to travel or movement." },
        { label: "Education", prompt: "Teach me 3 idioms related to school or learning." },
        { label: "Health", prompt: "Teach me 3 idioms about health and sickness." },
        { label: "Numbers", prompt: "Teach me 3 idioms involving numbers." },
        { label: "Nature", prompt: "Teach me 3 idioms involving nature or the outdoors." }
    ],
    "writer": [
        { label: "Application", prompt: "Write a formal Application for..." },
        { label: "Article", prompt: "Write a comprehensive Article about..." },
        { label: "Biography", prompt: "Write a biographical profile of..." },
        { label: "Blog Post", prompt: "Write an engaging Blog Post about..." },
        { label: "Case Study", prompt: "Write a Case Study analyzing..." },
        { label: "Cover Letter", prompt: "Write a professional Cover Letter for..." },
        { label: "Email", prompt: "Draft a professional Email regarding..." },
        { label: "Essay", prompt: "Write a structured Essay on..." },
        { label: "Feature Story", prompt: "Write a narrative Feature Story about..." },
        { label: "Future Outlook", prompt: "Write a speculative piece about the future of..." },
        { label: "How-To Guide", prompt: "Write a step-by-step Guide on..." },
        { label: "Letter", prompt: "Write a formal Letter to..." },
        { label: "News Report", prompt: "Write an objective News Report about..." },
        { label: "Opinion Piece", prompt: "Write a persuasive Opinion Piece arguing that..." },
        { label: "Review", prompt: "Write a balanced Review of..." },
        { label: "Speech", prompt: "Write an inspiring Speech about..." }
    ],
    "health_guide": [
        { label: "Symptom Check", prompt: "I am feeling [Symptoms]. What could this be?" },
        { label: "Cold/Flu", prompt: "I have a runny nose, sore throat, and mild fever. How should I treat it at home?" },
        { label: "Headache", prompt: "I have a throbbing headache. What are the likely causes and remedies?" },
        { label: "Stomach Pain", prompt: "I have a stomach ache after eating. Advise me on diet and relief." },
        { label: "Skin Rash", prompt: "I have a red, itchy rash. What are common causes and treatments?" },
        { label: "Insomnia", prompt: "I cannot sleep properly. Give me a medical plan to fix my sleep schedule." },
        { label: "Diet Plan", prompt: "Create a healthy diet plan for general well-being." },
        { label: "Anxiety", prompt: "I am feeling very anxious and stressed. Suggest coping mechanisms." },
        { label: "Fitness", prompt: "Suggest a beginner exercise routine for better heart health." },
        { label: "First Aid", prompt: "What are the immediate first aid steps for a minor burn/cut?" }
    ],

    "greetings_gen": {
        "greeting": [
            { label: "Birthday", prompt: "Write a touching birthday wish for a friend that also motivates them to achieve their goals this year." },
            { label: "Anniversary", prompt: "Write an anniversary message that celebrates love and motivates us to build a great future together." },
            { label: "New Year", prompt: "Write New Year wishes that inspire hope, resilience, and success for the coming year." },
            { label: "Get Well", prompt: "Write a get well message that encourages resilience and a strong recovery." },
            { label: "Diwali/Fest", prompt: "Write festival greetings that inspire light, positivity, and new beginnings." },
            { label: "Christmas", prompt: "Write Christmas wishes that inspire joy, kindness, and giving." },
            { label: "Eid", prompt: "Write Eid wishes that inspire peace, gratitude, and spiritual growth." },
            { label: "Thank You", prompt: "Write a thank you note that appreciates the gesture and motivates the person." },
            { label: "Promotion", prompt: "Write a congratulatory message for a promotion that inspires them to embrace new challenges." },
            { label: "Farewell", prompt: "Write a farewell message for a coworker that motivates them to conquer their new path." }
        ],
        "quote": [
            { label: "Success", prompt: "Generate 5 powerful motivational quotes about Success." },
            { label: "Hard Work", prompt: "Generate 5 inspiring quotes about Hard Work and Persistence." },
            { label: "Life", prompt: "Generate 5 deep philosophical quotes about Life." },
            { label: "Morning", prompt: "Generate 5 positive Good Morning quotes to start the day." },
            { label: "Failure", prompt: "Generate 5 encouraging quotes about overcoming Failure." },
            { label: "Confidence", prompt: "Generate 5 quotes to boost Self-Confidence." },
            { label: "Focus", prompt: "Generate 5 quotes about Focus and Discipline." },
            { label: "Change", prompt: "Generate 5 quotes about embracing Change." }
        ],
        "shayari": [
            { label: "Study Motivation", prompt: "Write a motivating Shayari about the importance of studying and hard work for students (in Hindi/Urdu style with English translation)." },
            { label: "Success (Jeet)", prompt: "Write an inspiring Shayari about achieving success (Jeet) through struggle." },
            { label: "Hard Work", prompt: "Write a powerful Shayari about the value of hard work (Mehnat) in student life." },
            { label: "Knowledge (Ilm)", prompt: "Write a beautiful Shayari about the power of knowledge (Ilm/Vidya)." },
            { label: "Dreams", prompt: "Write an encouraging Shayari about chasing dreams and ambitions." },
            { label: "Focus", prompt: "Write a Shayari about staying focused and avoiding distractions." },
            { label: "Teacher (Guru)", prompt: "Write a respectful Shayari dedicated to Teachers (Guru/Ustad)." },
            { label: "Never Give Up", prompt: "Write a Shayari about resilience and never giving up during exams." }
        ]
    },


    "study_planner": [
        { label: "Python (2 Weeks)", prompt: "Create a 2-week curriculum to learn Python basics from scratch." },
        { label: "Exam Cram (3 Days)", prompt: "Create a 3-day emergency revision plan for an upcoming History/Science exam." },
        { label: "Web Dev (1 Month)", prompt: "Create a 1-month roadmap to learn HTML, CSS, and JavaScript basics." },
        { label: "Language Basics", prompt: "Create a 14-day plan to learn conversational Spanish/French for travel." },
        { label: "Data Science", prompt: "Create a 3-month comprehensive roadmap for getting started with Data Science." },
        { label: "Calculus Review", prompt: "Create a 5-day refresher plan for key Calculus I concepts." },
        { label: "SAT Prep", prompt: "Create a 4-week study schedule for SAT preparation." },
        { label: "Public Speaking", prompt: "Create a 1-week practical plan to improve public speaking skills." },
        { label: "Machine Learning", prompt: "Create a 6-week roadmap to learn the fundamentals of Machine Learning." },
        { label: "Photography", prompt: "Create a 10-day plan to master the basics of digital photography." }
    ],
    "math_solver": [
        { label: "Algebra", prompt: "Solve for x: 3x - 7 = 14. Use [[CONCEPT_CARD]] for the solution steps." },
        { label: "Derivative", prompt: "Calculate the derivative of f(x) = 3x^2 + 5x. Use [[CONCEPT_CARD]] for the rules used." },
        { label: "Pythagoras", prompt: "Find the hypotenuse of a right triangle with sides 3 and 4. Use [[CONCEPT_CARD]] for the calculation." },
        { label: "Statistics", prompt: "Calculate the Mean, Median, and Mode of: 5, 2, 8, 2, 9." },
        { label: "Quadratic", prompt: "Solve x^2 - 5x + 6 = 0 using the quadratic formula. Use [[CONCEPT_CARD]] for the formula." },
        { label: "Fractions", prompt: "Calculate 3/4 + 2/5 and simplify. Use [[CONCEPT_CARD]] for steps." },
        { label: "Trig", prompt: "Calculate the value of sin(30Â°) + cos(60Â°)." },
        { label: "Geometry", prompt: "Calculate the area of a circle with radius 5. Use [[CONCEPT_CARD]] for the formula." },
        { label: "Matrix", prompt: "Multiply matrices: [[1, 2], [3, 4]] * [[1, 0], [0, 1]]. Use [[CONCEPT_CARD]] for the matrix." },
        { label: "Logarithms", prompt: "Evaluate log10(1000)." }
    ],
    "debate_coach": [
        { label: "Trending News", prompt: "Pick a random, controversial topic from recent global news (Politics, Environment, Economics, or Society). Generate a debate on it." },
        { label: "AI Safety", prompt: "Debate Topic: Artificial Intelligence is a threat to humanity." },
        { label: "Remote Work", prompt: "Debate Topic: Remote work is better than office work." },
        { label: "Social Media", prompt: "Debate Topic: Social media does more harm than good." },
        { label: "UBI", prompt: "Debate Topic: Universal Basic Income is necessary for the future." },
        { label: "Space Exp.", prompt: "Debate Topic: Space exploration is a waste of resources vs essential for survival." },
        { label: "Climate", prompt: "Debate Topic: Individual action vs Corporate regulation for Climate Change." },
        { label: "Education", prompt: "Debate Topic: Traditional college degrees are becoming obsolete." },
        { label: "Privacy", prompt: "Debate Topic: Privacy is dead in the digital age." },
        { label: "Genetic Eng.", prompt: "Debate Topic: Genetic engineering of humans should be banned." },
        { label: "Nuclear", prompt: "Debate Topic: Nuclear energy is the greenest solution." }
    ],

};

const LANGUAGE_CODES: { [key: string]: string } = {
    "English": "en-US",
    "Hindi": "hi-IN",
    "Spanish": "es-ES",
    "French": "fr-FR",
    "German": "de-DE",
    "Italian": "it-IT",
    "Japanese": "ja-JP",
    "Korean": "ko-KR",
    "Chinese": "zh-CN",
    "Russian": "ru-RU",
    "Portuguese": "pt-BR",
    "Arabic": "ar-SA",
    "Dutch": "nl-NL",
    "Swedish": "sv-SE",
    "Turkish": "tr-TR"
};

const THEMES: { [key: string]: any } = {
    day: { id: 'day', label: 'Day', bg: "#ffffff", text: "#1a1a1a", secondary: "#555555", uiBg: "#f8f9fa", border: "#e9ecef", highlight: "#e7f5ff", buttonBg: "#f1f3f5", bubbleUser: "#2563eb", bubbleAI: "#f8f9fa", inputBg: "#f1f3f5", logoBg: "#4f46e5", logoText: "#ffffff", toolColor: null, activeWord: "#bfdbfe", primary: "#2563eb", statusBarStyle: "light-content" },
    sepia: { id: 'sepia', label: 'E-Reader', bg: "#f8f1e3", text: "#5b4636", secondary: "#8c7b66", uiBg: "#f1eadd", border: "#e3dccf", highlight: "#e8dfce", buttonBg: "#e8dfce", bubbleUser: "#8c7b66", bubbleAI: "#f1eadd", inputBg: "#e3dccf", logoBg: "#8c7b66", logoText: "#f5e6d3", toolColor: ["#a89f91", "#8c7b66"], activeWord: "#d6cbb6", primary: "#8c7b66", statusBarStyle: "dark-content" },
    night: { id: 'night', label: 'Night', bg: "#000000", text: "#e5e5e5", secondary: "#a3a3a3", uiBg: "#121212", border: "#27272a", highlight: "#1f2937", buttonBg: "#18181b", bubbleUser: "#4b5563", bubbleAI: "#18181b", inputBg: "#18181b", logoBg: "#e5e5e5", logoText: "#000000", toolColor: ["#1f2937", "#374151"], activeWord: "#374151", primary: "#2563eb", statusBarStyle: "light-content" },
    midnight: { id: 'midnight', label: 'Midnight', bg: "#0f172a", text: "#cbd5e1", secondary: "#94a3b8", uiBg: "#1e293b", border: "#334155", highlight: "#1e293b", buttonBg: "#334155", bubbleUser: "#3b82f6", bubbleAI: "#1e293b", inputBg: "#0f172a", logoBg: "#cbd5e1", logoText: "#0f172a", toolColor: ["#1e293b", "#334155"], activeWord: "#3b82f6", primary: "#3b82f6", statusBarStyle: "light-content" },
    forest: { id: 'forest', label: 'Forest', bg: "#f0fdf4", text: "#14532d", secondary: "#166534", uiBg: "#dcfce7", border: "#bbf7d0", highlight: "#dcfce7", buttonBg: "#bbf7d0", bubbleUser: "#16a34a", bubbleAI: "#dcfce7", inputBg: "#f0fdf4", logoBg: "#166534", logoText: "#f0fdf4", toolColor: null, activeWord: "#86efac", primary: "#16a34a", statusBarStyle: "dark-content" },
    lavender: { id: 'lavender', label: 'Lavender', bg: "#faf5ff", text: "#581c87", secondary: "#7e22ce", uiBg: "#f3e8ff", border: "#e9d5ff", highlight: "#f3e8ff", buttonBg: "#e9d5ff", bubbleUser: "#9333ea", bubbleAI: "#f3e8ff", inputBg: "#faf5ff", logoBg: "#7e22ce", logoText: "#faf5ff", toolColor: null, activeWord: "#d8b4fe", primary: "#9333ea", statusBarStyle: "dark-content" },
    pink: { id: 'pink', label: 'Pink', bg: "#fdf2f8", text: "#831843", secondary: "#be185d", uiBg: "#fce7f3", border: "#fbcfe8", highlight: "#fce7f3", buttonBg: "#fbcfe8", bubbleUser: "#db2777", bubbleAI: "#fce7f3", inputBg: "#fdf2f8", logoBg: "#be185d", logoText: "#fdf2f8", toolColor: null, activeWord: "#f9a8d4", primary: "#db2777", statusBarStyle: "dark-content" },
    yellow: { id: 'yellow', label: 'Sunny', bg: "#fefce8", text: "#422006", secondary: "#a16207", uiBg: "#fef9c3", border: "#fde047", highlight: "#fef08a", buttonBg: "#fde047", bubbleUser: "#ca8a04", bubbleAI: "#fef9c3", inputBg: "#fefce8", logoBg: "#ca8a04", logoText: "#ffffff", toolColor: null, activeWord: "#fde047", primary: "#ca8a04", statusBarStyle: "dark-content" },
    // NEW THEMES
    coffee: { id: 'coffee', label: 'Coffee', bg: "#201a16", text: "#d6c4b0", secondary: "#8a7b6b", uiBg: "#2c241f", border: "#3e322b", highlight: "#2c241f", buttonBg: "#3e322b", bubbleUser: "#a67c52", bubbleAI: "#2c241f", inputBg: "#2c241f", logoBg: "#a67c52", logoText: "#201a16", toolColor: ["#2c241f", "#3e322b"], activeWord: "#43302b", primary: "#a67c52", statusBarStyle: "light-content" },
    nord: { id: 'nord', label: 'Nord', bg: "#2e3440", text: "#d8dee9", secondary: "#81a1c1", uiBg: "#3b4252", border: "#4c566a", highlight: "#3b4252", buttonBg: "#434c5e", bubbleUser: "#88c0d0", bubbleAI: "#3b4252", inputBg: "#3b4252", logoBg: "#88c0d0", logoText: "#2e3440", toolColor: ["#3b4252", "#434c5e"], activeWord: "#434c5e", primary: "#88c0d0", statusBarStyle: "light-content" },
    ocean: { id: 'ocean', label: 'Ocean', bg: "#f0f9ff", text: "#0c4a6e", secondary: "#0284c7", uiBg: "#e0f2fe", border: "#bae6fd", highlight: "#e0f2fe", buttonBg: "#bae6fd", bubbleUser: "#0ea5e9", bubbleAI: "#e0f2fe", inputBg: "#f0f9ff", logoBg: "#0284c7", logoText: "#f0f9ff", toolColor: null, activeWord: "#7dd3fc", primary: "#0284c7", statusBarStyle: "dark-content" },
    slate: { id: 'slate', label: 'Slate', bg: "#f8fafc", text: "#334155", secondary: "#64748b", uiBg: "#e2e8f0", border: "#cbd5e1", highlight: "#e2e8f0", buttonBg: "#cbd5e1", bubbleUser: "#475569", bubbleAI: "#e2e8f0", inputBg: "#f8fafc", logoBg: "#475569", logoText: "#f8fafc", toolColor: null, activeWord: "#94a3b8", primary: "#475569", statusBarStyle: "dark-content" },
};

// --- Helper Functions ---
const generateId = (): string => Math.random().toString(36).substr(2, 9);

const getFontFamily = (family: string): string => {
    if (family === 'Classic') {
        return Platform.OS === 'ios' ? 'Georgia' : 'serif';
    }
    if (family === 'Typewriter') {
        return Platform.OS === 'ios' ? 'Courier New' : 'monospace';
    }
    if (family === 'Rounded') {
        return Platform.OS === 'ios' ? 'Arial Rounded MT Bold' : 'sans-serif-rounded';
    }
    if (family === 'Elegant') {
        return Platform.OS === 'ios' ? 'Palatino' : 'serif';
    }
    if (family === 'Compact') {
        return Platform.OS === 'ios' ? 'Arial Narrow' : 'sans-serif-condensed';
    }
    if (family === 'Minimalist') {
        return Platform.OS === 'ios' ? 'Avenir Next' : 'sans-serif-light';
    }
    if (family === 'Casual') {
        return Platform.OS === 'ios' ? 'Chalkboard SE' : 'sans-serif-medium';
    }
    // Modern (Default) and fallback
    return Platform.OS === 'ios' ? 'System' : 'sans-serif';
};

const getTypographyStyle = (family: string, styles: string[] = []): any => {
    const base: any = { fontFamily: getFontFamily(family) };
    if (styles.includes('Bold')) base.fontWeight = 'bold';
    if (styles.includes('Italic')) base.fontStyle = 'italic';

    // NEW: Fix for non-English text clipping on Android (e.g. Hindi matras)
    if (Platform.OS === 'android') {
        base.includeFontPadding = false;
        base.textAlignVertical = 'center';
    }

    let decorations: string[] = [];
    if (styles.includes('Underlined')) decorations.push('underline');
    if (styles.includes('Strikethrough')) decorations.push('line-through');
    if (decorations.length > 0) base.textDecorationLine = decorations.join(' ');

    if (styles.includes('Wide')) base.letterSpacing = 1.5;

    return base;
};

const formatTimer = (totalSeconds: number): string => {
    const minutes: number = Math.floor(totalSeconds / 60);
    const seconds: number = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
};

const formatDuration = (ms: number): string => {
    const seconds: number = Math.floor(ms / 1000);
    if (seconds < 60) return `${seconds}s`;
    const minutes: number = Math.floor(seconds / 60);
    const remainingSeconds: number = seconds % 60;
    return `${minutes}m ${remainingSeconds}s`;
};

// NEW: Helper for safe filename from title
const getSafeFileName = (str: string): string => {
    if (!str) return "Audio";
    return str.replace(/[^a-zA-Z0-9\-_]/g, '_').substring(0, 60); // Limit length to avoid OS errors
};

// Generate a filename-safe hash for string content
const simpleHash = (str: string): string => {
    let hash: number = 0;
    for (let i = 0; i < str.length; i++) {
        const char: number = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
};

const isPdf = (uri: string): boolean => {
    if (!uri) return false;
    return uri.toLowerCase().endsWith('.pdf') || uri.startsWith('application/pdf');
};

// --- WAV Header Utilities for Gemini TTS ---
const keyStr: string = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

const decodeBase64 = (input: string): Uint8Array => {
    let output: number[] = [];
    let chr1: number, chr2: number, chr3: number;
    let enc1: number, enc2: number, enc3: number, enc4: number;
    let i: number = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        output.push(chr1);
        if (enc3 != 64) output.push(chr2);
        if (enc4 != 64) output.push(chr3);
    }
    return new Uint8Array(output);
};

// UPDATED: Optimized Base64 Encoder for Large Audio Files
const encodeBase64 = (input: Uint8Array): string => {
    const keyStr: string = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let output: string = ""; // Use string concatenation for smaller memory footprint in JSI vs Array.join for massive arrays
    let chr1: number, chr2: number, chr3: number, enc1: number, enc2: number, enc3: number, enc4: number;
    let i: number = 0;
    const len: number = input.length;

    // Chunk the processing to avoid blocking UI too long
    while (i < len) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (chr2 === undefined) {
            enc3 = enc4 = 64;
        } else if (chr3 === undefined) {
            enc4 = 64;
        }

        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }

    return output;
};

// UPDATED: High-Performance WAV Conversion (Zero-Copy)
// Instead of decoding/encoding the massive PCM string, we generate a 54-byte header
// (which includes a padding chunk to align to 3 bytes) and simply concatenate the strings.
// This reduces processing time for a 1MB file from ~1.5s to ~1ms.
// Helper to write ASCII strings to DataView
const writeString = (view: DataView, offset: number, string: string) => {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
};

// NEW: Convert Base64 PCM to WAV (Instant Header Prepend)
const pcmToWav = (base64Pcm: string, sampleRate: number = 24000): string => {
    // 1. Calculate PCM byte size from Base64 length
    // Base64 is 4 chars per 3 bytes. Padding '=' indicates fewer bytes.
    let pcmLength: number = (base64Pcm.length * 3) / 4;
    if (base64Pcm.endsWith('==')) pcmLength -= 2;
    else if (base64Pcm.endsWith('=')) pcmLength -= 1;

    // 2. Create Header Buffer (54 bytes)
    // We add a 'PAD ' chunk (10 bytes) to align the total header to 54 bytes.
    // 54 is divisible by 3, allowing clean Base64 concatenation without bit-shifting the PCM data.
    const header: ArrayBuffer = new ArrayBuffer(54);
    const view: DataView = new DataView(header);

    // RIFF Chunk
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + 10 + pcmLength, true); // File size - 8 (+10 for PAD chunk)
    writeString(view, 8, 'WAVE');

    // fmt Chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // Subchunk1Size
    view.setUint16(20, 1, true); // PCM
    view.setUint16(22, 1, true); // Mono
    view.setUint32(24, sampleRate, true); // SampleRate
    view.setUint32(28, sampleRate * 2, true); // ByteRate
    view.setUint16(32, 2, true); // BlockAlign
    view.setUint16(34, 16, true); // BitsPerSample

    // PAD Chunk (Alignment Hack)
    writeString(view, 36, 'PAD '); // Custom Padding Chunk
    view.setUint32(40, 2, true); // Size of padding data
    view.setUint16(44, 0, true); // 2 bytes of zeros

    // data Chunk
    writeString(view, 46, 'data');
    view.setUint32(50, pcmLength, true);

    // 3. Encode Header to Base64
    const headerBytes: Uint8Array = new Uint8Array(header);
    const headerBase64: string = encodeBase64(headerBytes);

    // 4. Concatenate (Instant)
    return headerBase64 + base64Pcm;
};

const ensureImageIsSavedToFile = async (uri: string): Promise<string> => {
    if (!uri || !uri.startsWith('data:')) return uri;
    try {
        const filename: string = `${generateId()}.jpg`;
        const docDir: string | null = (fs as any).documentDirectory || FileSystem.documentDirectory;
        const filepath: string = `${docDir}${filename}`;
        const base64Data: string = uri.split(',')[1];
        await fs.writeAsStringAsync(filepath, base64Data, { encoding: 'base64' });
        return filepath;
    } catch (e) {
        console.log("Error saving image to file", e);
        return uri;
    }
};

// NEW: Helper to format LaTeX math to Unicode for display
const formatMathForDisplay = (text: string): string => {
    if (!text) return "";
    let clean: string = text;

    // 1. Basic Replacements
    const replacements: { [key: string]: string } = {
        '\\\\propto': 'âˆ',
        '\\\\approx': 'â‰ˆ',
        '\\\\neq': 'â‰ ',
        '\\\\leq': 'â‰¤',
        '\\\\le': 'â‰¤',
        '\\\\geq': 'â‰¥',
        '\\\\ge': 'â‰¥',
        '\\\\times': 'Ã—',
        '\\\\cdot': 'â‹…',
        '\\\\pm': 'Â±',
        '\\\\rightarrow': 'â†’',
        '\\\\implies': 'â‡’',
        '\\\\infty': 'âˆž',
        '\\\\int': 'âˆ«',
        '\\\\partial': 'âˆ‚',
        '\\\\nabla': 'âˆ‡',
        '\\\\Delta': 'Î”',
        '\\\\pi': 'Ï€',
        '\\\\theta': 'Î¸',
        '\\\\lambda': 'Î»',
        '\\\\sigma': 'Ïƒ',
        '\\\\omega': 'Ï‰',
        '\\\\alpha': 'Î±',
        '\\\\beta': 'Î²',
        '\\\\gamma': 'Î³',
        '\\\\mu': 'Î¼',
        '\\\\epsilon': 'Îµ',
        '\\\\rho': 'Ï',
        '\\\\circ': 'Â°',
        '\\\\degree': 'Â°'
    };

    // 2. Fractions: \frac{a}{b} -> (a/b)
    // IMPROVED REGEX: Handles optional spaces and basic nesting
    clean = clean.replace(/\\frac\s*\{([^{}]+)\}\s*\{([^{}]+)\}/g, '($1/$2)');
    // Handle simple space separated: \frac a b (rare but possible)
    clean = clean.replace(/\\frac\s+(\w+)\s+(\w+)/g, '($1/$2)');
    // Handle derivatives specifically if they look like \frac{d...}{d...}
    clean = clean.replace(/\\frac\s*\{d\s*([^{}]+)\}\s*\{d\s*([^{}]+)\}/g, 'd$1/d$2');

    // 3. Roots
    clean = clean.replace(/\\sqrt\s*\{([^{}]+)\}/g, 'âˆš($1)');

    // 4. Formatting
    clean = clean.replace(/\\text\s*\{([^{}]+)\}/g, '$1');
    clean = clean.replace(/\\mathbf\s*\{([^{}]+)\}/g, '$1');
    clean = clean.replace(/\\mathrm\s*\{([^{}]+)\}/g, '$1');

    // 5. Apply Map replacements
    Object.keys(replacements).forEach(key => {
        clean = clean.replace(new RegExp(key, 'g'), replacements[key]);
    });

    // 6. Sub/Superscripts cleanup (remove braces)
    clean = clean.replace(/\^\{([^{}]+)\}/g, '^$1');
    clean = clean.replace(/_\{([^{}]+)\}/g, '_$1');

    // 7. Cleanup remaining latex garbage
    clean = clean.replace(/\\left/g, '');
    clean = clean.replace(/\\right/g, '');
    clean = clean.replace(/\\/g, ''); // Remove remaining backslashes

    // 8. Final Polish: Fix common spacing issues in formulas
    clean = clean.replace(/\s*\/\s*/g, '/'); // Tighten division (a / b) -> (a/b)
    clean = clean.replace(/\s*\^\s*/g, '^'); // Tighten exponent

    return clean;
};

// Helper to parse only metadata from session JSON (Lightweight List)
const parseSessionLite = (jsonString: string) => {
    try {
        const full = JSON.parse(jsonString);
        return {
            id: full.id,
            title: full.title,
            timestamp: full.timestamp,
            toolId: full.toolId,
            lastOpened: full.lastOpened,
            pinned: full.pinned,
            partNumber: full.partNumber,
            contentPath: full.contentPath,
            hasAudio: full.hasAudio,
            // Create a preview if messages exist (First 100 chars, no newlines)
            // BUG FIX: Check for explicit preview field first (for items stored in files)
            preview: full.preview || full.messages?.[0]?.content?.substring(0, 100).replace(/\n/g, ' ') || "",
            // FLAGGED: Indicates this is a lite object
            isLite: true
        };
    } catch (e) {
        return null;
    }
};

const cleanTextForDisplay = (rawText: string): string => {
    if (!rawText) return "";

    // NEW: Format math before stripping other chars
    let processedText: string = formatMathForDisplay(rawText);

    return processedText
        .split('\n')
        .map(line => {
            let clean: string = line.trim();

            // NEW: Remove Table Separator lines (e.g. |---| or | :--- |) completely
            if (/^\|?[\s\-:|]+\|?$/.test(clean)) {
                return '';
            }

            // NEW: Handle Markdown Links [Text](URL) - Keep Text only for TTS/Display cleaning
            clean = clean.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');

            // NEW: Remove App-Specific Tags (Concept Cards, Toggle Tables, Resource Links)
            clean = clean.replace(/\[\[CONCEPT_CARD:\s*(.*?)\]\]/g, '$1. '); // Keep Title, add pause
            clean = clean.replace(/\[\[END_CARD\]\]/g, '');
            clean = clean.replace(/\[\[TOGGLE_TABLE.*?\]\]/g, '');
            clean = clean.replace(/RESOURCE_LINK:\s*https?:\/\/[^\s]+/, '');

            clean = clean.replace(/^#{1,6}\s+/, '');
            clean = clean.replace(/^[\*\-\+]\s+/, '');

            clean = clean.replace(/^>\s+/, '');

            // NEW: Replace pipes with space to match TTS reading behavior (prevents word merge)
            clean = clean.replace(/\|/g, ' ');

            // Remove Markdown chars (updated to preserve some math symbols if they slipped through)
            clean = clean.replace(/(\*\*|__|\*|_|`|~|\[|\]|#|\$)/g, ''); // Removed backslash from here as formatMath handles it
            clean = clean.replace(/[\u2022\u25CF\u25CB\u25A0\u25A1\u25B6\u25C0\u26AB\u26AA\uD83D\uDD34\uD83D\uDD35\u2705\u274C\u2728\u2B50]/g, '');

            // Collapse multiple spaces
            return clean.replace(/\s+/g, ' ').trim();
        })
        .filter(line => line.length > 0) // Filter empty lines to ensure dense text for TTS
        .join('\n');
};

// NEW: Integer Slider for Data Limits
const IntSlider = ({ value, min, max, onValueChange, label, theme, step = 50, usageText, formatValue }: {
    value: number;
    min: number;
    max: number;
    onValueChange: (val: number) => void;
    label: string;
    theme: any;
    step?: number;
    usageText?: string;
    formatValue?: (val: number) => string;
}) => {
    const percentage: number = Math.min(100, Math.max(0, ((value - min) / (max - min)) * 100));
    const activeColor: string = theme.id === 'day' ? '#2563eb' : theme.primary;

    const handleDecrease = (): void => {
        const newValue: number = Math.max(min, value - step);
        onValueChange(newValue);
    };

    const handleIncrease = (): void => {
        const newValue: number = Math.min(max, value + step);
        onValueChange(newValue);
    };

    return (
        <View style={{ marginBottom: 25 }}>
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-end', marginBottom: 12 }}>
                <View style={{ flex: 1, marginRight: 10 }}>
                    <Text style={[styles.appearanceLabel, { color: theme ? theme.secondary : '#64748b', marginBottom: 4, paddingBottom: 0 }]}>{label}</Text>
                    {usageText && (
                        <Text style={{ fontSize: 11, color: theme.secondary, fontWeight: '500' }}>{usageText}</Text>
                    )}
                </View>
                <Text style={{ color: theme ? theme.text : '#64748b', fontWeight: '600' }}>
                    {formatValue ? formatValue(value) : `${value} Limit`}
                </Text>
            </View>

            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>
                <TouchableOpacity
                    onPress={handleDecrease}
                    style={{
                        width: 36, height: 36,
                        borderRadius: 18,
                        backgroundColor: theme ? theme.buttonBg : '#f1f5f9',
                        alignItems: 'center', justifyContent: 'center',
                        borderWidth: 1, borderColor: theme ? theme.border : '#e2e8f0'
                    }}
                >
                    <Minus size={20} color={theme ? theme.text : '#0f172a'} />
                </TouchableOpacity>

                <View
                    style={{ flex: 1, height: 30, justifyContent: 'center' }}
                    onTouchEnd={(e: GestureResponderEvent) => {
                        const { locationX } = e.nativeEvent;
                        const width: number = 200; // Approximate width of track
                        const ratio: number = Math.max(0, Math.min(1, locationX / width));
                        const rawValue: number = min + (ratio * (max - min));
                        // Snap to step
                        const steppedValue: number = Math.round(rawValue / step) * step;
                        onValueChange(Math.min(max, Math.max(min, steppedValue)));
                    }}
                >
                    <View style={{ height: 8, backgroundColor: theme ? theme.border : '#e2e8f0', borderRadius: 4, width: '100%', overflow: 'hidden' }}>
                        <View style={{ width: `${percentage}%`, height: '100%', backgroundColor: activeColor }} />
                    </View>
                    <View style={{
                        position: 'absolute',
                        left: `${percentage}%`,
                        marginLeft: -16,
                        width: 32,
                        height: 32,
                        borderRadius: 16,
                        backgroundColor: activeColor,
                        borderWidth: 2,
                        borderColor: theme ? theme.bg : 'white',
                        shadowColor: "#000",
                        shadowOffset: { width: 0, height: 1 },
                        shadowOpacity: 0.2,
                        shadowRadius: 2,
                        elevation: 3,
                        justifyContent: 'center',
                        alignItems: 'center'
                    }}>
                    </View>
                </View>

                <TouchableOpacity
                    onPress={handleIncrease}
                    style={{
                        width: 36, height: 36,
                        borderRadius: 18,
                        backgroundColor: theme ? theme.buttonBg : '#f1f5f9',
                        alignItems: 'center', justifyContent: 'center',
                        borderWidth: 1, borderColor: theme ? theme.border : '#e2e8f0'
                    }}
                >
                    <Plus size={20} color={theme ? theme.text : '#0f172a'} />
                </TouchableOpacity>
            </View>
        </View>
    );
};




const getSentenceBounds = (fullText: string, charIndex: number): { start: number; end: number } | null => {
    if (charIndex === null || charIndex === undefined || charIndex < 0) return null;
    let start: number = fullText.lastIndexOf('.', charIndex - 1);
    const start2: number = fullText.lastIndexOf('!', charIndex - 1);
    const start3: number = fullText.lastIndexOf('?', charIndex - 1);
    const start4: number = fullText.lastIndexOf('\n', charIndex - 1);
    start = Math.max(start, start2, start3, start4);
    start = start === -1 ? 0 : start + 1;
    let end: number = fullText.indexOf('.', charIndex);
    const end2: number = fullText.indexOf('!', charIndex);
    const end3: number = fullText.indexOf('?', charIndex);
    const end4: number = fullText.indexOf('\n', charIndex);
    const candidates: number[] = [end, end2, end3, end4].filter(i => i !== -1);
    end = candidates.length > 0 ? Math.min(...candidates) : fullText.length;
    end = Math.min(fullText.length, end + 1);
    return { start, end };
};

const extractJSON = (text: string): string => {
    if (!text) return "";
    try {
        let clean: string = text.replace(/```json/gi, '').replace(/```/g, '').trim();
        // Locate first and last valid brackets/braces to ignore prologue/epilogue text
        const firstOpenBracket = clean.indexOf('[');
        const firstOpenBrace = clean.indexOf('{');
        const lastCloseBrace = clean.lastIndexOf('}');
        const lastCloseBracket = clean.lastIndexOf(']');

        let start = -1;
        let end = -1;

        // Determine if Object or Array starts first
        if (firstOpenBracket !== -1 && (firstOpenBrace === -1 || firstOpenBracket < firstOpenBrace)) {
            start = firstOpenBracket;
            end = lastCloseBracket;
        } else if (firstOpenBrace !== -1) {
            start = firstOpenBrace;
            end = lastCloseBrace;
        }

        if (start !== -1 && end !== -1 && end > start) {
            return clean.substring(start, end + 1);
        }

        return clean;
    } catch (e) {
        return text;
    }
};

const repairMalformedJson = (jsonString: string) => {
    let repaired = jsonString.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');

    // Replace Smart Quotes
    repaired = repaired.replace(/[\u2018\u2019]/g, "'").replace(/[\u201C\u201D]/g, '"');

    // LaTeX Fixes: Double escape backslashes
    repaired = repaired.replace(
        /\\(frac|sqrt|text|cdot|times|pm|theta|pi|infty|int|sum|lim|alpha|beta|gamma|delta|sin|cos|tan|log|ln|neq|leq|geq|approx|div|circ|angle|triangle|deg|left|right|over|mu|sigma|lambda|omega|phi|psi|epsilon|rho|partial|nabla|vec|hat|bar|to|implies|subset|cup|cap|bot|top|vdash|models|mathbb|mathcal|mathbf)/g,
        '\\\\$1'
    );

    repaired = repaired.replace(/\n/g, " ");

    // Fix invalid escapes
    repaired = repaired.replace(/\\([^"\\\/bfnrtu])/g, '$1');

    // Remove trailing backslash
    if (repaired.endsWith('\\')) {
        repaired = repaired.slice(0, -1);
    }

    // Fix single quoted keys/values
    repaired = repaired.replace(/'([^']+?)'\s*:/g, '"$1":');
    repaired = repaired.replace(/:\s*'([^']+?)'\s*([,}])/g, ':"$1"$2');

    // Fix unquoted keys
    repaired = repaired.replace(/([{,]\s*)([^"'{}\[\],:]+?)\s*:/g, '$1"$2":');

    // NEW: Fix unquoted string values (that are not numbers/true/false/null)
    // Looks for: : followed by non-special chars, ending with comma or brace
    // e.g. "key": value, -> "key": "value",
    // Warning: This is aggressive and might catch valid numbers if regex is loose, but 'i' error suggests text.
    // We exclude digits, true, false, null to avoid quoting them.
    repaired = repaired.replace(/:\s*(?!(?:true|false|null|\d|\[|\{))([a-zA-Z_][a-zA-Z0-9_\s\.\-]*?)\s*([,}])/g, ':"$1"$2');

    // Fix missing commas between properties
    repaired = repaired.replace(/(["\d}lue\]])\s+(?=")/g, '$1,');

    // Cleanup trailing commas
    repaired = repaired.replace(/,(\s*[}\]])/g, '$1');

    return repaired;
};

// NEW: Helper to extract the first markdown table from text for context persistence
const extractFirstTable = (text: string) => {
    if (!text) return null;
    const lines = text.split('\n');
    let tableLines = [];
    let inTable = false;
    for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('|')) {
            inTable = true;
            tableLines.push(trimmed);
        } else {
            if (inTable) break; // End of contiguous table
        }
    }
    // Needs at least 2 lines to be a valid table context
    if (tableLines.length >= 2) return tableLines.join('\n');
    return null;
};

// NEW: Helper to normalize keys if LLM translates them (e.g. Hindi keys)
const normalizeQuizKeys = (questions: any[]) => {
    if (!Array.isArray(questions)) return questions;
    return questions.map(q => {
        // If standard keys exist, assume it's fine
        if (q.question && q.options && q.correctOptionIndex !== undefined) return q;

        const newQ = { ...q };
        const keys = Object.keys(q);

        // 1. Find Options (Array)
        if (!newQ.options) {
            const optionsKey = keys.find(k => Array.isArray(q[k]));
            if (optionsKey) {
                newQ.options = q[optionsKey];
            }
        }

        // 2. Find Correct Index (Number)
        if (newQ.correctOptionIndex === undefined) {
            // Look for number value
            const indexKey = keys.find(k => typeof q[k] === 'number');
            if (indexKey) {
                newQ.correctOptionIndex = q[indexKey];
            } else {
                // Sometimes LLM gives string "0"
                const stringIndexKey = keys.find(k => !isNaN(parseInt(q[k])) && q[k] < 4);
                if (stringIndexKey) newQ.correctOptionIndex = parseInt(q[stringIndexKey]);
            }
        }

        // 3. Find Strings (Question, Explanation, VisualPrompt)
        const stringKeys = keys.filter(k => typeof q[k] === 'string' && k !== 'visualUri');

        // Visual Prompt often has 'prompt', 'visual', 'image' in key
        if (!newQ.visualPrompt) {
            const visKey = stringKeys.find(k => /prompt|visual|image|chitra|tasveer/i.test(k));
            if (visKey) {
                newQ.visualPrompt = q[visKey];
            }
        }

        // Explanation usually matches specific keywords in many languages or is the longest string
        if (!newQ.explanation) {
            const expKey = stringKeys.find(k =>
                /explanation|reason|solution|answer|detail|vyakhya|hal|vivaran|aciklama|explication|beschreibung/i.test(k) && q[k] !== newQ.visualPrompt
            );
            if (expKey) {
                newQ.explanation = q[expKey];
            }
        }

        // Question is whatever is left
        if (!newQ.question) {
            const candidates = stringKeys.filter(k =>
                q[k] !== newQ.options &&
                q[k] !== newQ.visualPrompt &&
                q[k] !== newQ.explanation
            );
            const qKey = candidates.find(k => /question|prashn|pregunta/i.test(k)) || candidates[0];
            if (qKey) newQ.question = q[qKey];
        }

        return newQ;
    });
};

// NEW: Helper to shuffle options to prevent "Option A" bias
const randomizeQuizData = (questions: any[]) => {
    if (!Array.isArray(questions)) return [];
    return questions.map(q => {
        if (!q.options || !Array.isArray(q.options) || q.options.length < 2) return q;

        // Safety check for index
        let correctIdx = q.correctOptionIndex;
        if (typeof correctIdx !== 'number' || correctIdx < 0 || correctIdx >= q.options.length) {
            correctIdx = 0; // Default fallback if malformed
        }

        const optsWithStatus = q.options.map((opt: string, idx: number) => ({
            text: opt,
            isCorrect: idx === correctIdx
        }));

        // Fisher-Yates Shuffle
        for (let i = optsWithStatus.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [optsWithStatus[i], optsWithStatus[j]] = [optsWithStatus[j], optsWithStatus[i]];
        }

        return {
            ...q,
            options: optsWithStatus.map((o: { text: string; isCorrect: boolean }) => o.text),
            correctOptionIndex: optsWithStatus.findIndex((o: { text: string; isCorrect: boolean }) => o.isCorrect)
        };
    });
};

const DraggableFAB = ({ onPress, theme, primaryColor, initialPosition, onPositionChange, label }: {
    onPress: () => void;
    theme: any;
    primaryColor: string;
    initialPosition?: { x: number; y: number };
    onPositionChange?: (pos: { x: number; y: number }) => void;
    label?: string;
}) => {
    const pan = useRef(new Animated.ValueXY(initialPosition || { x: 0, y: 0 })).current;
    const val = useRef(initialPosition || { x: 0, y: 0 });

    useEffect(() => {
        const id = pan.addListener((value) => (val.current = value));
        return () => pan.removeListener(id);
    }, []);

    const panResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => false,
            onMoveShouldSetPanResponder: (evt, gestureState) => {
                return Math.abs(gestureState.dx) > 10 || Math.abs(gestureState.dy) > 10;
            },
            onPanResponderGrant: () => {
                pan.setOffset({
                    x: val.current.x,
                    y: val.current.y
                });
                pan.setValue({ x: 0, y: 0 });
            },
            onPanResponderMove: Animated.event(
                [null, { dx: pan.x, dy: pan.y }],
                { useNativeDriver: false }
            ),
            onPanResponderRelease: (e, gestureState) => {
                pan.flattenOffset();
                if (onPositionChange) {
                    onPositionChange(val.current);
                }
            }
        })
    ).current;

    return (
        <Animated.View
            style={{
                transform: [{ translateX: pan.x }, { translateY: pan.y }],
                position: 'absolute',
                bottom: 100,
                right: 30,
                zIndex: 9999,
            }}
            {...panResponder.panHandlers}
        >
            <TouchableOpacity
                onPress={onPress}
                activeOpacity={0.8}
                style={{
                    backgroundColor: primaryColor,
                    height: 56,
                    borderRadius: 28,
                    flexDirection: 'row', // Added for label
                    alignItems: 'center',
                    justifyContent: 'center',
                    paddingHorizontal: label ? 20 : 0, // Padding for label
                    minWidth: 56,
                    shadowColor: "#000",
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 5,
                    elevation: 6
                }}
            >
                <Sparkles size={24} color="white" />
                {label && (
                    <Text style={{ color: 'white', fontWeight: 'bold', marginLeft: 8, fontSize: 16 }}>
                        {label}
                    </Text>
                )}
            </TouchableOpacity>
        </Animated.View>
    );
};

const SeekSlider = ({ value, min, max, onSeekEnd, theme, activeColor = '#3b82f6' }: {
    value: number;
    min: number;
    max: number;
    onSeekEnd: (val: number) => void;
    theme: any;
    activeColor?: string;
}) => {
    const [dragValue, setDragValue] = useState(value);
    const [isPressed, setIsPressed] = useState(false);
    const widthRef = useRef(0);
    const isDragging = useRef(false);

    useEffect(() => {
        if (!isDragging.current) {
            setDragValue(value);
        }
    }, [value]);

    const panResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponder: () => true,
            onPanResponderGrant: (evt, gestureState) => {
                isDragging.current = true;
                setIsPressed(true);
            },
            onPanResponderMove: (evt, gestureState) => {
                if (widthRef.current > 0) {
                    const { locationX } = evt.nativeEvent;
                    const ratio = Math.max(0, Math.min(1, locationX / widthRef.current));
                    const newValue = min + (ratio * (max - min));
                    setDragValue(newValue);
                }
            },
            onPanResponderRelease: (evt, gestureState) => {
                if (widthRef.current > 0) {
                    const { locationX } = evt.nativeEvent;
                    const ratio = Math.max(0, Math.min(1, locationX / widthRef.current));
                    const finalValue = min + (ratio * (max - min));
                    setDragValue(finalValue);
                    onSeekEnd(finalValue);
                }
                isDragging.current = false;
                setIsPressed(false);
            },
            onPanResponderTerminate: () => {
                isDragging.current = false;
                setIsPressed(false);
            }
        })
    ).current;

    const percentage = Math.min(100, Math.max(0, ((dragValue - min) / (max - min || 1)) * 100));

    // Dynamic visual styles for interactivity
    const thumbSize = isPressed ? 28 : 22;

    return (
        <View
            style={{ height: 40, justifyContent: 'center' }}
            onLayout={(e: LayoutChangeEvent) => widthRef.current = e.nativeEvent.layout.width}
            {...panResponder.panHandlers}
        >
            <View style={{ height: 6, backgroundColor: theme.border, borderRadius: 3, width: '100%', overflow: 'hidden' }}>
                <View style={{ width: `${percentage}%`, height: '100%', backgroundColor: activeColor }} />
            </View>

            <View style={{
                position: 'absolute',
                left: `${percentage}%`,
                marginLeft: -thumbSize / 2,
                width: thumbSize,
                height: thumbSize,
                borderRadius: thumbSize / 2,
                backgroundColor: 'white',
                borderWidth: isPressed ? 6 : 4,
                borderColor: activeColor,
                shadowColor: "#000",
                shadowOffset: { width: 0, height: 2 },
                shadowOpacity: 0.3,
                shadowRadius: 3,
                elevation: 5,
                transform: [{ scale: isPressed ? 1.1 : 1 }]
            }} />
        </View>
    );
};

interface TextSegment {
    text: string;
    isBold: boolean;
    isItalic: boolean;
    isMath: boolean;
    isLink: boolean;
    linkUrl?: string | null;
    isGreen: boolean;
}

interface LineWord {
    word: string;
    start: number;
    end: number;
    isBold: boolean;
    isItalic: boolean;
    isMath: boolean;
    isLink: boolean;
    linkUrl?: string | null;
    isGreen: boolean;
}



const InteractiveText = React.memo(({ rawText, onWordPress, onLinkPress, style, activeSentence, paragraphOffset = 0, theme, isHighlightMode, highlights = [], onHighlightPress, tapToDefineEnabled = true }: InteractiveTextProps) => {
    // Flatten style array to object to access properties safely
    const flatStyle: any = useMemo(() => StyleSheet.flatten(style) || {}, [style]);

    // UPDATED: Destructure processed data and total length for paragraph-level operations
    const { lines: processedLines, totalLength } = useMemo(() => {
        if (typeof rawText !== 'string') return { lines: [], totalLength: 0 };
        // Split by newline but keep the delimiter to detect empty lines
        const lines = rawText.split(/(\n)/g);
        let charIndex = 0;

        const mappedLines = lines.map((line, lineIdx) => {
            const rawLine = line; // Don't trim immediately, checking for \n
            if (rawLine === '\n') {
                // It's a newline separator
                return { isNewline: true, key: lineIdx };
            }

            const trimmed = rawLine.trim();
            let type = 'normal';
            let cleanLine = line;

            if (trimmed.length === 0) {
                // Empty line (double newline case)
                return { isNewline: false, isEmpty: true, key: lineIdx };
            }

            if (trimmed.startsWith('#')) {
                type = 'header';
                cleanLine = line.replace(/#{1,6}\s*/, '');
            } else if (trimmed.startsWith('**') && trimmed.endsWith('**') && trimmed.length < 50) {
                type = 'menu';
                cleanLine = line.replace(/^\*\*/, '').replace(/\*\*$/, '');
            } else if ((trimmed.startsWith('* ') || trimmed.startsWith('- ')) && trimmed.length < 60) {
                type = 'submenu';
                cleanLine = line.replace(/^[\*\-]\s*/, '');
            } else if (trimmed.startsWith('>')) { // Added quote detection
                type = 'quote';
                cleanLine = line.replace(/^>\s*/, '');
            } else {
                // NEW: Detect Formula Lines
                const mathSymbols = /[=â‰ˆâˆ><â‰¥â‰¤âˆ«âˆ‘âˆšÂ±Ã—Ã·]/;
                const isShort = trimmed.length < 80;
                if (isShort && mathSymbols.test(trimmed) && !trimmed.endsWith('.')) {
                    type = 'formula';
                }
            }

            // 1. Initial segment (whole line)
            let mixedSegments: TextSegment[] = [{ text: cleanLine, isBold: false, isItalic: false, isMath: false, isLink: false, linkUrl: null, isGreen: false }];

            // ... (existing segmentation logic unchanged) ...
            // 2. Process Markdown Links [Text](URL) - Process FIRST to protect URLs
            mixedSegments = mixedSegments.flatMap(seg => {
                if (seg.isBold || seg.isItalic || seg.isMath) return [seg];
                const parts = seg.text.split(/(\[[^\]]+\]\([^)]+\))/g);
                return parts.map(part => {
                    const linkMatch = part.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
                    if (linkMatch) {
                        return {
                            text: linkMatch[1].replace(/\s+/g, ' ').trim(),
                            isBold: false, isItalic: false, isMath: false,
                            isLink: true, linkUrl: linkMatch[2],
                            isGreen: false
                        };
                    }
                    return {
                        text: part,
                        isBold: false, isItalic: false, isMath: false,
                        isLink: false, linkUrl: null,
                        isGreen: false
                    };
                });
            });

            // 3. Process Bold
            mixedSegments = mixedSegments.flatMap(seg => {
                if (seg.isBold || seg.isItalic || seg.isMath || seg.isLink) return [seg];
                return seg.text.split(/(\*\*.*?\*\*)/g).map(part => {
                    if (part.startsWith('**') && part.endsWith('**') && part.length >= 4) {
                        return { text: part.slice(2, -2), isBold: true, isItalic: false, isMath: false, isLink: false, linkUrl: null, isGreen: false };
                    }
                    return { text: part, isBold: false, isItalic: false, isMath: false, isLink: false, linkUrl: null, isGreen: false };
                });
            });

            // 4. Process Math
            mixedSegments = mixedSegments.flatMap(seg => {
                if (seg.isBold || seg.isItalic || seg.isMath || seg.isLink) return [seg];
                return seg.text.split(/(\$.*?\$)/g).map(part => {
                    if (part.startsWith('$') && part.endsWith('$') && part.length >= 3) {
                        return { text: part.slice(1, -1), isBold: false, isItalic: false, isMath: true, isLink: false, linkUrl: null, isGreen: false };
                    }
                    return { text: part, isBold: false, isItalic: false, isMath: false, isLink: false, linkUrl: null, isGreen: false };
                });
            });

            // 5. Process Italic
            mixedSegments = mixedSegments.flatMap(seg => {
                if (seg.isBold || seg.isMath || seg.isLink) return [seg];
                return seg.text.split(/(\*[^*]+?\*)/g).map(part => {
                    if (part.startsWith('*') && part.endsWith('*') && part.length >= 3) {
                        return { text: part.slice(1, -1), isBold: false, isItalic: true, isMath: false, isLink: false, linkUrl: null, isGreen: false };
                    }
                    return { text: part, isBold: false, isItalic: false, isMath: false, isLink: false, linkUrl: null, isGreen: false };
                });
            });

            // 6. Process Green Blank
            mixedSegments = mixedSegments.flatMap(seg => {
                if (seg.isBold || seg.isMath || seg.isLink || seg.isItalic) return [seg];
                return seg.text.split(/(\[\[Blank\]\])/g).map(part => {
                    if (part === '[[Blank]]') {
                        return { text: 'Blank', isBold: true, isItalic: false, isMath: false, isLink: false, linkUrl: null, isGreen: true };
                    }
                    return { text: part, isBold: false, isItalic: false, isMath: false, isLink: false, linkUrl: null, isGreen: false };
                });
            });

            const lineWords: LineWord[] = [];

            mixedSegments.forEach(seg => {
                let cleanSeg = seg.text;
                if (!seg.isMath && !seg.isLink && !seg.isGreen) {
                    cleanSeg = cleanSeg.replace(/\|/g, ' ');
                    cleanSeg = cleanSeg.replace(/(\*\*|__|\*|_|`|~|\\|\[|\]|#)/g, '');
                    cleanSeg = cleanSeg.replace(/[\u2022\u25CF\u25CB\u25A0\u25A1\u25B6\u25C0\u26AB\u26AA\uD83D\uDD34\uD83D\uDD35\u2705\u274C\u2728\u2B50]/g, '');
                    cleanSeg = cleanSeg.replace(/\s+/g, ' ');
                }

                const words = cleanSeg.split(/(\s+)/);
                words.forEach(word => {
                    if (!word) return;
                    lineWords.push({
                        word,
                        start: charIndex,
                        end: charIndex + word.length,
                        isBold: seg.isBold,
                        isItalic: seg.isItalic,
                        isMath: seg.isMath,
                        isLink: seg.isLink,
                        linkUrl: seg.linkUrl,
                        isGreen: seg.isGreen
                    });
                    charIndex += word.length;
                });
            });

            return { lineWords, type, key: lineIdx };
        });

        return { lines: mappedLines, totalLength: charIndex };
    }, [rawText]);

    // NEW: Track press duration and movement to differentiate Tap (Define) vs Selection/Scroll
    const pressTrackerRef = useRef({ time: 0, x: 0, y: 0 });

    return (
        // UPDATED: Enable text selection even if Tap to Define is ON. (Only disable in HighlightMode to prevent conflict)
        <Text style={flatStyle} selectable={!isHighlightMode}>
            {processedLines.map((lineData) => {
                if (lineData.isNewline) {
                    return <Text key={lineData.key}>{"\n"}</Text>;
                }
                if (lineData.isEmpty) {
                    return null; // Don't render empty strings, newline handles spacing
                }

                const { lineWords, type, key } = lineData;

                let dynamicColor = flatStyle.color || theme.text;
                let dynamicWeight = flatStyle.fontWeight || 'normal';
                let dynamicSize = flatStyle.fontSize;
                let dynamicMargin = 0;
                let dynamicStyle = flatStyle.fontStyle || 'normal';
                let dynamicTextAlign = 'left';

                if (type === 'header') {
                    dynamicColor = theme.id === 'night' ? '#60a5fa' : (theme.id === 'sepia' ? '#8c7b66' : '#2563eb');
                    dynamicWeight = flatStyle.fontWeight || 'bold';
                    dynamicSize = flatStyle.fontSize * 1.3;
                    dynamicMargin = 10;
                } else if (type === 'menu') {
                    dynamicColor = theme.id === 'night' ? '#c084fc' : (theme.id === 'sepia' ? '#8c7b66' : '#9333ea');
                    dynamicWeight = flatStyle.fontWeight || '700';
                } else if (type === 'submenu') {
                    dynamicColor = theme.id === 'night' ? '#34d399' : (theme.id === 'sepia' ? '#5b4636' : '#059669');
                    dynamicWeight = flatStyle.fontWeight || '600';
                } else if (type === 'quote') {
                    dynamicColor = theme.secondary;
                    dynamicStyle = 'italic';
                    dynamicMargin = 4;
                } else if (type === 'formula') {
                    dynamicTextAlign = 'center';
                    dynamicStyle = 'italic';
                    dynamicColor = theme.text;
                    dynamicSize = flatStyle.fontSize * 1.15;
                    dynamicMargin = 8;
                    dynamicWeight = '600';
                }

                return (
                    <Text key={key} style={{ marginTop: dynamicMargin, textAlign: dynamicTextAlign as any }}>
                        {lineWords && (lineWords as any[]).map(({ word, start, end, isBold, isItalic, isMath, isLink, linkUrl, isGreen }, index) => {
                            if (!word) return null;

                            const globalStart = paragraphOffset + start;
                            const globalEnd = globalStart + word.length;

                            let isHighlighted = false;

                            if (activeSentence) {
                                if (globalStart >= activeSentence.start && globalStart < activeSentence.end) {
                                    isHighlighted = true;
                                }
                            }

                            // CHECK MANUAL HIGHLIGHT
                            const manualHighlight = highlights.find(h =>
                                (globalStart < h.end && globalEnd > h.start) // Overlap check
                            );

                            const isUrl = word.match(/^https?:\/\//i);
                            const isSpace = !word.trim();

                            let wordColor = dynamicColor;
                            let wordWeight = dynamicWeight;
                            let wordStyleProp = dynamicStyle;
                            let wordDecor = flatStyle.textDecorationLine || 'none';

                            if (isUrl) {
                                wordColor = '#2563eb';
                                wordDecor = 'underline';
                            } else if (isLink) {
                                wordColor = '#2563eb';
                                wordDecor = 'underline';
                                wordWeight = 'bold';
                            } else if (isGreen) {
                                wordColor = '#22c55e';
                                wordWeight = 'bold';
                            } else if (isBold && type === 'normal') {
                                wordColor = theme.id === 'day' ? '#2563eb' : theme.primary;
                                wordWeight = 'bold';
                            } else if (isMath && type === 'normal') {
                                wordColor = theme.id === 'day' ? '#ea580c' : '#fb923c';
                                wordWeight = '500';
                            } else if (isItalic && type === 'normal') {
                                wordColor = theme.id === 'day' ? '#9333ea' : '#c084fc';
                                wordStyleProp = 'italic';
                            } else if (type === 'formula') {
                                wordColor = dynamicColor;
                                wordWeight = dynamicWeight;
                                var fontFamily = 'serif';
                                if (Platform.OS === 'ios') fontFamily = 'Georgia';
                            }

                            let backgroundColor = 'transparent';
                            if (manualHighlight) {
                                const hColor = manualHighlight.color || 'yellow';
                                const colorDef = (HIGHLIGHT_COLORS as any)[hColor] || HIGHLIGHT_COLORS.yellow;
                                backgroundColor = theme.id === 'day' ? colorDef.day : colorDef.night;
                            } else if (isHighlighted) {
                                backgroundColor = theme.activeWord;
                            }

                            const wordStyle = {
                                color: manualHighlight && theme.id !== 'day' ? '#fefce8' : wordColor,
                                fontWeight: wordWeight,
                                backgroundColor: backgroundColor,
                                fontSize: dynamicSize,
                                fontFamily: type === 'formula' ? (Platform.OS === 'ios' ? 'Georgia' : 'serif') : flatStyle.fontFamily,
                                fontStyle: wordStyleProp,
                                lineHeight: flatStyle.lineHeight,
                                textDecorationLine: wordDecor,
                                letterSpacing: flatStyle.letterSpacing,
                                includeFontPadding: false,
                                textAlignVertical: 'center' as any
                            };

                            if (isSpace) {
                                return (
                                    <Text key={`${key}-${index}`} style={wordStyle}>
                                        {word}
                                    </Text>
                                );
                            }

                            const isInteractive = isHighlightMode || (isLink && linkUrl) || isUrl || tapToDefineEnabled;

                            return (
                                <Text
                                    key={`${key}-${index}`}
                                    style={wordStyle}
                                    onPressIn={(e) => {
                                        const { pageX, pageY } = e.nativeEvent;
                                        pressTrackerRef.current = { time: Date.now(), x: pageX, y: pageY };
                                    }}
                                    onPress={isInteractive ? (e) => {
                                        const { pageX, pageY } = e.nativeEvent;
                                        const { time, x, y } = pressTrackerRef.current;

                                        const duration = Date.now() - time;
                                        const dist = Math.sqrt(Math.pow(pageX - x, 2) + Math.pow(pageY - y, 2));

                                        // Ignore if long press (>350ms) OR moved significantly (>10px) (Drag/Selection)
                                        if (duration > 350 || dist > 10) {
                                            return;
                                        }

                                        if (isHighlightMode) {
                                            onHighlightPress && onHighlightPress({
                                                start: paragraphOffset,
                                                end: paragraphOffset + totalLength,
                                                text: "Paragraph Highlight"
                                            });
                                        } else if (isLink && linkUrl) {
                                            const handled = onLinkPress && onLinkPress(linkUrl);
                                            if (handled) return;
                                            Linking.openURL(linkUrl).catch(err => Alert.alert("Error", "Cannot open this link."));
                                        } else if (isUrl) {
                                            const cleanUrl = word.replace(/[.,;)]$/, '');
                                            Linking.openURL(cleanUrl).catch(err => Alert.alert("Error", "Cannot open this link."));
                                        } else if (tapToDefineEnabled) {
                                            onWordPress?.(word.replace(/[.,/#!$%^&*;:{}=\-_`~()"'?]/g, ""));
                                        }
                                    } : undefined}
                                >
                                    {word}
                                </Text>
                            );
                        })}
                    </Text>
                );
            })}
        </Text>
    );
}, (prev, next) => {
    // Flatten styles to compare properties correctly (handles array styles)
    const prevStyle = StyleSheet.flatten(prev.style) || {};
    const nextStyle = StyleSheet.flatten(next.style) || {};

    // 1. Check standard props (Primitive & References)
    if (prev.rawText !== next.rawText ||
        prev.paragraphOffset !== next.paragraphOffset ||
        prev.theme.id !== next.theme.id ||
        prev.theme.text !== next.theme.text || // NEW: Explicitly check for theme text color change
        prev.theme.bg !== next.theme.bg ||     // NEW: Check for background changes
        prev.isHighlightMode !== next.isHighlightMode ||
        prev.tapToDefineEnabled !== next.tapToDefineEnabled ||
        prevStyle.fontSize !== nextStyle.fontSize ||
        prevStyle.fontFamily !== nextStyle.fontFamily ||
        prevStyle.fontWeight !== nextStyle.fontWeight ||
        prevStyle.color !== nextStyle.color || // NEW: Explicitly check style prop color
        prevStyle.fontStyle !== nextStyle.fontStyle ||
        prevStyle.textDecorationLine !== nextStyle.textDecorationLine ||
        prevStyle.letterSpacing !== nextStyle.letterSpacing
    ) {
        return false; // Re-render needed
    }

    // 2. Optimization: Active Sentence Check
    // Only re-render if the active sentence INTERSECTS this paragraph.
    const pStart = next.paragraphOffset || 0;
    // Use raw length as a safe upper bound
    const pEnd = pStart + next.rawText.length + 50;

    // Helper to check intersection for Sentence
    const sentenceIntersects = (range: any) => {
        if (!range) return false;
        return (range.start < pEnd && range.end > pStart);
    };

    const prevActive = prev.activeSentence;
    const nextActive = next.activeSentence;

    const wasHighlighted = sentenceIntersects(prevActive);
    const isHighlighted = sentenceIntersects(nextActive);

    // If highlight status changed (e.g., entered or left this paragraph), re-render
    if (wasHighlighted !== isHighlighted) return false;
    // If still highlighted, check if bounds changed
    if (wasHighlighted && isHighlighted && prevActive && nextActive) {
        if ((prevActive as any).start !== (nextActive as any).start || (prevActive as any).end !== (nextActive as any).end) return false;
    }

    // 3. Smart Manual Highlight Check
    // If global highlights array reference changed, check if it actually affects THIS paragraph
    if (prev.highlights !== next.highlights) {
        const getRelevant = (list: any[] | undefined) => (list || []).filter(h => h.start < pEnd && h.end > pStart);

        const prevRelevant = getRelevant(prev.highlights || []);
        const nextRelevant = getRelevant(next.highlights || []);

        // Fast length check first
        if (prevRelevant.length !== nextRelevant.length) return false;

        // Deep check items without JSON.stringify for speed
        for (let i = 0; i < prevRelevant.length; i++) {
            const p = prevRelevant[i];
            const n = nextRelevant[i];
            if (p.id !== n.id || p.start !== n.start || p.end !== n.end || p.color !== n.color) {
                return false;
            }
        }
    }

    return true; // Props are effectively equal
});

const CleanSlider = ({ value, min, max, onValueChange, label, formatValue, activeColor = '#3b82f6', theme }: any) => {
    const percentage = Math.min(100, Math.max(0, ((value - min) / (max - min)) * 100));
    const trackColor = label.includes('SPEED') ? '#22c55e' : activeColor;

    const step = (max - min) / 10;

    const handleDecrease = () => {
        const newValue = Math.max(min, value - step);
        const rounded = Math.round(newValue * 10) / 10;
        onValueChange(rounded);
    };

    const handleIncrease = () => {
        const newValue = Math.min(max, value + step);
        const rounded = Math.round(newValue * 10) / 10;
        onValueChange(rounded);
    };

    // Adjusted font size calc to prevent overflow (max 20px instead of 24px)
    const knobFontSize = label.includes('SIZE') ? 12 + ((value - min) / (max - min)) * 8 : 16;

    return (
        <View style={{ marginBottom: 25 }}>
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
                {/* FIXED: Explicitly override marginBottom to 0 and ensure alignment */}
                <Text style={[styles.appearanceLabel, { color: theme ? theme.secondary : '#64748b', marginBottom: 0, paddingBottom: 0 }]}>{label}</Text>
                <Text style={{ color: theme ? theme.text : '#64748b', fontWeight: '600' }}>{formatValue ? formatValue(value) : value.toFixed(1)}</Text>
            </View>

            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>
                <TouchableOpacity
                    onPress={handleDecrease}
                    style={{
                        width: 36, height: 36,
                        borderRadius: 18,
                        backgroundColor: theme ? theme.buttonBg : '#f1f5f9',
                        alignItems: 'center', justifyContent: 'center',
                        borderWidth: 1, borderColor: theme ? theme.border : '#e2e8f0'
                    }}
                >
                    <Minus size={20} color={theme ? theme.text : '#0f172a'} />
                </TouchableOpacity>

                <View
                    style={{ flex: 1, height: 30, justifyContent: 'center' }}
                    onTouchEnd={(e) => {
                        const { locationX } = e.nativeEvent;
                        const width = 200;
                        const ratio = Math.max(0, Math.min(1, locationX / width));
                        const newValue = min + (ratio * (max - min));
                        const steps = 10;
                        const steppedValue = Math.round(newValue * steps) / steps;
                        onValueChange(steppedValue);
                    }}
                >
                    <View style={{ height: 8, backgroundColor: theme ? theme.border : '#e2e8f0', borderRadius: 4, width: '100%', overflow: 'hidden' }}>
                        <View style={{ width: `${percentage}%`, height: '100%', backgroundColor: trackColor }} />
                    </View>
                    <View style={{
                        position: 'absolute',
                        left: `${percentage}%`,
                        marginLeft: -16,
                        width: 32,
                        height: 32,
                        borderRadius: 16,
                        backgroundColor: trackColor,
                        borderWidth: 2,
                        borderColor: theme ? theme.bg : 'white',
                        shadowColor: "#000",
                        shadowOffset: { width: 0, height: 1 },
                        shadowOpacity: 0.2,
                        shadowRadius: 2,
                        elevation: 3,
                        justifyContent: 'center',
                        alignItems: 'center'
                    }}>
                        {label.includes('SIZE') && (
                            <Text style={{
                                color: 'white',
                                fontWeight: 'bold',
                                fontSize: knobFontSize,
                                textAlign: 'center',
                                includeFontPadding: false // Android fix for centering
                            }}>A</Text>
                        )}
                    </View>
                </View>

                <TouchableOpacity
                    onPress={handleIncrease}
                    style={{
                        width: 36, height: 36,
                        borderRadius: 18,
                        backgroundColor: theme ? theme.buttonBg : '#f1f5f9',
                        alignItems: 'center', justifyContent: 'center',
                        borderWidth: 1, borderColor: theme ? theme.border : '#e2e8f0'
                    }}
                >
                    <Plus size={20} color={theme ? theme.text : '#0f172a'} />
                </TouchableOpacity>
            </View>
        </View>
    );
};

const SegmentedControl = ({ label, options, selected, onSelect, theme }: any) => (
    <View style={{ marginBottom: 25 }}>
        {label && <Text style={[styles.appearanceLabel, { color: theme ? theme.secondary : '#64748b' }]}>{label}</Text>}
        <View style={[styles.segmentedContainer, { backgroundColor: theme ? theme.buttonBg : '#f1f5f9' }]}>
            {options.map((opt: any) => {
                const isActive = selected === opt.value;
                return (
                    <TouchableOpacity
                        key={opt.value}
                        onPress={() => onSelect(opt.value)}
                        style={[
                            styles.segmentedOption,
                            isActive && [styles.segmentedOptionActive, { backgroundColor: theme ? theme.bg : 'white' }]
                        ]}
                    >
                        <Text style={[
                            styles.segmentedText,
                            { color: theme ? theme.secondary : '#64748b' },
                            isActive && [styles.segmentedTextActive, { color: theme ? theme.text : '#0f172a' }]
                        ]}>{opt.label}</Text>
                    </TouchableOpacity>
                );
            })}
        </View>
    </View>
);

const DropdownInput = ({ label, value, options, onSelect, theme }: any) => {
    const [visible, setVisible] = useState(false);

    return (
        <View style={{ flex: 1 }}>
            <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase', letterSpacing: 0.5 }}>{label}</Text>
            <TouchableOpacity
                onPress={() => setVisible(true)}
                style={{
                    flexDirection: 'row',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: 12,
                    backgroundColor: theme.inputBg,
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: theme.border
                }}
            >
                <Text style={{ color: theme.text, fontWeight: '600' }} numberOfLines={1}>{value}</Text>
                <ChevronDown size={16} color={theme.secondary} />
            </TouchableOpacity>

            <Modal visible={visible} transparent animationType="fade" onRequestClose={() => setVisible(false)}>
                <TouchableOpacity
                    style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', padding: 20 }}
                    activeOpacity={1}
                    onPress={() => setVisible(false)}
                >
                    <TouchableWithoutFeedback>
                        <View style={{ backgroundColor: theme.bg, borderRadius: 16, padding: 10, shadowColor: "#000", shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.25, shadowRadius: 3.84, elevation: 5 }}>
                            <Text style={{ textAlign: 'center', fontWeight: 'bold', color: theme.secondary, marginBottom: 10, marginTop: 5, textTransform: 'uppercase', fontSize: 12 }}>Select {label}</Text>
                            <ScrollView style={{ maxHeight: 300 }}>
                                {options.map((opt: any, i: number) => (
                                    <TouchableOpacity
                                        key={opt}
                                        onPress={() => { onSelect(opt); setVisible(false); }}
                                        style={{
                                            padding: 15,
                                            borderBottomWidth: i === options.length - 1 ? 0 : 1,
                                            borderBottomColor: theme.border,
                                            flexDirection: 'row',
                                            justifyContent: 'space-between',
                                            alignItems: 'center'
                                        }}
                                    >
                                        <Text style={{ color: theme.text, fontSize: 16, fontWeight: value === opt ? 'bold' : '400' }}>{opt}</Text>
                                        {value === opt && <Check size={16} color="#2563eb" />}
                                    </TouchableOpacity>
                                ))}
                            </ScrollView>
                        </View>
                    </TouchableWithoutFeedback>
                </TouchableOpacity>
            </Modal>
        </View>
    );
};

const EditableSelectionList = ({ label, items, selectedItem, onSelect, onAdd, onDelete, theme, placeholder = "Add new...", formatItem, maxItems, fillSpace }: any) => {
    const [inputValue, setInputValue] = useState("");
    const [isAdding, setIsAdding] = useState(false);
    const scrollViewRef = useRef<ScrollView>(null);
    const { width, height } = useWindowDimensions();
    const isLandscape = width > height;

    const handleAdd = () => {
        if (inputValue.trim()) {
            onAdd(inputValue.trim());
            setInputValue("");
            setIsAdding(false);
        }
    };

    const handleStartAdding = () => {
        setIsAdding(true);
        // In landscape mode, scroll more aggressively and with multiple attempts
        if (isLandscape) {
            // Immediate scroll
            setTimeout(() => {
                scrollViewRef.current?.scrollToEnd({ animated: true });
            }, 50);
            // Second scroll after keyboard likely appears
            setTimeout(() => {
                scrollViewRef.current?.scrollToEnd({ animated: true });
            }, 300);
            // Final scroll to ensure visibility
            setTimeout(() => {
                scrollViewRef.current?.scrollToEnd({ animated: false });
            }, 600);
        } else {
            // Portrait mode - single scroll is usually sufficient
            setTimeout(() => {
                scrollViewRef.current?.scrollToEnd({ animated: true });
            }, 100);
        }
    };

    // Re-scroll when keyboard appears in landscape mode
    useEffect(() => {
        if (isAdding && isLandscape) {
            const keyboardDidShowListener = Keyboard.addListener('keyboardDidShow', () => {
                setTimeout(() => {
                    scrollViewRef.current?.scrollToEnd({ animated: true });
                }, 100);
            });

            return () => {
                keyboardDidShowListener.remove();
            };
        }
    }, [isAdding, isLandscape]);

    const showAdd = onAdd && (!maxItems || (items || []).length < maxItems);
    const Container = fillSpace ? View : ScrollView;

    return (
        <View style={{ marginBottom: 25 }}>
            <Text style={[styles.appearanceLabel, { color: theme.secondary }]}>{label}</Text>

            <Container
                ref={fillSpace ? undefined : scrollViewRef}
                {...(fillSpace ? {} : { horizontal: true, showsHorizontalScrollIndicator: false })}
                style={fillSpace ? { flexDirection: 'row', gap: 10, alignItems: 'center', width: '100%' } : undefined}
                contentContainerStyle={fillSpace ? undefined : { gap: 10, alignItems: 'center', paddingRight: isLandscape ? 20 : 10 }}
                keyboardShouldPersistTaps="handled"
            >
                {(items || []).map((item: any) => {
                    const isSelected = selectedItem === item;

                    let displayText = item;
                    if (formatItem) {
                        displayText = formatItem(item);
                    } else {
                        // Truncate display text if it's too long (specifically for prompts)
                        // If longer than 20 chars, show first 2-3 words max
                        displayText = item.length > 20
                            ? item.split(' ').slice(0, 3).join(' ') + '...'
                            : item;
                    }

                    return (
                        <TouchableOpacity
                            key={item}
                            onPress={() => onSelect(item)}
                            onLongPress={() => onDelete && onDelete(item)}
                            delayLongPress={500}
                            style={{
                                paddingHorizontal: 16,
                                paddingVertical: 10,
                                borderRadius: 20,
                                backgroundColor: isSelected ? '#2563eb' : theme.buttonBg,
                                borderWidth: 1,
                                borderColor: isSelected ? '#2563eb' : theme.border,
                                flexDirection: 'row',
                                alignItems: 'center',
                                gap: 6,
                                flex: fillSpace ? 1 : undefined,
                                maxWidth: fillSpace ? undefined : 180,
                                justifyContent: fillSpace ? 'center' : 'flex-start'
                            }}
                        >
                            <Text style={{ color: isSelected ? 'white' : theme.text, fontWeight: 'bold' }} numberOfLines={1} ellipsizeMode="tail">
                                {displayText}
                            </Text>
                        </TouchableOpacity>
                    );
                })}

                {showAdd && (isAdding ? (
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5, flex: fillSpace ? 1 : undefined, minWidth: fillSpace ? undefined : (isLandscape ? 250 : 200) }}>
                        <TextInput
                            style={{
                                flex: 1,
                                paddingHorizontal: 12, paddingVertical: 8,
                                backgroundColor: theme.inputBg,
                                borderRadius: 16,
                                borderWidth: 1, borderColor: '#2563eb',
                                color: theme.text,
                                minWidth: isLandscape ? 140 : 120,
                                fontSize: 14
                            }}
                            placeholder={placeholder}
                            placeholderTextColor={theme.secondary}
                            value={inputValue}
                            onChangeText={setInputValue}
                            autoFocus
                            onSubmitEditing={handleAdd}
                            returnKeyType="done"
                            blurOnSubmit={true}
                            onFocus={() => {
                                // Extra scroll when input is focused (especially helpful in landscape)
                                if (isLandscape) {
                                    setTimeout(() => {
                                        scrollViewRef.current?.scrollToEnd({ animated: true });
                                    }, 200);
                                }
                            }}
                        />
                        <TouchableOpacity onPress={handleAdd} style={{ backgroundColor: '#2563eb', padding: 8, borderRadius: 20 }}>
                            <Check size={14} color="white" />
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => { setIsAdding(false); setInputValue(""); }} style={{ backgroundColor: theme.buttonBg, padding: 8, borderRadius: 20 }}>
                            <X size={14} color={theme.text} />
                        </TouchableOpacity>
                    </View>
                ) : (
                    <TouchableOpacity
                        onPress={handleStartAdding}
                        style={{
                            paddingHorizontal: 14, paddingVertical: 10,
                            borderRadius: 20,
                            borderWidth: 1, borderColor: theme.border,
                            borderStyle: 'dashed',
                            flexDirection: 'row', alignItems: 'center', gap: 4,
                            flex: fillSpace ? 1 : undefined,
                            justifyContent: fillSpace ? 'center' : 'flex-start'
                        }}
                    >
                        <Plus size={16} color={theme.secondary} />
                        <Text style={{ color: theme.secondary, fontSize: 12, fontWeight: 'bold' }}>Add</Text>
                    </TouchableOpacity>
                ))}
            </Container>
        </View>
    );
};

const ZoomableImageModal = ({ visible, uri, onClose }: any) => {
    const [scale, setScale] = useState(1);
    const scaleRef = useRef(1); // To access in PanResponder

    const [pan, setPan] = useState({ x: 0, y: 0 });
    const panRef = useRef({ x: 0, y: 0 });

    useEffect(() => {
        if (visible) {
            setScale(1);
            scaleRef.current = 1;
            setPan({ x: 0, y: 0 });
            panRef.current = { x: 0, y: 0 };
        }
    }, [visible]);

    const updateScale = (newScale: number) => {
        const s = Math.max(1, Math.min(newScale, 4));
        setScale(s);
        scaleRef.current = s;
        if (s === 1) {
            setPan({ x: 0, y: 0 });
            panRef.current = { x: 0, y: 0 };
        }
    };

    const panResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => scaleRef.current > 1,
            onMoveShouldSetPanResponder: () => scaleRef.current > 1,
            onPanResponderGrant: () => { },
            onPanResponderMove: (evt, gestureState) => {
                if (scaleRef.current > 1) {
                    setPan({
                        x: panRef.current.x + gestureState.dx,
                        y: panRef.current.y + gestureState.dy
                    });
                }
            },
            onPanResponderRelease: (evt, gestureState) => {
                if (scaleRef.current > 1) {
                    panRef.current = {
                        x: panRef.current.x + gestureState.dx,
                        y: panRef.current.y + gestureState.dy
                    };
                }
            }
        })
    ).current;

    return (
        <Modal visible={visible} transparent={true} animationType="fade" onRequestClose={onClose}>
            <View style={{ flex: 1, backgroundColor: 'black' }}>
                <View
                    {...panResponder.panHandlers}
                    style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}
                >
                    {uri && (
                        <Image
                            source={{ uri }}
                            style={{
                                width: '100%',
                                height: '100%',
                                transform: [
                                    { scale: scale },
                                    { translateX: pan.x / scale },
                                    { translateY: pan.y / scale }
                                ]
                            }}
                            resizeMode="contain"
                        />
                    )}
                </View>

                <TouchableOpacity
                    style={{ position: 'absolute', top: 50, right: 30, zIndex: 10, backgroundColor: 'rgba(0,0,0,0.5)', borderRadius: 20, padding: 8 }}
                    onPress={onClose}
                >
                    <X size={30} color="white" />
                </TouchableOpacity>

                <View style={{ position: 'absolute', bottom: 50, width: '100%', flexDirection: 'row', justifyContent: 'center', alignItems: 'center', gap: 20, zIndex: 10 }}>
                    <TouchableOpacity style={{ backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 30, padding: 12 }} onPress={() => updateScale(scale - 0.5)}>
                        <Minus size={24} color="white" />
                    </TouchableOpacity>

                    <View style={{ backgroundColor: 'rgba(0,0,0,0.6)', paddingHorizontal: 12, paddingVertical: 6, borderRadius: 16 }}>
                        <Text style={{ color: 'white', fontWeight: 'bold' }}>{Math.round(scale * 100)}%</Text>
                    </View>

                    <TouchableOpacity style={{ backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 30, padding: 12 }} onPress={() => updateScale(scale + 0.5)}>
                        <Plus size={24} color="white" />
                    </TouchableOpacity>
                </View>
            </View>
        </Modal>
    );
};


















// NEW: Memoized Question components to prevent re-creation on every re-render (fixes switching delay)
const QuizNavButtons = React.memo(({ currentIndex, totalQuestions, isExamMode, theme, onPrevious, onReview, onNext }: any) => (
    <View style={{ flexDirection: 'row', gap: 10 }}>
        {currentIndex > 0 && (
            <TouchableOpacity
                onPress={onPrevious}
                style={{
                    backgroundColor: theme.buttonBg,
                    paddingVertical: 14,
                    paddingHorizontal: 20,
                    borderRadius: 12,
                    alignItems: 'center',
                    justifyContent: 'center',
                    borderWidth: 1,
                    borderColor: theme.border
                }}
            >
                <ArrowLeft size={24} color={theme.text} />
            </TouchableOpacity>
        )}

        {isExamMode ? (
            <View style={{ flex: 1, flexDirection: 'row', gap: 10 }}>
                <TouchableOpacity
                    onPress={onReview}
                    style={{
                        flex: 1,
                        backgroundColor: '#eab308',
                        paddingVertical: 14,
                        borderRadius: 12,
                        alignItems: 'center',
                        justifyContent: 'center',
                        flexDirection: 'row',
                        gap: 6,
                        shadowColor: "#eab308",
                        shadowOffset: { width: 0, height: 2 },
                        shadowOpacity: 0.2,
                        shadowRadius: 4,
                        elevation: 3
                    }}
                >
                    <Flag size={18} color="white" />
                    <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 14 }}>Review</Text>
                </TouchableOpacity>

                <TouchableOpacity
                    onPress={onNext}
                    style={{
                        flex: 1,
                        backgroundColor: '#2563eb',
                        paddingVertical: 14,
                        borderRadius: 12,
                        alignItems: 'center',
                        justifyContent: 'center',
                        shadowColor: "#2563eb",
                        shadowOffset: { width: 0, height: 2 },
                        shadowOpacity: 0.2,
                        shadowRadius: 4,
                        elevation: 3
                    }}
                >
                    <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 14 }}>
                        {currentIndex === totalQuestions - 1 ? "Finish" : "Next"}
                    </Text>
                </TouchableOpacity>
            </View>
        ) : (
            <TouchableOpacity
                onPress={onNext}
                style={{
                    flex: 1,
                    backgroundColor: '#2563eb',
                    paddingVertical: 14,
                    borderRadius: 12,
                    alignItems: 'center',
                    flexDirection: 'row',
                    justifyContent: 'center',
                    gap: 8,
                    shadowColor: "#2563eb",
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8,
                    elevation: 5
                }}
            >
                <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 16 }}>
                    {currentIndex === totalQuestions - 1 ? "Finish Quiz" : "Next Question"}
                </Text>
                {currentIndex !== totalQuestions - 1 && <ArrowRight size={20} color="white" />}
            </TouchableOpacity>
        )}
    </View>
));

const QuizOptionsList = React.memo(({ options, selected, correctOptionIndex, showResult, isExamMode, theme, onSelect, fontFamily, textStyles, getTypographyStyle }: any) => (
    <View style={{ gap: 12 }}>
        {options?.map((opt: any, idx: number) => {
            const isUserSelection = selected === idx;
            const isCorrect = idx === correctOptionIndex;
            const optionLabel = String.fromCharCode(65 + idx);

            let borderColor = 'transparent';
            let bg = theme.bg;
            let textColor = theme.text;

            if (showResult) {
                if (isCorrect) {
                    borderColor = '#22c55e'; bg = '#f0fdf4'; textColor = '#14532d';
                } else if (isUserSelection) {
                    borderColor = '#ef4444'; bg = '#fef2f2'; textColor = '#7f1d1d';
                }
            } else if (isUserSelection) {
                borderColor = '#2563eb'; bg = theme.highlight;
            }

            return (
                <TouchableOpacity
                    key={idx}
                    disabled={!isExamMode && showResult}
                    activeOpacity={0.8}
                    onPress={() => onSelect(idx)}
                    style={{
                        flexDirection: 'row',
                        alignItems: 'center',
                        padding: 16,
                        borderRadius: 12,
                        backgroundColor: bg,
                        borderWidth: 1,
                        borderColor: borderColor === 'transparent' ? theme.border : borderColor,
                    }}
                >
                    <View style={{
                        width: 30, height: 30, borderRadius: 15,
                        backgroundColor: showResult && (isCorrect || isUserSelection)
                            ? (isCorrect ? '#22c55e' : '#ef4444')
                            : (isUserSelection ? '#2563eb' : theme.uiBg),
                        alignItems: 'center', justifyContent: 'center',
                        marginRight: 15,
                        borderWidth: 1,
                        borderColor: theme.border
                    }}>
                        <Text style={{ fontSize: 14, fontWeight: 'bold', color: (showResult && (isCorrect || isUserSelection)) || isUserSelection ? 'white' : theme.secondary }}>
                            {optionLabel}
                        </Text>
                    </View>
                    <Text style={{ fontSize: 16, color: textColor, flex: 1, fontWeight: '500', ...getTypographyStyle(fontFamily, textStyles) }}>{opt}</Text>
                </TouchableOpacity>
            );
        })}
    </View>
));

const QuizContentHeader = React.memo(({ currentIndex, contextText, showReferenceText, setShowReferenceText, visualUri, isGeneratingVisual, onGenerateVisual, theme, primaryColor, showResult, qSelected, qCorrectIndex }: any) => (
    <View style={{ marginBottom: 15, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8, flex: 1, flexWrap: 'wrap' }}>
            <Text style={{ color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase', fontSize: 12, letterSpacing: 1 }}>
                Question {currentIndex + 1}
            </Text>

            {contextText && (
                <TouchableOpacity
                    onPress={() => setShowReferenceText(!showReferenceText)}
                    style={{
                        paddingHorizontal: 8, paddingVertical: 4,
                        backgroundColor: showReferenceText ? theme.highlight : theme.buttonBg,
                        borderRadius: 6, borderWidth: 1,
                        borderColor: showReferenceText ? primaryColor : theme.border,
                        flexDirection: 'row', alignItems: 'center', gap: 4
                    }}
                >
                    <FileText size={12} color={showReferenceText ? primaryColor : theme.secondary} />
                    <Text style={{ fontSize: 10, fontWeight: 'bold', color: showReferenceText ? primaryColor : theme.secondary }}>
                        {showReferenceText ? "Hide Text" : "Read Text"}
                    </Text>
                </TouchableOpacity>
            )}

            {!visualUri && (
                <TouchableOpacity
                    onPress={onGenerateVisual}
                    disabled={isGeneratingVisual}
                    style={{ padding: 4, backgroundColor: theme.buttonBg, borderRadius: 6, borderWidth: 1, borderColor: theme.border }}
                >
                    {isGeneratingVisual ? (
                        <ActivityIndicator size="small" color={theme.secondary} style={{ transform: [{ scale: 0.7 }] }} />
                    ) : (
                        <ImageIcon size={14} color={theme.secondary} />
                    )}
                </TouchableOpacity>
            )}
        </View>

        {showResult && (
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                {qSelected === qCorrectIndex
                    ? <CheckCircle size={16} color="#16a34a" style={{ marginRight: 5 }} />
                    : <XCircle size={16} color="#dc2626" style={{ marginRight: 5 }} />
                }
                <Text style={{ fontSize: 12, fontWeight: 'bold', color: qSelected === qCorrectIndex ? '#16a34a' : '#dc2626' }}>
                    {qSelected === qCorrectIndex ? 'Correct' : 'Incorrect'}
                </Text>
            </View>
        )}
    </View>
));

// NEW: Extracted QuestionSlider Component to prevent scroll reset on re-render
const QuestionSlider = React.memo(({ questions, currentIndex, onJump, theme, isExamMode }: any) => {
    return (
        <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ paddingHorizontal: 15, gap: 8, paddingVertical: 10 }}>
            {questions.map((qItem: any, idx: number) => {
                const isCurrent = idx === currentIndex;
                const isUserSel = qItem.selected !== null;
                const isCorrect = qItem.selected === qItem.correctOptionIndex;

                let bgColor = theme.buttonBg;
                let borderColor = theme.border;
                let textColor = theme.text;

                // Logic adapted from previous QuestionMap
                if (isExamMode) {
                    if (qItem.markedForReview) {
                        bgColor = '#eab308'; borderColor = '#eab308'; textColor = 'white';
                    } else if (isUserSel) {
                        bgColor = '#22c55e'; borderColor = '#22c55e'; textColor = 'white';
                    } else if (qItem.visited && !isUserSel) {
                        bgColor = '#ef4444'; borderColor = '#ef4444'; textColor = 'white';
                    }
                } else {
                    // Practice Mode
                    if (isUserSel) {
                        if (isCorrect) { bgColor = '#22c55e'; borderColor = '#22c55e'; textColor = 'white'; }
                        else { bgColor = '#ef4444'; borderColor = '#ef4444'; textColor = 'white'; }
                    } else if (qItem.visited && !isUserSel) {
                        bgColor = '#f59e0b'; borderColor = '#f59e0b'; textColor = 'white';
                    }
                }

                if (isCurrent) {
                    borderColor = '#2563eb';
                    if (bgColor === theme.buttonBg) {
                        bgColor = theme.highlight;
                        textColor = '#2563eb';
                    }
                }

                return (
                    <TouchableOpacity
                        key={idx}
                        onPress={() => onJump(idx)}
                        style={{
                            width: 36, height: 36, borderRadius: 18,
                            backgroundColor: bgColor,
                            alignItems: 'center', justifyContent: 'center',
                            borderWidth: isCurrent ? 2 : 1,
                            borderColor: borderColor
                        }}
                    >
                        <Text style={{ color: textColor, fontWeight: 'bold', fontSize: 12 }}>{idx + 1}</Text>
                    </TouchableOpacity>
                );
            })}
        </ScrollView>
    );
});

// --- Main App Component ---
const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    header: { height: 50, flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', paddingHorizontal: 16, borderBottomWidth: 1 },
    logoContainer: { flexDirection: 'row', alignItems: 'center', flex: 1, marginRight: 10 },
    logoBox: { width: 32, height: 32, borderRadius: 8, alignItems: 'center', justifyContent: 'center', marginRight: 8 },
    logoText: { fontWeight: 'bold', fontSize: 18 },
    appTitle: { fontSize: 20, fontWeight: 'bold' },
    iconBtn: { padding: 8, borderRadius: 20, borderWidth: 1 },
    scrollContent: { paddingHorizontal: 20, paddingTop: 10, paddingBottom: 5 },
    welcomeSection: { alignItems: 'center', marginVertical: 10 },
    welcomeTitle: { fontSize: 28, fontWeight: 'bold', marginBottom: 8 },
    welcomeSub: { fontSize: 16, marginBottom: 20 },
    // searchBar: { flexDirection: 'row', width: '100%', height: 50, borderRadius: 25, borderWidth: 1, alignItems: 'center', paddingLeft: 5, paddingRight: 5, marginBottom: 30 }, // Duplicate removed
    searchInput: { flex: 1, height: '100%', fontSize: 16 },
    searchBtn: { backgroundColor: '#2563eb', padding: 10, borderRadius: 20, alignItems: 'center', justifyContent: 'center' },

    centerContent: { flex: 1, alignItems: 'center', justifyContent: 'center' },
    loadingText: { marginTop: 20, fontSize: 18, fontWeight: 'bold' },
    articleContent: { padding: 20, paddingBottom: 100 },
    // FIXED: Removed fontWeight: 'bold' to allow "zeroing" and user control via Text Style settings
    articleTitle: { fontSize: 24, marginBottom: 15 },
    articleText: { fontSize: 18 },

    coverImage: { width: '100%', height: 300, borderRadius: 16, marginBottom: 20 }, // Increased height
    quizOption: { padding: 16, borderRadius: 12, borderWidth: 1, marginBottom: 10 },
    primaryBtn: { backgroundColor: '#2563eb', padding: 16, borderRadius: 12, alignItems: 'center', justifyContent: 'center' },
    primaryBtnText: { color: 'white', fontWeight: 'bold', fontSize: 16 },
    secondaryBtn: { flexDirection: 'row', alignItems: 'center', justifyContent: 'center', padding: 12, borderRadius: 12 },
    modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'flex-end' },
    modalContent: { borderTopLeftRadius: 24, borderTopRightRadius: 24, padding: 24, minHeight: 400 },
    modalHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 },
    modalTitle: { fontSize: 22, fontWeight: 'bold' },
    fullScreenModal: { flex: 1 },
    themeBtn: { flex: 1, padding: 12, borderRadius: 8, alignItems: 'center', justifyContent: 'center' },
    sectionTitle: { fontSize: 14, fontWeight: 'bold', textTransform: 'uppercase', marginBottom: 10 },
    input: { width: '100%', padding: 14, borderRadius: 12, borderWidth: 1, marginBottom: 20 },
    textArea: { width: '100%', padding: 14, borderRadius: 12, borderWidth: 1, height: 120, textAlignVertical: 'top' },
    historyItem: { padding: 16, borderRadius: 12, borderWidth: 1, marginBottom: 10 },
    historyTitle: { fontSize: 16, fontWeight: 'bold', marginBottom: 4 },
    footer: {
        flexDirection: 'row',
        height: 80, // Increased from 60 to 80
        borderTopWidth: 1,
        alignItems: 'center',
        justifyContent: 'space-around',
        paddingBottom: 10 // Added padding for safe area
    },
    tabItem: {
        flex: 1,
        height: '100%', // Ensure full height clickability
        alignItems: 'center',
        justifyContent: 'center',
        paddingVertical: 5 // Increased padding
    },
    settingsCard: {
        padding: 20,
        borderRadius: 16,
        borderWidth: 1,
        marginBottom: 20
    },
    appearanceLabel: {
        fontSize: 12,
        fontWeight: '700',
        marginBottom: 10,
        textTransform: 'uppercase',
        letterSpacing: 1
    },
    segmentedContainer: {
        flexDirection: 'row',
        borderRadius: 8,
        padding: 4
    },
    segmentedOption: {
        flex: 1,
        paddingVertical: 6,
        alignItems: 'center',
        borderRadius: 6
    },
    segmentedOptionActive: {
        shadowColor: "#000",
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
        elevation: 2
    },
    segmentedText: {
        fontSize: 12,
        fontWeight: '500'
    },
    segmentedTextActive: {
        fontWeight: 'bold'
    },
    appearanceSection: {
        marginBottom: 20
    },
    appearanceSectionTitle: {
        fontSize: 12,
        fontWeight: '700',
        marginBottom: 12,
        textTransform: 'uppercase',
        letterSpacing: 1
    },
    divider: {
        height: 1,
        backgroundColor: 'rgba(0,0,0,0.05)',
        marginVertical: 15
    },
    searchBar: { flexDirection: 'row', width: '100%', minHeight: 50, maxHeight: 150, borderRadius: 25, borderWidth: 1, alignItems: 'center', paddingLeft: 5, paddingRight: 5, marginBottom: 30, paddingVertical: 4 },
    // searchInput: { flex: 1, fontSize: 16, paddingHorizontal: 8 }, // Duplicate removed
    // NEW STYLES FOR ADVERTISEMENT
    adContainer: {
        borderRadius: 16,
        overflow: 'hidden',
        borderWidth: 1,
        height: 160,
        marginBottom: 10,
        position: 'relative'
    },
    adImage: {
        width: '100%',
        height: '100%',
    },
    adOverlay: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        padding: 15,
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-end',
        paddingTop: 40 // Fade gradient start
    },
    adTitle: {
        color: 'white',
        fontWeight: '900',
        fontSize: 20,
        textShadowColor: 'rgba(0, 0, 0, 0.5)',
        textShadowOffset: { width: 0, height: 1 },
        textShadowRadius: 2
    },
    adSubtitle: {
        color: 'rgba(255,255,255,0.9)',
        fontSize: 13,
        marginTop: 2,
        fontWeight: '500'
    }
});

const OnboardingModal = ({ visible, onClose, theme, onSave }: any) => {
    const [name, setName] = useState("");
    const [profession, setProfession] = useState("");
    const [goal, setGoal] = useState("");
    const [bio, setBio] = useState("");

    const handleNext = () => {
        if (!name.trim()) {
            Alert.alert("Required", "Please tell us your name.");
            return;
        }
        onSave({ userName: name, userProfession: profession, userGoal: goal, userBio: bio });
    };

    return (
        <Modal visible={visible} animationType="slide" transparent>
            <KeyboardAvoidingView
                behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                style={{ flex: 1 }}
            >
                <View style={{ flex: 1, backgroundColor: theme.bg, padding: 20, paddingTop: 60 }}>
                    <Text style={{ fontSize: 28, fontWeight: 'bold', color: theme.text, marginBottom: 10, textAlign: 'center' }}>Welcome! ðŸ‘‹</Text>
                    <Text style={{ fontSize: 16, color: theme.secondary, marginBottom: 20, textAlign: 'center' }}>Let's personalize your experience.</Text>

                    {/* Elite Pass Banner */}
                    <View style={{
                        backgroundColor: 'rgba(234, 179, 8, 0.15)', // Golden tint
                        borderColor: '#EAB308',
                        borderWidth: 1,
                        borderRadius: 16,
                        padding: 16,
                        marginBottom: 30,
                        flexDirection: 'row',
                        alignItems: 'center',
                        gap: 12
                    }}>
                        <View style={{
                            width: 40, height: 40, borderRadius: 20,
                            backgroundColor: '#EAB308',
                            alignItems: 'center', justifyContent: 'center'
                        }}>
                            <Crown size={24} color="white" fill="white" />
                        </View>
                        <View style={{ flex: 1 }}>
                            <Text style={{ color: '#EAB308', fontWeight: '800', fontSize: 13, textTransform: 'uppercase', marginBottom: 2, letterSpacing: 0.5 }}>Early Access Bonus</Text>
                            <Text style={{ color: theme.text, fontSize: 14, fontWeight: '600' }}>
                                Elite Pass unlocked until <Text style={{ color: '#EAB308' }}>Dec 31, 2026</Text>
                            </Text>
                        </View>
                    </View>

                    <ScrollView showsVerticalScrollIndicator={false}>
                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>What should we call you? *</Text>
                        <TextInput
                            style={{ backgroundColor: theme.inputBg, color: theme.text, padding: 15, borderRadius: 12, borderWidth: 1, borderColor: theme.border, marginBottom: 20, fontSize: 16 }}
                            placeholder="Your Name"
                            placeholderTextColor={theme.secondary}
                            value={name}
                            onChangeText={setName}
                        />

                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>What do you do?</Text>
                        <TextInput
                            style={{ backgroundColor: theme.inputBg, color: theme.text, padding: 15, borderRadius: 12, borderWidth: 1, borderColor: theme.border, marginBottom: 20, fontSize: 16 }}
                            placeholder="Student, Designer, Engineer..."
                            placeholderTextColor={theme.secondary}
                            value={profession}
                            onChangeText={setProfession}
                        />

                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>Main Goal?</Text>
                        <TextInput
                            style={{ backgroundColor: theme.inputBg, color: theme.text, padding: 15, borderRadius: 12, borderWidth: 1, borderColor: theme.border, marginBottom: 20, fontSize: 16 }}
                            placeholder="Learn AI, Write a Book, Ace Exams..."
                            placeholderTextColor={theme.secondary}
                            value={goal}
                            onChangeText={setGoal}
                        />

                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>How should AI answer you?</Text>
                        <TextInput
                            style={{ backgroundColor: theme.inputBg, color: theme.text, padding: 15, borderRadius: 12, borderWidth: 1, borderColor: theme.border, marginBottom: 30, fontSize: 16, height: 100, textAlignVertical: 'top' }}
                            placeholder="e.g. Simple terms, professional tone, use analogies, be concise..."
                            placeholderTextColor={theme.secondary}
                            value={bio}
                            onChangeText={setBio}
                            multiline
                        />

                        <TouchableOpacity
                            onPress={handleNext}
                            style={{ backgroundColor: theme.primary, padding: 18, borderRadius: 16, alignItems: 'center', shadowColor: theme.primary, shadowOpacity: 0.4, shadowRadius: 10, shadowOffset: { width: 0, height: 4 }, elevation: 5 }}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                                <Text style={{ color: 'white', fontSize: 18, fontWeight: 'bold' }}>Next: Explore App</Text>
                                <ArrowRight size={20} color="white" />
                            </View>
                        </TouchableOpacity>
                    </ScrollView>
                </View>
            </KeyboardAvoidingView>
        </Modal>
    );
};

const OnboardingPreviewFooter = ({ theme, apiKey, setApiKey, testConnection, connectionStatus, onFinish, onSkip, isLandscape }: any) => {
    return (
        <View style={{
            backgroundColor: theme.bg,
            borderTopWidth: 1,
            borderTopColor: theme.border,
            padding: isLandscape ? 10 : 20,
            paddingBottom: Platform.OS === 'ios' ? (isLandscape ? 15 : 40) : (isLandscape ? 10 : 20),
            zIndex: 1000
        }}>
            <Text style={{ color: theme.text, fontSize: isLandscape ? 14 : 18, fontWeight: 'bold', marginBottom: isLandscape ? 3 : 5 }}>Setup AI Connection</Text>
            <Text style={{ color: theme.secondary, fontSize: isLandscape ? 12 : 14, marginBottom: isLandscape ? 8 : 15 }}>Enter your Gemini API Key to unlock Smart Features.</Text>

            <View style={{ flexDirection: 'row', gap: 10, marginBottom: isLandscape ? 8 : 15 }}>
                <TextInput
                    style={{
                        flex: 1,
                        backgroundColor: theme.inputBg,
                        color: theme.text,
                        padding: isLandscape ? 8 : 12,
                        borderRadius: 12,
                        borderWidth: 1,
                        borderColor: connectionStatus === 'success' ? '#22c55e' : (connectionStatus === 'failed' ? '#ef4444' : theme.border),
                        fontSize: isLandscape ? 12 : 14
                    }}
                    placeholder="Enter API Key..."
                    placeholderTextColor={theme.secondary}
                    value={apiKey}
                    onChangeText={setApiKey}
                    secureTextEntry
                />
                <TouchableOpacity
                    onPress={testConnection}
                    disabled={connectionStatus === 'testing'}
                    style={{
                        backgroundColor: connectionStatus === 'success' ? '#22c55e' : theme.buttonBg,
                        paddingHorizontal: isLandscape ? 15 : 20,
                        justifyContent: 'center',
                        borderRadius: 12,
                        borderWidth: 1,
                        borderColor: connectionStatus === 'success' ? '#22c55e' : theme.border
                    }}
                >
                    {connectionStatus === 'testing' ? (
                        <ActivityIndicator size="small" color="#4f46e5" />
                    ) : (
                        <Text style={{ color: connectionStatus === 'success' ? 'white' : theme.text, fontWeight: 'bold', fontSize: isLandscape ? 12 : 14 }}>
                            {connectionStatus === 'success' ? "Linked" : "Test"}
                        </Text>
                    )}
                </TouchableOpacity>
            </View>

            <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                <TouchableOpacity onPress={onSkip}>
                    <Text style={{ color: theme.secondary, fontSize: isLandscape ? 12 : 14, textDecorationLine: 'underline' }}>Skip for now</Text>
                </TouchableOpacity>

                <TouchableOpacity
                    onPress={onFinish}
                    style={{
                        backgroundColor: '#4f46e5',
                        paddingVertical: isLandscape ? 8 : 12,
                        paddingHorizontal: isLandscape ? 20 : 25,
                        borderRadius: 12,
                        flexDirection: 'row',
                        alignItems: 'center',
                        gap: 8,
                        opacity: connectionStatus === 'success' ? 1 : 0.6
                    }}
                >
                    <Text style={{ color: 'white', fontWeight: 'bold', fontSize: isLandscape ? 14 : 16 }}>Finish Setup</Text>
                    <ArrowRight size={isLandscape ? 16 : 20} color="white" />
                </TouchableOpacity>
            </View>
        </View>
    );
};

// NEW: Helper to get human-readable language name
const getLanguageName = (code: string) => {
    const manualMap: { [key: string]: string } = {
        'en-US': 'English (US)',
        'en-GB': 'English (UK)',
        'en-IN': 'English (India)',
        'en-AU': 'English (Australia)',
        'hi-IN': 'Hindi (India)',
        'es-ES': 'Spanish (Spain)',
        'fr-FR': 'French (France)',
        'de-DE': 'German (Germany)',
        'it-IT': 'Italian (Italy)',
        'ja-JP': 'Japanese (Japan)',
        'ko-KR': 'Korean (Korea)',
        'pt-BR': 'Portuguese (Brazil)',
        'ru-RU': 'Russian (Russia)',
        'zh-CN': 'Chinese (Simplified)',
        'zh-TW': 'Chinese (Traditional)',
    };
    if (manualMap[code]) return manualMap[code];

    try {
        // Fallback to Intl.DisplayNames if available
        // @ts-ignore
        const languageNames = new Intl.DisplayNames(['en'], { type: 'language' });
        return languageNames.of(code) || code;
    } catch (e) {
        return code;
    }
};

const LanguageSelector = ({
    items,
    selectedItem,
    onSelect,
    theme
}: {
    items: { code: string; label: string }[];
    selectedItem: string;
    onSelect: (lang: string) => void;
    theme: any;
}) => {
    return (
        <View style={{ marginBottom: 20 }}>
            <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 10, textTransform: 'uppercase' }}>
                OFFLINE TTS NARRATORS
            </Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {items.map((item) => {
                    const isSelected = item.code === selectedItem;
                    return (
                        <TouchableOpacity
                            key={item.code}
                            onPress={() => onSelect(item.code)}
                            style={{
                                paddingHorizontal: 16,
                                paddingVertical: 8,
                                borderRadius: 20,
                                backgroundColor: isSelected ? theme.primary : theme.uiBg,
                                marginRight: 10,
                                borderWidth: 1,
                                borderColor: isSelected ? theme.primary : theme.border
                            }}
                        >
                            <Text style={{
                                color: isSelected ? '#fff' : theme.text,
                                fontWeight: '600',
                                fontSize: 14
                            }}>
                                {item.label}
                            </Text>
                        </TouchableOpacity>
                    );
                })}
            </ScrollView>
        </View>
    );
};

export default function App() {
    const [displaySettings, setDisplaySettings] = useState<any>({
        theme: "forest",
        fontSize: 1.0,
        ttsRate: 1.0,
        fontFamily: "Modern",
        textStyles: [] as string[],
        language: "English",
        availableLanguages: ["English"],
        primaryLanguage: "English", // NEW
        voice: "Kore",
        onlineTtsEnabled: true,
        imageGenerationEnabled: true,
        modelPriority: "speed",
        groqModelPriority: "quality",
        groqCustomModel: "",
        savedGroqCustomModels: [],
        showPersonalDictionary: true,
        customTextModel: "",
        savedCustomModels: [],
        preventSleep: false,
        userProfession: "", // NEW
        userGoal: "", // NEW
        userBio: "", // NEW
        dictionaryLimit: 10000,
        libraryLimit: 2000, // UPDATED: Default limit increased to 2000
        tapToDefine: true,
        keepLabelsEnglish: false,
        userName: "",
        nameLocked: false, // NEW
        isExamMode: false,
        quizTarget: 'quiz', // 'quiz' | 'flashcards'
        modeLocked: false, // NEW: Lock state for name
        isOnboarded: false, // NEW: Onboarding state
        smartBio: "", // NEW: AI-generated summary
        offlineTtsLanguage: "en-GB", // NEW: Default to English (UK) as per user observation
        offlineVoice: "", // NEW: Specific voice identifier
    });

    // NEW: Available Offline Voices (stored as objects)
    const [availableVoices, setAvailableVoices] = useState<{ code: string; label: string; identifier?: string }[]>([]);

    useEffect(() => {
        const fetchVoices = async () => {
            try {
                const voices = await Speech.getAvailableVoicesAsync();

                // 1. Sort by language first to group them
                voices.sort((a, b) => a.language.localeCompare(b.language));

                // 2. Map with sequential numbering
                const languageCounts: { [key: string]: number } = {};

                const mappedVoices = voices.map(v => {
                    if (!languageCounts[v.language]) {
                        languageCounts[v.language] = 0;
                    }
                    languageCounts[v.language]++;

                    return {
                        code: v.language,
                        label: `${getLanguageName(v.language)} (Voice ${languageCounts[v.language]})`,
                        identifier: v.identifier
                    };
                }).sort((a, b) => a.label.localeCompare(b.label));

                setAvailableVoices(mappedVoices);
                console.log("Loaded Voices:", mappedVoices.length);
            } catch (e) {
                console.warn("Failed to fetch TTS voices", e);
            }
        };
        fetchVoices();
    }, []);

    const theme = THEMES[displaySettings.theme];

    const recorder = useAudioRecorder(SPEECH_RECORDING_OPTIONS);
    const [customApiKey, setCustomApiKey] = useState("");
    const [isInOnboardingPreview, setIsInOnboardingPreview] = useState(false);
    const [dictionaryViewMode, setDictionaryViewMode] = useState('list'); // 'list' or 'advanced'

    const [flashcardSession, setFlashcardSession] = useState<any>(null);

    const [lastQuizSubject, setLastQuizSubject] = useState<any>("General");
    const [selectedScenario, setSelectedScenario] = useState<any>(null);
    // UPDATED: Added isLanguageLearning to schoolConfig state
    const [schoolConfig, setSchoolConfig] = useState<any>({ input: "", length: "Medium", complexity: "Intermediate", subject: "General", isLanguageLearning: false });
    const [chatSessions, setChatSessions] = useState<any>({});
    const [savedWords, setSavedWords] = useState<any[]>([]);
    const [wordMap, setWordMap] = useState<Set<string>>(new Set());
    // Pagination State
    const [allSessionIds, setAllSessionIds] = useState<string[]>([]);
    const [loadedSessionCount, setLoadedSessionCount] = useState(50);

    useEffect(() => {
        // Build O(1) lookup set when savedWords changes
        const m = new Set<string>();
        savedWords.forEach(w => {
            if (w.word) m.add(w.word.toLowerCase());
        });
        setWordMap(m);
    }, [savedWords]);

    const [availableSubjects, setAvailableSubjects] = useState<any[]>([]);
    const [readingSession, setReadingSession] = useState<any>(null);
    const [isEditingNote, setIsEditingNote] = useState<any>(false);
    const [currentNoteInput, setCurrentNoteInput] = useState<any>("");
    const [currentNoteTitle, setCurrentNoteTitle] = useState<any>("");
    const [currentNoteSummary, setCurrentNoteSummary] = useState<any>("");
    const [currentNoteId, setCurrentNoteId] = useState<any>(null);
    const [currentNoteImages, setCurrentNoteImages] = useState<any[]>([]);
    const [isNoteAnalyzing, setIsNoteAnalyzing] = useState<any>(false);
    const [customNotePrompt, setCustomNotePrompt] = useState<any>("");
    const [nextChapterInput, setNextChapterInput] = useState<any>(""); // NEW: State for story continuation guidance
    const [showStoryAd, setShowStoryAd] = useState<any>(false); // NEW: State for showing ad in story reader
    const [isSaving, setIsSaving] = useState<any>(false);
    const [noteSearchQuery, setNoteSearchQuery] = useState<any>("");
    const [librarySearchQuery, setLibrarySearchQuery] = useState<any>("");
    const [imagePickerMode, setImagePickerMode] = useState<any>('vision');
    // NEW: Debounce ref to prevent double-clicks in quiz
    const quizProcessingRef = useRef<any>(false);
    const [quizState, setQuizState] = useState<any>(null);
    const [isExamMode, setIsExamMode] = useState<any>(false);
    const [isFlashcardMode, setIsFlashcardMode] = useState<any>(false);
    const [savedQuestions, setSavedQuestions] = useState<any[]>([]);
    const [questionsViewMode, setQuestionsViewMode] = useState<any>('quizzes');
    const [selectedWord, setSelectedWord] = useState<any>(null);
    const [dictionaryInput, setDictionaryInput] = useState<any>("");
    const [quizPassword, setQuizPassword] = useState<any>(""); // NEW: Password State
    const [quizUnlockInput, setQuizUnlockInput] = useState<any>(""); // NEW: Unlock Input State
    const [isReviewUnlocked, setIsReviewUnlocked] = useState<any>(false); // NEW: Lock State
    const [audioFiles, setAudioFiles] = useState<any[]>([]);
    const [isAudioLoading, setIsAudioLoading] = useState<any>(false);
    const [wordData, setWordData] = useState<any>(null);
    const [isDefining, setIsDefining] = useState<any>(false);


    const [dictionaryResult, setDictionaryResult] = useState<any>(null);
    const [isDictionaryLoading, setIsDictionaryLoading] = useState<any>(false);
    const [isBatchProcessing, setIsBatchProcessing] = useState<any>(false); // NEW: Non-blocking batch indicator
    const [recentSearches, setRecentSearches] = useState<any[]>([]);
    const recentSearchesRef = useRef<any[]>([]); // SINGLE SOURCE OF TRUTH for Dictionary

    // HELPER: Orchestrator for safely updating Dictionary List (Fixes Concurrency)
    const updateRecentSearchesOrchestrator = async (newItems: any[], skipStateUpdate: boolean = false) => {
        // 1. Update Reference (Master List)
        recentSearchesRef.current = newItems;

        // 2. Save to File (Always Persist Master List)
        await saveRecentSearchesToFile(newItems);

        // 3. Update UI State (Optional - can be skipped for batch logic)
        if (!skipStateUpdate) {
            setRecentSearches(newItems);
        }
    };
    const [dictionaryCurrentWord, setDictionaryCurrentWord] = useState<any>("");
    const [dictionaryCache, setDictionaryCache] = useState<any>({});
    const [quizSecondsElapsed, setQuizSecondsElapsed] = useState<any>(0);
    const [apiConnectionStatus, setApiConnectionStatus] = useState<any>("idle");
    const [isLoadingHistory, setIsLoadingHistory] = useState<any>(false);
    const [fabPosition, setFabPosition] = useState<any>({ x: 0, y: 0 });
    const [fullScreenImage, setFullScreenImage] = useState<any>(null);
    const [storageStats, setStorageStats] = useState<any>({ free: 0, used: 0, audio: 0 }); // UPDATED: Added audio field

    // NEW: Track specific audio item export state to block UI
    const [isExportingAudioId, setIsExportingAudioId] = useState<any>(null);

    // Restored State Variables
    const [appMode, setAppMode] = useState("idle");
    const [activeTab, setActiveTab] = useState("home");
    const [navOrigin, setNavOrigin] = useState("idle");
    const [quickSearchQuery, setQuickSearchQuery] = useState("");
    const [generationData, setGenerationData] = useState<any>(null);
    const [isTranslating, setIsTranslating] = useState(false);
    const [isRateLimited, setIsRateLimited] = useState(false);
    const [isCheckingModel, setIsCheckingModel] = useState(false);
    const [showModelSelector, setShowModelSelector] = useState(false);
    const [showGroqModelSelector, setShowGroqModelSelector] = useState(false);
    const [isReaderQuerying, setIsReaderQuerying] = useState(false);
    const [greetingsMode, setGreetingsMode] = useState('greeting');
    const [minimizedSession, setMinimizedSession] = useState<any>(null);
    const [showFullScreenReference, setShowFullScreenReference] = useState(false);
    const [showReferenceText, setShowReferenceText] = useState(false);
    const [isRecording, setIsRecording] = useState(false);
    const [isTranscribing, setIsTranscribing] = useState(false);

    // NEW: Sharing Lock State to prevent multiple tap crashes
    const [isSharing, setIsSharing] = useState<any>(false);
    const [isCustomAudioPlaying, setIsCustomAudioPlaying] = useState<boolean>(false);
    const customAudioPlayerRef = useRef<any>(null);
    const [customAudioUrisState, setCustomAudioUrisState] = useState<Record<string, string>>({});
    // NEW: Track playback progress for custom uploaded audio
    const [customAudioProgress, setCustomAudioProgress] = useState<{ position: number, duration: number }>({ position: 0, duration: 1 });
    // NEW: Tracking Profile Edit Mode
    const [isEditingProfile, setIsEditingProfile] = useState(false);
    const [isGeneratingBio, setIsGeneratingBio] = useState(false);

    // NEW: State to prevent onboarding flash (Race Condition Fix)
    const [isSettingsLoaded, setIsSettingsLoaded] = useState(false);

    useEffect(() => {
        // Load custom audio mappings
        AsyncStorage.getItem('customAudioUris').then(json => {
            if (json) {
                const parsed = JSON.parse(json);
                setCustomAudioUrisState(parsed);
                customAudioUris = parsed; // Sync global/module variable
            }
        });

        // Hook up global setter so handleUploadAudio updates state
        setCustomAudioUris = (newMappings: Record<string, string>) => {
            customAudioUris = newMappings;
            setCustomAudioUrisState(newMappings);
            AsyncStorage.setItem('customAudioUris', JSON.stringify(newMappings));
        };
    }, []);

    // NEW: Dynamic Image Aspect Ratio for Reader Mode
    const [coverAspectRatio, setCoverAspectRatio] = useState<any>(1.5); // Default
    const [ttsFinishedNaturally, setTtsFinishedNaturally] = useState<any>(0);
    const autoPlayRef = useRef<any>(false);
    const [speechRange, setSpeechRange] = useState<any>(null);
    const [ttsStatus, setTtsStatus] = useState<any>("stopped");
    const [playingMeta, setPlayingMeta] = useState<any>(null);
    const [isTtsDownloading, setIsTtsDownloading] = useState<any>(false);
    const persistSession = async (newSession: any) => {
        if (newSession.image && newSession.image.startsWith('data:')) {
            newSession.image = await ensureImageIsSavedToFile(newSession.image);
        }

        if (newSession.images && Array.isArray(newSession.images)) {
            const savedImages = await Promise.all(newSession.images.map((uri: string) => ensureImageIsSavedToFile(uri)));
            newSession.images = savedImages;
        }

        // NEW: Update Quiz History Tracking (Hidden)
        // Saves detailed state for 10 days to allow restoration after deletion
        if (newSession.toolId === 'quiz_save') {
            const historyData = quizHistoryRef.current || {};

            // Clean quizData to reduce size (optional, but good practice)
            // We focus on saving user state (selections) rather than static content if possible, 
            // but saving everything ensures full restoration.
            historyData[newSession.id] = {
                attempts: newSession.attempts || 1,
                score: newSession.score || 0,
                totalQuestions: newSession.totalQuestions || 0,
                totalTime: newSession.totalTime || 0, // Save time taken
                quizData: newSession.quizData, // Save questions & answers state
                timestamp: Date.now()
            };

            quizHistoryRef.current = historyData;
            AsyncStorage.setItem('quiz_history_tracking', JSON.stringify(historyData)).catch(e => console.warn(e));
        }

        // Update State Immediately with FULL content for smooth UI
        setChatSessions((prev: any) => ({ ...prev, [newSession.id]: newSession }));

        const saveToStorage = async () => {
            try {
                // Prepare a copy for storage
                let sessionToSave = JSON.parse(JSON.stringify(newSession));

                // --- NEW: AUTO-ARCHIVING LOGIC (Prevent 2MB Crash) ---
                // If text content grows too large, split it into a new "Part"
                const content = sessionToSave.messages?.[0]?.content || "";
                // Limit: 100KB (Safe threshold well below 2MB limit to allow for overhead and JSON encoding)
                // A typical long chapter might be 10-20KB, so 100KB represents a VERY long conversation.
                const ARCHIVE_THRESHOLD = 100 * 1024;

                if (content.length > ARCHIVE_THRESHOLD) {
                    console.log(`Session ${sessionToSave.id} exceeded size limit (${(content.length / 1024).toFixed(1)}KB). Archiving...`);

                    // Strategy: Keep the last 20% (context) + Title, Archive the rest.
                    // We split by newline to avoid cutting words/markdown formatting.
                    const lines = content.split('\n');
                    const totalLines = lines.length;
                    const splitIndex = Math.floor(totalLines * 0.8); // Archive first 80%

                    const archiveContent = lines.slice(0, splitIndex).join('\n');
                    const activeContent = lines.slice(splitIndex).join('\n');

                    // 1. Create Archive Session
                    const archiveId = generateId();
                    const partNumber = (sessionToSave.partNumber || 1);
                    const archiveTitle = `${sessionToSave.title} (Part ${partNumber})`;

                    // Save archive to FILE immediately (it's large)
                    const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                    const archiveFilename = `archive_${archiveId}.txt`;
                    const archivePath = `${docDir}${archiveFilename}`;
                    await fs.writeAsStringAsync(archivePath, archiveContent, { encoding: fs.EncodingType.UTF8 });

                    const archiveSession = {
                        id: archiveId,
                        title: archiveTitle,
                        timestamp: new Date().toISOString(), // Keep chronological
                        toolId: sessionToSave.toolId,
                        contentPath: archiveFilename, // Pointer to file
                        preview: archiveContent.substring(0, 100).replace(/\n/g, ' '), // Save preview since content cleared
                        pinned: false,
                        partNumber: partNumber
                    };

                    // Save archive session meta to index/storage? 
                    // Use recursive call or manual save. Manual save to avoid loop if logic flawed.
                    await AsyncStorage.setItem(`session_${archiveId}`, JSON.stringify(archiveSession));

                    // Update sessionToSave
                    sessionToSave.partNumber = partNumber + 1;
                    if (sessionToSave.messages && sessionToSave.messages[0]) {
                        sessionToSave.messages[0].content = `(Continued from Part ${partNumber})\n\n` + activeContent;
                    }

                    // Also add archive to index later
                    const indexJson = await AsyncStorage.getItem('session_index');
                    let index = indexJson ? JSON.parse(indexJson) : [];
                    index.push(archiveId);
                    await AsyncStorage.setItem('session_index', JSON.stringify(index));
                }

                // Normal Save Logic
                // If content is still huge (unlikely after archive), save to file
                // But for now assume standard save.
                // Check if we should use file storage for Main Session too (if > 50KB or has images)
                const currentContent = sessionToSave.messages?.[0]?.content || "";
                if (currentContent.length > 50 * 1024) {
                    const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                    const filename = `content_${sessionToSave.id}.txt`;
                    const path = `${docDir}${filename}`;
                    await fs.writeAsStringAsync(path, currentContent, { encoding: fs.EncodingType.UTF8 });

                    // BUG FIX: Store preview before clearing content
                    sessionToSave.preview = currentContent.substring(0, 100).replace(/\n/g, ' ');
                    sessionToSave.contentPath = filename;
                    if (sessionToSave.messages && sessionToSave.messages[0]) {
                        sessionToSave.messages[0].content = ""; // Clear from JSON to save space
                    }
                }

                await AsyncStorage.setItem(`session_${newSession.id}`, JSON.stringify(sessionToSave));

                // Update Index
                const indexJson = await AsyncStorage.getItem('session_index');
                let index = indexJson ? JSON.parse(indexJson) : [];
                if (!index.includes(newSession.id)) {
                    // Check if we need to remove old items (limit 100?) happening elsewhere
                    // Simple Push
                    index.push(newSession.id);
                    await AsyncStorage.setItem('session_index', JSON.stringify(index));
                }

                // INDEX SYNC: Update Metadata Index
                try {
                    // Optimized: Only read if we have to. 
                    // Actually, for singular updates, reading 1MB JSON is bad.
                    // Ideally we should have a separate store or use SQLite.
                    // For now, we try-catch. If it fails, we delete it to force rebuild.
                    const metaJson = await AsyncStorage.getItem('library_metadata_index');
                    if (metaJson) {
                        let metaMap = JSON.parse(metaJson);
                        const lite = parseSessionLite(JSON.stringify(sessionToSave));
                        if (lite) {
                            metaMap[newSession.id] = lite;
                            await AsyncStorage.setItem('library_metadata_index', JSON.stringify(metaMap));
                        }
                    }
                } catch (idxErr) {
                    console.error("Index Sync Failed - Invalidating Index", idxErr);
                    // If we can't update it, it's stale. Delete it.
                    AsyncStorage.removeItem('library_metadata_index').catch(e => { });
                }
            } catch (e) {
                if (e && (e as any).message && ((e as any).message.includes("code 13") || (e as any).message.includes("full") || (e as any).message.includes("quota"))) {
                    console.warn("Storage full (Code 13).");
                    Alert.alert("Storage Full", "Cannot save more items. Please delete some old items manually or use the Reset Library option in Settings.");
                } else {
                    console.error("Storage Error", e);
                    Alert.alert("Error Saving", "Could not save your session to storage.");
                }
            }
        };

        await saveToStorage();
    };
    // NEW: Refs needed for Deep Linking Handler (to avoid stale closures)
    const persistSessionRef = useRef<any>(null);
    const setChatSessionsRef = useRef<any>(null);
    const setActiveTabRef = useRef<any>(null);
    const setAppModeRef = useRef<any>(null);
    const showToastRef = useRef<any>(null);
    const loadHistorySessionRef = useRef<any>(null);

    // NEW: Add Refs for Dictionary/Recent Searches to allow Import from File Manager
    const setRecentSearchesRef = useRef<any>(null);

    // NEW: Ref for Persistent Quiz History (Survives Deletion)
    const quizHistoryRef = useRef<any>({});
    // NEW: Ref for Active Audio Queue (Playlist within a chapter)
    const activeAudioQueue = useRef({ uris: [], index: 0, itemId: null });

    // NEW: Helper to get or create a persistent Device/Installation ID
    const getInstallationId = async () => {
        try {
            let id = await AsyncStorage.getItem('installation_id');
            if (!id) {
                id = generateId() + '-' + Date.now().toString(36);
                await AsyncStorage.setItem('installation_id', id);
            }
            return id;
        } catch (e) {
            return "unknown-device";
        }
    };

    // NEW: Unified Content Bundler for Sharing
    // NEW: Unified Content Bundler for Sharing (Recursive)
    const createShareBundle = async (items: any, sourceTab: any) => {
        const deviceId = await getInstallationId();
        const visitedIds = new Set<string>(); // Cycle Detection

        // Recursive helper to process items (resolve content, images, children)
        const processExportItem = async (item: any): Promise<any> => {
            // Cycle Check
            if (item.id && visitedIds.has(item.id)) {
                console.warn(`[Export] Cycle detected for ${item.id}. Skipping recursion.`);
                return { ...item, _cycleSkipped: true }; // Return shallow copy to break loop
            }
            if (item.id) visitedIds.add(item.id);

            let processed = { ...item };

            // 0. HYDRATION: If item is "Lite" or missing content, try to fetch full session from storage
            // This fixes the issue where exports only contained metadata because the full content wasn't loaded in memory
            if (processed.isLite || (!processed.messages && !processed.content && !processed.contentPath)) {
                try {
                    // Try to load from session storage
                    const fullJson = await AsyncStorage.getItem(`session_${processed.id}`);
                    if (fullJson) {
                        const fullSession = JSON.parse(fullJson);
                        // Merge, but keep existing metadata if newer (though unlikely for export)
                        processed = { ...processed, ...fullSession };
                        console.log(`[Export] Hydrated session ${processed.id} from storage.`);
                    }
                } catch (e) {
                    console.warn(`[Export] Failed to hydrate session ${processed.id}`, e);
                }
            }

            // 0. Handle Dictionary specific logic
            if (sourceTab === 'dictionary') {
                if (!processed.id && processed.data?.id) processed.id = processed.data.id;
                if (!processed.id) processed.id = generateId();
                return processed;
            }

            // 1. Resolve Text Content from File
            if (processed.contentPath) {
                try {
                    // BUG FIX: Ensure we have a full URI. If it's just a filename, prepend documentDirectory.
                    const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                    const fullPath = processed.contentPath.startsWith('file://')
                        ? processed.contentPath
                        : (docDir + processed.contentPath);

                    const info = await fs.getInfoAsync(fullPath);
                    if (info.exists) {
                        const text = await fs.readAsStringAsync(fullPath, { encoding: fs.EncodingType.UTF8 });
                        processed.content = text;
                        if (processed.messages && processed.messages[0]) {
                            processed.messages[0].content = text;
                        }
                    }
                } catch (e: any) { }
                delete processed.contentPath;
            } else {
                if (!processed.content && processed.messages && processed.messages[0]) {
                    processed.content = processed.messages[0].content;
                }
            }

            // 2. Resolve Images
            if (processed.images && Array.isArray(processed.images)) {
                const MAX_IMAGE_SIZE = 500 * 1024;
                const MAX_FINAL_SIZE = 1024 * 1024;
                const b64List = await Promise.all(processed.images.map(async (uri: any) => {
                    if (typeof uri !== 'string') return null;
                    if (uri.startsWith('data:')) return uri;
                    try {
                        const fileInfo = await fs.getInfoAsync(uri);
                        if (!fileInfo.exists) return null;
                        let finalUri = uri;
                        if (fileInfo.size > MAX_IMAGE_SIZE) {
                            const compressed = await ImageManipulator.manipulateAsync(
                                uri,
                                [{ resize: { width: 1024 } }],
                                { compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
                            );
                            finalUri = compressed.uri;
                        }
                        const b64 = await fs.readAsStringAsync(finalUri, { encoding: fs.EncodingType.Base64 });
                        const base64Size = (b64.length * 3) / 4;
                        if (base64Size > MAX_FINAL_SIZE) return null;
                        const mime = uri.toLowerCase().endsWith('.pdf') ? 'application/pdf' : 'image/jpeg';
                        return `data:${mime};base64,${b64}`;
                    } catch (e) { return null; }
                }));
                processed.images = b64List.filter(Boolean);
            }

            // 3. Resolve Cover Image
            if (processed.image && !processed.image.startsWith('data:')) {
                try {
                    const b64 = await fs.readAsStringAsync(processed.image, { encoding: fs.EncodingType.Base64 });
                    processed.image = `data:image/jpeg;base64,${b64}`;
                } catch (e) { }
            }

            // 4. Recursively Process Children (Chapters / Items)
            if (processed.chapters && Array.isArray(processed.chapters)) {
                processed.chapters = await Promise.all(processed.chapters.map(processExportItem));
            }
            if (processed.items && Array.isArray(processed.items)) {
                processed.items = await Promise.all(processed.items.map(processExportItem));
            }

            return processed;
        };

        const processedItems = await Promise.all(items.map(processExportItem));

        return {
            type: "reader_unified_export",
            version: 1,
            deviceId: deviceId,
            sourceTab: sourceTab,
            timestamp: new Date().toISOString(),
            items: processedItems
        };
    };

    // NEW: Refs for Auto-Submit Logic
    const chatSessionsRef = useRef(chatSessions);
    const quizStateRef = useRef(quizState);
    const quizSecondsElapsedRef = useRef(quizSecondsElapsed);
    const handleAutoSubmitExamRef = useRef<any>(null); // NEW: Ref for the handler

    // CHANGED: Removed useURL hook to avoid "multiple linking" error with Expo Router
    const lastProcessedUrl = useRef<any>(null);
    const lastProcessedTime = useRef(0); // NEW: Time tracking for debounce

    // DEEP LINKING HANDLER
    useEffect(() => {
        // Helper to save text as note or move existing to top
        const processContentAsNote = async (text: string, defaultTitle: string) => {
            // 1. Check for Duplicate Item
            const currentSessions = chatSessionsRef.current || {};
            const existingSession = (Object.values(currentSessions) as any[]).find((s: any) =>
                s.toolId === 'quick_notes' && s.messages && s.messages[0] && s.messages[0].content === text
            );

            if (existingSession) {
                // NEW: Update timestamp to move it to the top of the list
                const updatedSession = { ...existingSession, timestamp: new Date().toISOString(), lastOpened: new Date().toISOString() };

                if (persistSessionRef.current) {
                    await persistSessionRef.current(updatedSession);
                }
                if (showToastRef.current) showToastRef.current("Note Moved to Top");

                // Open it
                if (setActiveTabRef.current) setActiveTabRef.current('notes');
                if (loadHistorySessionRef.current) loadHistorySessionRef.current(updatedSession);
                return;
            }

            // 2. Create New Note if not found
            const id = generateId();
            const titleLine = text.split('\n')[0].substring(0, 50);
            const title = titleLine.trim() || defaultTitle;

            const newSession = {
                id: id,
                timestamp: new Date().toISOString(),
                lastOpened: new Date().toISOString(),
                messages: [{ role: "user", content: text }],
                title: title,
                toolId: "quick_notes",
                images: [],
                pinned: false
            };

            if (persistSessionRef.current) {
                await persistSessionRef.current(newSession);
            }

            if (setActiveTabRef.current) setActiveTabRef.current('notes');
            if (setAppModeRef.current) setAppModeRef.current('idle');

            if (loadHistorySessionRef.current) loadHistorySessionRef.current(newSession);
            if (showToastRef.current) showToastRef.current("File imported as Note");
        };

        // NEW: Extracted Import Execution Logic
        const handleImportExecution = async (content: any, json: any, isJsonValid: any) => {
            if (isJsonValid && json) {
                try {
                    // NEW: Handle Unified Export (Common for Share Note/Journal)
                    if (json.type === 'reader_unified_export' && Array.isArray(json.items)) {
                        // 1. CHECK FOR DICTIONARY SOURCE TAB
                        if (json.sourceTab === 'dictionary') {
                            const items = json.items;
                            if (setRecentSearchesRef.current && recentSearchesRef.current) {
                                const currentWords = recentSearchesRef.current;
                                const currentWordMap = new Map(currentWords.map(item => {
                                    const w = typeof item === 'string' ? item : item.word;
                                    return [w.toLowerCase(), true];
                                }));

                                const newItems = [...currentWords];
                                let addedCount = 0;
                                let skippedCount = 0;

                                items.forEach((item: any) => {
                                    let wordString = typeof item === 'string' ? item : item.word;
                                    let wordData = typeof item === 'object' ? (item.data || item) : null;

                                    if (wordString && !currentWordMap.has(wordString.toLowerCase())) {
                                        newItems.unshift({
                                            word: wordString,
                                            data: wordData || { word: wordString, definition: "Imported", timestamp: new Date().toISOString() }
                                        });
                                        currentWordMap.set(wordString.toLowerCase(), true);
                                        addedCount++;
                                    } else {
                                        skippedCount++;
                                    }
                                });

                                if (addedCount > 0) {
                                    // Use Orchestrator: Update Ref, File, and State
                                    await updateRecentSearchesOrchestrator(newItems, false);
                                }

                                if (setActiveTabRef.current) setActiveTabRef.current('dictionary');

                                Alert.alert("Import Complete", `â€¢ ${addedCount} Words added\nâ€¢ ${skippedCount} Skipped (Duplicate)`);
                            }
                            return; // EXIT if handled as dictionary
                        }

                        // 2. Handle Standard Sessions (Notes/Journals/Quizzes)
                        const items = json.items;
                        let importedCount = 0;
                        let openedItem = null;

                        const currentSessions = chatSessionsRef.current || {};

                        for (const item of items) {
                            // 1. Check by ID
                            let existing = currentSessions[item.id];

                            // 2. Check by Content if ID not found (prevent content duplicate)
                            if (!existing) {
                                const itemContent = item.content || (item.messages && item.messages[0]?.content);
                                if (itemContent) {
                                    existing = (Object.values(currentSessions) as any[]).find(s =>
                                        s.messages && s.messages[0] && s.messages[0].content.trim() === itemContent.trim()
                                    );
                                }
                            }

                            if (existing) {
                                // Found Existing: Update timestamp to bump to top
                                const updated = { ...existing, timestamp: new Date().toISOString() };

                                if (persistSessionRef.current) await persistSessionRef.current(updated);
                                openedItem = updated;
                            } else {
                                // New Item
                                if (!item.id) item.id = generateId();
                                item.timestamp = new Date().toISOString();

                                // NEW: Auto-Increment Attempt for Re-Imported Quizzes
                                if (item.toolId === 'quiz_save' && quizHistoryRef.current && quizHistoryRef.current[item.id]) {
                                    const history = quizHistoryRef.current[item.id];
                                    // If previous history exists, start at next attempt number
                                    if (history.attempts >= (item.attempts || 0)) {
                                        item.attempts = history.attempts + 1;
                                        // Reset state for the new attempt
                                        item.completed = false;
                                        item.score = 0;
                                        item.currentIndex = 0;
                                        if (Array.isArray(item.quizData)) {
                                            item.quizData = (item.quizData as any[]).map((q: any) => ({
                                                ...q,
                                                selected: null,
                                                markedForReview: false,
                                                visited: false
                                            }));
                                        }
                                    }
                                }

                                // Ensure content structure is valid for session
                                if (item.content && (!item.messages || item.messages.length === 0)) {
                                    item.messages = [{ role: 'user', content: item.content }];
                                }

                                if (persistSessionRef.current) await persistSessionRef.current(item);
                                importedCount++;
                                openedItem = item;
                            }
                        }

                        // If single item, open it immediately
                        if (items.length === 1 && openedItem && loadHistorySessionRef.current) {
                            if (showToastRef.current) showToastRef.current("Opened File");
                            // If it's a note, switch tab
                            if (openedItem.toolId === 'quick_notes' && setActiveTabRef.current) {
                                setActiveTabRef.current('notes');
                            }
                            // Load it
                            const origin = openedItem.toolId === 'quick_notes' ? 'idle' : 'reader';
                            loadHistorySessionRef.current(openedItem, origin);
                        } else {
                            if (importedCount > 0) {
                                Alert.alert("Import Complete", `Imported ${importedCount} new items.`);
                            } else {
                                if (showToastRef.current) showToastRef.current("File already exists");
                            }
                        }
                        return;
                    }

                    // CASE 1: FULL BACKUP (Object with 'type' or 'sessions')
                    if (json.type === "reader_backup_v2" || (json.sessions && json.dictionary)) {
                        Alert.alert(
                            "Restore Backup",
                            "Full backup file detected. Restore everything?",
                            [
                                { text: "Cancel", style: "cancel" },
                                {
                                    text: "Restore", onPress: async () => {
                                        let sessionRestored = 0;
                                        let sessionSkipped = 0;
                                        let wordsRestored = 0;
                                        let wordsSkipped = 0;

                                        // 1. Restore Sessions
                                        if (json.sessions && Array.isArray(json.sessions) && setChatSessionsRef.current) {
                                            const newSessionsMap: any = {};
                                            const storagePairs: [string, string][] = [];
                                            const indexJson = await AsyncStorage.getItem('session_index');
                                            let currentIndex = indexJson ? JSON.parse(indexJson) : [];

                                            const currentSessions = chatSessionsRef.current || {};

                                            (json.sessions as any[]).forEach((session: any) => {
                                                if (session.id) {
                                                    if ((currentSessions as any)[session.id]) {
                                                        sessionSkipped++;
                                                    } else {
                                                        (newSessionsMap as any)[session.id] = session;
                                                        storagePairs.push([`session_${session.id}`, JSON.stringify(session)]);
                                                        if (!currentIndex.includes(session.id)) currentIndex.push(session.id);
                                                        sessionRestored++;
                                                    }
                                                }
                                            });

                                            if (sessionRestored > 0) {
                                                setChatSessionsRef.current((prev: any) => ({ ...prev, ...newSessionsMap }));
                                                await AsyncStorage.multiSet(storagePairs);
                                                await AsyncStorage.setItem('session_index', JSON.stringify(currentIndex));
                                            }
                                        }

                                        // 2. Restore Dictionary
                                        if (json.dictionary && Array.isArray(json.dictionary) && setRecentSearchesRef.current) {
                                            const currentWords = recentSearchesRef.current || [];
                                            const currentWordMap = new Map(currentWords.map(item => {
                                                const w = typeof item === 'string' ? item : item.word;
                                                return [w.toLowerCase(), true];
                                            }));

                                            const newItems = [...currentWords];

                                            json.dictionary.forEach((item: any) => {
                                                let wordString = typeof item === 'string' ? item : item.word;
                                                let wordData = typeof item === 'object' ? (item.data || item) : null;

                                                if (wordString && !currentWordMap.has(wordString.toLowerCase())) {
                                                    newItems.unshift({
                                                        word: wordString,
                                                        data: wordData || { word: wordString, definition: "Imported", timestamp: new Date().toISOString() }
                                                    });
                                                    currentWordMap.set(wordString.toLowerCase(), true);
                                                    wordsRestored++;
                                                } else {
                                                    wordsSkipped++;
                                                }
                                            });

                                            if (wordsRestored > 0) {
                                                setRecentSearchesRef.current(newItems);
                                                await AsyncStorage.setItem('recentSearches', JSON.stringify(newItems));
                                            }
                                        }

                                        let msg = "Restore Complete.\n";
                                        if (sessionRestored > 0) msg += `\nâ€¢ ${sessionRestored} items restored`;
                                        if (sessionSkipped > 0) msg += `\nâ€¢ ${sessionSkipped} items skipped (Duplicate)`;
                                        if (wordsRestored > 0) msg += `\nâ€¢ ${wordsRestored} words restored`;
                                        if (wordsSkipped > 0) msg += `\nâ€¢ ${wordsSkipped} words skipped (Duplicate)`;

                                        if (sessionRestored === 0 && wordsRestored === 0) msg = "No new data found. All items already exist.";

                                        Alert.alert("Success", msg);
                                    }
                                }
                            ]
                        );
                        return;
                    }

                    // CASE 2: DICTIONARY BACKUP (Array of words)
                    const isDictionary = Array.isArray(json) && json.length > 0 &&
                        json.every(item => typeof item === 'string' || (item.word && !item.messages));

                    if (isDictionary) {
                        Alert.alert(
                            "Import Dictionary",
                            `Found ${json.length} words. Import to Recent Words Flashcards?`,
                            [
                                { text: "Cancel", style: "cancel" },
                                {
                                    text: "Import", onPress: async () => {
                                        if (setRecentSearchesRef.current && recentSearchesRef.current) {
                                            const currentWords = recentSearchesRef.current;
                                            const currentWordMap = new Map(currentWords.map(item => {
                                                const w = typeof item === 'string' ? item : item.word;
                                                return [w.toLowerCase(), true];
                                            }));

                                            const newItems = [...currentWords];
                                            let addedCount = 0;
                                            let skippedCount = 0;

                                            json.forEach(item => {
                                                let wordString = typeof item === 'string' ? item : item.word;
                                                let wordData = typeof item === 'object' ? (item.data || item) : null;

                                                if (wordString && !currentWordMap.has(wordString.toLowerCase())) {
                                                    newItems.unshift({
                                                        word: wordString,
                                                        data: wordData || { word: wordString, definition: "Imported", timestamp: new Date().toISOString() }
                                                    });
                                                    currentWordMap.set(wordString.toLowerCase(), true);
                                                    addedCount++;
                                                } else {
                                                    skippedCount++;
                                                }
                                            });

                                            if (addedCount > 0) {
                                                setRecentSearchesRef.current(newItems);
                                                await AsyncStorage.setItem('recentSearches', JSON.stringify(newItems));
                                            }

                                            if (setActiveTabRef.current) setActiveTabRef.current('dictionary');

                                            Alert.alert("Import Complete", `â€¢ ${addedCount} Words added\nâ€¢ ${skippedCount} Skipped (Duplicate)`);
                                        }
                                    }
                                }
                            ]
                        );
                        return;
                    }

                    // CASE 3: NOTES BACKUP (Array of sessions)
                    if (Array.isArray(json)) {
                        // Assume it's a list of sessions/notes
                        let importedCount = 0;
                        let skippedCount = 0;
                        const newSessionsMap: any = {};
                        const storagePairs: [string, string][] = [];
                        const indexJson = await AsyncStorage.getItem('session_index');
                        let currentIndex = indexJson ? JSON.parse(indexJson) : [];

                        const currentSessions = chatSessionsRef.current || {};

                        for (const item of json) {
                            if (item.id && item.toolId) {
                                if (currentSessions[item.id]) {
                                    skippedCount++;
                                } else {
                                    newSessionsMap[item.id] = item;
                                    storagePairs.push([`session_${item.id}`, JSON.stringify(item)]);
                                    if (!currentIndex.includes(item.id)) currentIndex.push(item.id);
                                    importedCount++;
                                }
                            }
                        }

                        if (importedCount > 0) {
                            await AsyncStorage.multiSet(storagePairs);
                            await AsyncStorage.setItem('session_index', JSON.stringify(currentIndex));

                            if (setChatSessionsRef.current) {
                                setChatSessionsRef.current((prev: any) => ({ ...prev, ...newSessionsMap }));
                            }
                        }

                        Alert.alert("Import Complete", `â€¢ ${importedCount} items imported\nâ€¢ ${skippedCount} Skipped (Duplicate)`);
                        return;
                    }

                    // Single Object Session
                    if (json.id && json.toolId) {
                        // Check for duplicate ID
                        const currentSessions = chatSessionsRef.current || {};
                        if (currentSessions[json.id]) {
                            // Duplicate ID found - bump timestamp to move to top
                            const updatedSession = { ...currentSessions[json.id], timestamp: new Date().toISOString() };
                            if (persistSessionRef.current) await persistSessionRef.current(updatedSession);

                            if (loadHistorySessionRef.current) loadHistorySessionRef.current(updatedSession);
                            if (showToastRef.current) showToastRef.current("Opened existing file");
                            return;
                        }

                        // NEW: Auto-Increment Attempt for Single Quiz Import
                        if (json.toolId === 'quiz_save') {
                            try {
                                const storedHistory = await AsyncStorage.getItem('quiz_history_tracking');
                                if (storedHistory) {
                                    const parsedHistory = JSON.parse(storedHistory);
                                    quizHistoryRef.current = { ...quizHistoryRef.current, ...parsedHistory };

                                    if (parsedHistory[json.id]) {
                                        const h = parsedHistory[json.id];

                                        // FORCE INCREMENT: Always start a fresh attempt count if history exists
                                        if (h.attempts >= (json.attempts || 0)) {
                                            json.attempts = h.attempts + 1;

                                            // RESET STATE: Clear previous results so it's a fresh run
                                            json.completed = false;
                                            json.score = 0;
                                            json.currentIndex = 0;
                                            json.totalTime = 0;
                                            if (Array.isArray(json.quizData)) {
                                                json.quizData = json.quizData.map((q: any) => ({
                                                    ...q,
                                                    selected: null,
                                                    markedForReview: false,
                                                    visited: false
                                                }));
                                            }

                                            if (showToastRef.current) showToastRef.current(`Starting Attempt #${json.attempts}`);
                                        }
                                    }
                                }
                            } catch (e: any) {
                                console.log("History check failed", e);
                            }
                        }

                        const newSession = { ...json, timestamp: new Date().toISOString() };
                        if (persistSessionRef.current) await persistSessionRef.current(newSession);
                        if (loadHistorySessionRef.current) loadHistorySessionRef.current(newSession);
                        if (showToastRef.current && !json.completed) showToastRef.current("Imported File");
                        return;
                    }

                } catch (e: any) {
                    // JSON Parse failed, treat as plain text note
                    await processContentAsNote(content, "Imported File");
                }
            } else {
                // Plain text
                await processContentAsNote(content, "Imported Note");
            }
        };

        const processUrl = async (url: any) => {
            if (!url) return;

            // Deduplicate: Allow same URL only after 2 seconds (fixes "Click again" issue)
            const now = Date.now();
            if (url === lastProcessedUrl.current && (now - lastProcessedTime.current) < 2000) {
                return;
            }
            lastProcessedUrl.current = url;
            lastProcessedTime.current = now;

            console.log("Incoming URL:", url);

            const isFile = url.startsWith('content://') || url.startsWith('file://') || url.includes('Received-File');

            if (isFile) {
                // RETRY SAFETY: If refs aren't ready (Cold Start), wait slightly and retry once
                if (!persistSessionRef.current || !chatSessionsRef.current) {
                    console.log("Refs not ready, waiting...");
                    await new Promise(r => setTimeout(r, 500));
                }

                if (showToastRef.current) showToastRef.current("Analyzing file...");

                try {
                    // 1. READ FILE FIRST
                    let content;
                    if (url.startsWith('content://')) {
                        try {
                            const tempUri = fs.cacheDirectory + 'temp_import_' + Date.now();
                            await fs.copyAsync({ from: url, to: tempUri });
                            content = await fs.readAsStringAsync(tempUri, { encoding: fs.EncodingType.UTF8 });
                            await fs.deleteAsync(tempUri, { idempotent: true });
                        } catch (e: any) {
                            console.warn("Copy-read failed, trying direct read", e);
                            const decodedUri = decodeURIComponent(url);
                            content = await fs.readAsStringAsync(decodedUri, { encoding: fs.EncodingType.UTF8 });
                        }
                    } else {
                        const decodedUri = decodeURIComponent(url);
                        content = await fs.readAsStringAsync(decodedUri, { encoding: fs.EncodingType.UTF8 });
                    }

                    if (!content) {
                        Alert.alert("Import Error", "File appears to be empty.");
                        return;
                    }

                    // 2. ANALYZE CONTENT
                    let fileSummary = "Unknown File Type";
                    let parsedJson = null;
                    let isJson = false;

                    const trimmed = content.trim();

                    if ((trimmed.startsWith('[') || trimmed.startsWith('{')) && trimmed.length > 2) {
                        try {
                            parsedJson = JSON.parse(trimmed);
                            isJson = true;

                            if (parsedJson.type === 'reader_unified_export') {
                                const count = Array.isArray(parsedJson.items) ? parsedJson.items.length : 0;
                                const source = parsedJson.sourceTab ? parsedJson.sourceTab.toUpperCase() : 'BUNDLE';
                                fileSummary = `Type: ${source} EXPORT\nItems: ${count}`;
                            } else if (parsedJson.type === 'reader_backup_v2' || (parsedJson.sessions && parsedJson.dictionary)) {
                                const sCount = parsedJson.sessions?.length || 0;
                                const dCount = parsedJson.dictionary?.length || 0;
                                const aCount = parsedJson.audio?.length || 0;
                                fileSummary = `Type: FULL BACKUP\nSessions: ${sCount}\nWords: ${dCount}\nAudio Files: ${aCount}`;
                            } else if (Array.isArray(parsedJson)) {
                                // Heuristic
                                const isDictionary = parsedJson.length > 0 && parsedJson.every(item => typeof item === 'string' || (item.word && !item.messages));
                                if (isDictionary) {
                                    fileSummary = `Type: DICTIONARY LIST\nWords: ${parsedJson.length}`;
                                } else {
                                    fileSummary = `Type: NOTES BUNDLE\nItems: ${parsedJson.length}`;
                                }
                            } else if (parsedJson.id && parsedJson.toolId) {
                                let typeName = "SESSION";
                                if (parsedJson.toolId === 'quiz_save') typeName = "QUIZ";
                                else if (parsedJson.toolId === 'story_generator') typeName = "STORY";
                                else if (parsedJson.toolId === 'quick_notes') typeName = "NOTE";

                                fileSummary = `Type: SINGLE ${typeName}\nTitle: ${parsedJson.title || 'Untitled'}`;
                            } else {
                                fileSummary = "Type: UNKNOWN JSON";
                            }
                        } catch (e: any) {
                            // JSON Parse failed, fallback to text
                            fileSummary = `Type: TEXT CONTENT\nSize: ${(content.length / 1024).toFixed(1)} KB`;
                            isJson = false;
                        }
                    } else {
                        fileSummary = `Type: PLAIN TEXT\nSize: ${(content.length / 1024).toFixed(1)} KB`;
                    }

                    // 3. CONFIRMATION ALERT
                    Alert.alert(
                        "Import File Details",
                        `${fileSummary}\n\nDo you want to import this content?`,
                        [
                            { text: "Cancel", style: "cancel" },
                            {
                                text: "Import",
                                onPress: async () => {
                                    // 4. PROCESS IMPORT
                                    await handleImportExecution(content, parsedJson, isJson);
                                }
                            }
                        ]
                    );

                } catch (e: any) {
                    console.error("Deep Link Read Error", e);
                    if (!url.includes('exp://')) {
                        Alert.alert("Import Failed", "Could not read file. Permissions may be restricted.");
                    }
                }
            }
        };

        // 1. Check Initial URL (Cold Start)
        Linking.getInitialURL().then(url => {
            if (url) processUrl(url);
        });

        // 2. Listen for updates (Warm Start)
        const subscription = Linking.addEventListener('url', (event: { url: string }) => {
            processUrl(event.url);
        });

        return () => {
            subscription.remove();
        };
    }, []);

    const [isHighlightMode, setIsHighlightMode] = useState(false);
    const [activeHighlightColor, setActiveHighlightColor] = useState('yellow');
    const activeHighlightColorRef = useRef('yellow');
    useEffect(() => { activeHighlightColorRef.current = activeHighlightColor; }, [activeHighlightColor]);

    const { width: windowWidth, height: windowHeight } = useWindowDimensions();
    const isLandscape = windowWidth > windowHeight;
    const [isReaderSearchExpanded, setIsReaderSearchExpanded] = useState(false);
    const [isLocalSearchMode, setIsLocalSearchMode] = useState(false); // NEW: Missing state for Reader Sidebar


    // --- UPDATED: UI TRANSLATION STATE WITH STATIC TEXT ---
    const [dynamicAssistantPrompts, setDynamicAssistantPrompts] = useState<any[] | null>(null);
    const [debouncedProfession, setDebouncedProfession] = useState((displaySettings as any).userProfession);
    const [uiData, setUiData] = useState<any>({
        tools: SCHOOL_TOOLS,
        toolPrompts: TOOL_QUICK_PROMPTS,
        subjectPrompts: SUBJECT_QUICK_PROMPTS,
        visionActions: VISION_QUICK_ACTIONS,
        documentActions: DOCUMENT_QUICK_ACTIONS,
        quizVisionActions: QUIZ_VISION_QUICK_ACTIONS,
        quizDocumentActions: QUIZ_DOCUMENT_QUICK_ACTIONS,
        storyVisionActions: STORY_VISION_QUICK_ACTIONS,
        storyDocumentActions: STORY_DOCUMENT_QUICK_ACTIONS,
        searchVisionActions: SEARCH_VISION_QUICK_ACTIONS,
        searchDocumentActions: SEARCH_DOCUMENT_QUICK_ACTIONS,
        writerVisionActions: WRITER_VISION_QUICK_ACTIONS,
        writerDocumentActions: WRITER_DOCUMENT_QUICK_ACTIONS,
        doctorVisionActions: DOCTOR_VISION_QUICK_ACTIONS,
        doctorDocumentActions: DOCTOR_DOCUMENT_QUICK_ACTIONS,
        emailVisionActions: EMAIL_VISION_QUICK_ACTIONS,
        organizerVisionActions: ORGANIZER_VISION_QUICK_ACTIONS,
        greetingsVisionActions: GREETINGS_VISION_QUICK_ACTIONS,
        editorialVisionActions: EDITORIAL_VISION_QUICK_ACTIONS,
        wordHelpVisionActions: WORD_HELP_VISION_QUICK_ACTIONS,
        customRoleVisionActions: CUSTOM_ROLE_VISION_QUICK_ACTIONS,
        mathVisionActions: MATH_VISION_QUICK_ACTIONS,
        // ADDED: Static Text Object
        staticText: STATIC_TEXT
    });

    const [uiCache, setUiCache] = useState<any>({ "English": uiData });

    // NEW: Load UI Cache from Storage on mount
    useEffect(() => {
        const loadUiCache = async () => {
            try {
                const stored = await AsyncStorage.getItem('ui_translations_cache');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    // Merge stored cache but ensure English is always the latest from code constants
                    setUiCache((prev: any) => ({ ...prev, ...parsed, "English": prev["English"] }));
                }
            } catch (e) { console.log("Cache load error", e); }
        };
        loadUiCache();
    }, []);

    // ... (getAllTools helper) ...
    const getAllTools = () => {
        return [...uiData.tools, ...customTools];
    };

    // --- UPDATED UI TRANSLATION LOGIC ---
    useEffect(() => {
        const translateUi = async () => {
            const targetLang = displaySettings.language;
            const isEnglish = targetLang === 'English';
            const key = customApiKey || apiKey;
            const keepLabels = displaySettings.keepLabelsEnglish;

            // Unique cache key based on language AND label preference
            const cacheKey = `${targetLang}_${keepLabels}`;

            if (isEnglish) {
                // Reset to base English data
                setUiData((prev: any) => ({ ...prev, ...(uiCache as any)["English"] }));
                return;
            }

            if ((uiCache as any)[cacheKey]) {
                // FIX: Rehydrate icons lost during JSON serialization (Storage)
                // When loading from AsyncStorage, React Components (Icons) are lost. We must restore them.
                const cachedData = (uiCache as any)[cacheKey];

                const rehydratedTools = cachedData.tools.map((t: any) => {
                    // Find original tool definition to restore the Icon component
                    const original = SCHOOL_TOOLS.find(st => st.id === t.id);
                    return {
                        ...t,
                        Icon: original ? original.Icon : t.Icon // Restore the component function
                    };
                });

                setUiData({ ...cachedData, tools: rehydratedTools });
                return;
            }

            // OPTIMIZATION: Synthesize Partial Translation (Keep English Labels) from Full Translation if available
            if (keepLabels && (uiCache as any)[`${targetLang}_false`]) {
                const fullData = (uiCache as any)[`${targetLang}_false`];
                const engData = (uiCache as any)["English"];

                // Helper to merge arrays preserving English structure/labels but using Translated prompts
                const mergeList = (engList: any, transList: any) => {
                    if (!engList) return [];
                    if (!transList) return engList;
                    return engList.map((engItem: any, i: number) => {
                        const transItem = transList[i] || {};
                        return {
                            ...engItem, // Keep English labels/titles/structure
                            prompt: transItem.prompt || engItem.prompt, // Use Translated Prompt
                            placeholder: transItem.placeholder || engItem.placeholder, // Use Translated Placeholder
                        };
                    });
                };

                // Helper for Object of Arrays (toolPrompts, subjectPrompts) - Recursive for greetings_gen
                const mergeObjLists = (engObj: any, transObj: any) => {
                    if (!engObj) return {};
                    const result = { ...engObj };
                    Object.keys(result).forEach(key => {
                        if (Array.isArray(engObj[key])) {
                            result[key] = mergeList(engObj[key], transObj?.[key]);
                        } else if (typeof engObj[key] === 'object' && engObj[key] !== null) {
                            result[key] = mergeObjLists(engObj[key], transObj?.[key]);
                        }
                    });
                    return result;
                };

                const synthesizedData = {
                    ...engData, // Start with English base (Labels, Static Text)
                    tools: mergeList(engData.tools, fullData.tools).map((t: any) => {
                        // Ensure Icons are correct (engData has them, but safety check)
                        const original = SCHOOL_TOOLS.find(st => st.id === t.id);
                        return { ...t, Icon: original ? original.Icon : t.Icon };
                    }),
                    toolPrompts: mergeObjLists(engData.toolPrompts, fullData.toolPrompts),
                    subjectPrompts: mergeObjLists(engData.subjectPrompts, fullData.subjectPrompts),

                    // Action Lists (Merged)
                    visionActions: mergeList(engData.visionActions, fullData.visionActions),
                    documentActions: mergeList(engData.documentActions, fullData.documentActions),
                    quizVisionActions: mergeList(engData.quizVisionActions, fullData.quizVisionActions),
                    quizDocumentActions: mergeList(engData.quizDocumentActions, fullData.quizDocumentActions),
                    storyVisionActions: mergeList(engData.storyVisionActions, fullData.storyVisionActions),
                    storyDocumentActions: mergeList(engData.storyDocumentActions, fullData.storyDocumentActions),
                    searchVisionActions: mergeList(engData.searchVisionActions, fullData.searchVisionActions),
                    searchDocumentActions: mergeList(engData.searchDocumentActions, fullData.searchDocumentActions),

                    customRoleVisionActions: mergeList(engData.customRoleVisionActions, fullData.customRoleVisionActions),
                    mathVisionActions: mergeList(engData.mathVisionActions, fullData.mathVisionActions),

                    staticText: engData.staticText // Keep English static text
                };

                // Cache and Set
                setUiCache((prev: any) => {
                    const updated = { ...prev, [cacheKey]: synthesizedData };
                    AsyncStorage.setItem('ui_translations_cache', JSON.stringify(updated));
                    return updated;
                });
                setUiData(synthesizedData);
                return;
            }

            if (!key) return;

            const payloadStaticText = keepLabels ? {} : STATIC_TEXT;

            const textPayload = {
                tools: SCHOOL_TOOLS.map(t => ({
                    title: t.title,
                    prompt: t.prompt,
                    placeholder: t.placeholder,
                    actionLabel: t.actionLabel
                })),
                toolPrompts: TOOL_QUICK_PROMPTS,
                subjectPrompts: SUBJECT_QUICK_PROMPTS,
                // ... all action lists ...
                visionActions: VISION_QUICK_ACTIONS,
                documentActions: DOCUMENT_QUICK_ACTIONS,
                quizVisionActions: QUIZ_VISION_QUICK_ACTIONS,
                quizDocumentActions: QUIZ_DOCUMENT_QUICK_ACTIONS,
                storyVisionActions: STORY_VISION_QUICK_ACTIONS,
                storyDocumentActions: STORY_DOCUMENT_QUICK_ACTIONS,
                searchVisionActions: SEARCH_VISION_QUICK_ACTIONS,
                searchDocumentActions: SEARCH_DOCUMENT_QUICK_ACTIONS,
                writerVisionActions: WRITER_VISION_QUICK_ACTIONS,
                writerDocumentActions: WRITER_DOCUMENT_QUICK_ACTIONS,
                doctorVisionActions: DOCTOR_VISION_QUICK_ACTIONS,
                doctorDocumentActions: DOCTOR_DOCUMENT_QUICK_ACTIONS,
                emailVisionActions: EMAIL_VISION_QUICK_ACTIONS,
                organizerVisionActions: ORGANIZER_VISION_QUICK_ACTIONS,
                greetingsVisionActions: GREETINGS_VISION_QUICK_ACTIONS,
                editorialVisionActions: EDITORIAL_VISION_QUICK_ACTIONS,
                wordHelpVisionActions: WORD_HELP_VISION_QUICK_ACTIONS,
                customRoleVisionActions: CUSTOM_ROLE_VISION_QUICK_ACTIONS,
                mathVisionActions: MATH_VISION_QUICK_ACTIONS,
                staticText: payloadStaticText
            };

            try {
                const translationRule = keepLabels
                    ? `CRITICAL INSTRUCTION FOR PARTIAL TRANSLATION:
                   - Field "prompt": TRANSLATE value to ${targetLang}.
                   - Field "placeholder": TRANSLATE value to ${targetLang}.
                   - Field "label": DO NOT TRANSLATE. KEEP IN ENGLISH.
                   - Field "title": DO NOT TRANSLATE. KEEP IN ENGLISH.
                   - Field "actionLabel": DO NOT TRANSLATE. KEEP IN ENGLISH.
                   - Field "description": DO NOT TRANSLATE. KEEP IN ENGLISH.
                   
                   Example for Quick Prompt:
                   Input: { "label": "Summarize", "prompt": "Summarize this text." }
                   Output: { "label": "Summarize", "prompt": "[Translated prompt in ${targetLang}]" }`
                    : `TRANSLATE ALL VALUES (title, label, prompt, placeholder, actionLabel, description, and staticText content) to ${targetLang}.`;

                const prompt = `
              Task: Transform the JSON object for an App Interface.
              Target Language: ${targetLang}.
              
              RULES:
              1. Preserve the exact JSON structure and keys.
              2. ${translationRule}
              3. Do NOT translate "id", "role", "type", "color", "iconName" or keys of the objects.
              4. Return VALID JSON only.
              
              JSON:
              ${JSON.stringify(textPayload)}
              `;

                const raw = await callLLM(prompt, "System Translator", true, "gemini-2.5-flash-lite");

                if (!raw || raw.startsWith("Error")) {
                    console.warn("UI Translation failed:", raw);
                    return;
                }

                const clean = extractJSON(raw);
                const translatedText = JSON.parse(clean);

                const mergedTools = SCHOOL_TOOLS.map((tool, index) => ({
                    ...tool,
                    ...translatedText.tools[index],
                    Icon: tool.Icon
                }));

                // FIX: Ensure staticText is never undefined. Fallback to STATIC_TEXT if translation missing.
                const finalStaticText = (keepLabels || !translatedText.staticText) ? STATIC_TEXT : translatedText.staticText;

                const newUiData = {
                    ...uiData,
                    ...translatedText,
                    tools: mergedTools,
                    staticText: finalStaticText
                };

                // Cache and Set
                setUiCache((prev: any) => {
                    const updated = { ...prev, [cacheKey]: newUiData };
                    AsyncStorage.setItem('ui_translations_cache', JSON.stringify(updated));
                    return updated;
                });
                setUiData(newUiData);
            } catch (e) {
                console.warn("UI Translation failed", e);
            }
        };

        translateUi();
    }, [displaySettings.language, displaySettings.keepLabelsEnglish]);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedProfession((displaySettings as any).userProfession);
        }, 800);
        return () => clearTimeout(handler);
    }, [(displaySettings as any).userProfession]);

    // NEW: Dynamic Quick Ideas for Personal Assistant based on Profession (Debounced)
    useEffect(() => {
        const updatePersonalAssistantPrompts = async () => {
            // Revert to default if no profession set
            if (!debouncedProfession) {
                setDynamicAssistantPrompts(null);
                return;
            }

            const profession = debouncedProfession;
            const prompt = `Act as a Creative Assistant.
            User Profession: "${profession}"
            
            Generate 6 relevant "Quick Ideas" (prompts) that this user would find useful to ask their Personal Assistant AI.
            
            Return strictly a JSON Array of objects with keys:
            - "label": Short title (max 15 chars)
            - "prompt": Full prompt text for the user to send.
            
            Example: [{"label": "Summarize News", "prompt": "Summarize the latest industry news..."}]
            
            Output VALID JSON ONLY.`;

            try {
                // Background generation - no loading state to avoid disruption
                const raw = await callLLM(prompt, "System", true);
                const clean = extractJSON(raw);
                const parsed = JSON.parse(clean);

                if (Array.isArray(parsed) && parsed.length > 0) {
                    const newPrompts = parsed.slice(0, 8); // Safety limit
                    setDynamicAssistantPrompts(newPrompts);
                }
            } catch (e) {
                console.log("Failed to generate dynamic prompts for profession", e);
            }
        };

        // Run on debounced profession change
        updatePersonalAssistantPrompts();

    }, [debouncedProfession]);

    const [activeModelId, setActiveModelId] = useState<any>(null);

    const loadWordFromFile = async (liteWord: any) => {
        if (!liteWord || !liteWord.id) return liteWord;
        if (liteWord.simple || liteWord.advanced) return liteWord;
        try {
            const docDir = fs.documentDirectory || FileSystem.documentDirectory;
            const fileName = `word_${liteWord.id}.json`;
            const fileUri = docDir + fileName;
            const info = await fs.getInfoAsync(fileUri);
            if (info.exists) {
                const content = await fs.readAsStringAsync(fileUri);
                const fullData = JSON.parse(content);
                return { ...fullData, id: liteWord.id, timestamp: liteWord.timestamp };
            }
        } catch (e) { }
        return liteWord;
    };

    const [availableSubjectsInitial, setAvailableSubjectsInitial] = useState(['Art', 'Basic Computer', 'Biology', 'Chemistry', 'Computer Science', 'English', 'General', 'Geography', 'History', 'Literature', 'Machine Learning', 'Mathematics', 'Physics', 'Reasoning', 'Science']);

    // Use effect to initialize availableSubjects if empty
    useEffect(() => {
        if (availableSubjects.length === 0) {
            setAvailableSubjects(availableSubjectsInitial);
        }
    }, []);

    // Check for other potential duplicates or just remove if they are strictly duplicates.
    // Actually, looking at the previous file view, these look like they might be duplicates of state declared way above.
    // Let's safe delete the duplicates but keep the initial value logic if needed.
    // Since I can't see the top of the file easily, I'll assume the top declarations are the "real" ones.
    // However, the top declaration of availableSubjects was empty.
    // I will modify the top declaration to have these values and delete this block.

    const [voiceTarget, setVoiceTarget] = useState('search');
    const [activeNoteField, setActiveNoteField] = useState('body');
    const [activePromptField, setActivePromptField] = useState('prompt');
    const [activeRoleField, setActiveRoleField] = useState('instructions');

    const recordingOpacity = useRef(new Animated.Value(1)).current;
    const [undoStack, setUndoStack] = useState<string[]>([]);
    const [redoStack, setRedoStack] = useState<string[]>([]);
    const historyTimeout = useRef<any>(null);
    const lastHistoryState = useRef("");

    const resetHistory = (initialContent = "") => {
        setUndoStack([]);
        setRedoStack([]);
        lastHistoryState.current = initialContent;
    };

    const handleNoteInputChange = (text: any) => {
        setCurrentNoteInput(text);
        if (historyTimeout.current) clearTimeout(historyTimeout.current);
        historyTimeout.current = setTimeout(() => {
            if (text !== lastHistoryState.current) {
                setUndoStack((prev: any[]) => [...prev, lastHistoryState.current]);
                setRedoStack([]);
                lastHistoryState.current = text;
            }
        }, 700);
    };

    const pushToHistoryImmediate = () => {
        setUndoStack((prev: any[]) => [...prev, currentNoteInput]);
        setRedoStack([]);
    };

    const handleUndo = () => {
        if (undoStack.length === 0) return;
        const prev = undoStack[undoStack.length - 1];
        const newUndo = undoStack.slice(0, -1);
        setRedoStack((prevRedo: any[]) => [...prevRedo, currentNoteInput]);
        setUndoStack(newUndo);
        setCurrentNoteInput(prev);
        lastHistoryState.current = prev;
    };

    const handleRedo = () => {
        if (redoStack.length === 0) return;
        const next = redoStack[redoStack.length - 1];
        const newRedo = redoStack.slice(0, -1);
        setUndoStack((prevUndo: any[]) => [...prevUndo, currentNoteInput]);
        setRedoStack(newRedo);
        setCurrentNoteInput(next);
        lastHistoryState.current = next;
    };

    // NEW: Sync Refs for Deep Link Handler and Auto-Submit
    useEffect(() => { setRecentSearchesRef.current = setRecentSearches; }, [setRecentSearches]);

    // SANITIZATION: Check for corrupt "Objects as React Child" data in recent searches on startup
    // --- NEW: FILE-BASED STORAGE HELPERS (Unlimited Size) ---
    const getRecentSearchesPath = () => `${FileSystem.documentDirectory}recent_searches.json`;

    const saveRecentSearchesToFile = async (data: any) => {
        try {
            await FileSystem.writeAsStringAsync(getRecentSearchesPath(), JSON.stringify(data), { encoding: 'utf8' });
        } catch (e) {
            console.error("Failed to save dictionary to file", e);
        }
    };

    const loadRecentSearchesFromFile = async () => {
        try {
            const path = getRecentSearchesPath();
            // REFACTOR: getInfoAsync is deprecated. Attempt read directly.
            const content = await FileSystem.readAsStringAsync(path, { encoding: 'utf8' });
            return JSON.parse(content);
        } catch (e) {
            // File doesn't exist or read failed. Return null to trigger migration check.
            return null;
        }
    };

    // SANITIZATION: Check for corrupt "Objects as React Child" data in recent searches on startup
    // UPDATED: Handles migration from AsyncStorage -> FileSystem
    useEffect(() => {
        const sanitizeRecentSearches = async () => {
            try {
                // 1. Try Load from File (Primary)
                let loadedData = await loadRecentSearchesFromFile();
                let isMigration = false;

                // 2. If no file, try Migration from Storage
                if (loadedData === null) {
                    let stored = null;
                    try {
                        stored = await AsyncStorage.getItem('recentSearches');
                    } catch (e: any) {
                        console.error("AsyncStorage READ ERROR (Row too big?). Clearing corrupted data.", e);
                        await AsyncStorage.removeItem('recentSearches').catch(() => { });
                        stored = null;
                    }

                    if (stored) {
                        try {
                            loadedData = JSON.parse(stored);
                            isMigration = true;
                        } catch (e: any) {
                            console.warn("Corrupt AsyncStorage data found during migration.");
                            loadedData = [];
                        }
                    } else {
                        loadedData = [];
                    }
                }

                if (Array.isArray(loadedData)) {
                    let hasChanges = isMigration; // Force save if migrating
                    const sanitized = (loadedData as any[]).map((item: any) => {
                        // Fix: Ensure 'word' is a string. If it's an object, extract the string or drop it.
                        if (item && typeof item.word === 'object') {
                            hasChanges = true;
                            // Attempt to recover if it has a 'word' property inside
                            if (item.word.word && typeof item.word.word === 'string') {
                                return { ...item, word: item.word.word };
                            }
                            return null; // Drop corrupt item
                        }
                        return item;
                    }).filter(item => item !== null);

                    if (hasChanges) {
                        console.log("Sanitized/Migrated recentSearches, saving to FILE.");
                        await updateRecentSearchesOrchestrator(sanitized, false);
                        if (isMigration) {
                            // Clean up old storage after successful migration
                            AsyncStorage.removeItem('recentSearches').catch(() => { });
                        }
                    } else {
                        setRecentSearches(sanitized);
                    }
                }
            } catch (e: any) {
                console.warn("Error sanitizing recent searches", e);
                // RECOVERY: If storage is corrupt (CursorWindow error), clear it to allow app to start
                if (e.message && (e.message.includes("CursorWindow") || e.message.includes("Row too big"))) {
                    console.error("Critical Storage Error detected. clearing recentSearches...");
                    // Try to clear file too if it exists and is corrupt
                    try { await FileSystem.deleteAsync(getRecentSearchesPath(), { idempotent: true }); } catch (fe) { }
                    await AsyncStorage.removeItem('recentSearches');
                    setRecentSearches([]);
                    recentSearchesRef.current = []; // Fix: Sync ref on crash clear
                }
            }
        };
        sanitizeRecentSearches();
    }, []);
    useEffect(() => { recentSearchesRef.current = recentSearches; }, [recentSearches]);
    useEffect(() => { setChatSessionsRef.current = setChatSessions; }, [chatSessions]);

    // NEW: Sync refs for background handling
    useEffect(() => { chatSessionsRef.current = chatSessions; }, [chatSessions]);
    useEffect(() => { quizStateRef.current = quizState; }, [quizState]);
    useEffect(() => { quizSecondsElapsedRef.current = quizSecondsElapsed; }, [quizSecondsElapsed]);

    useEffect(() => {
        if (isRecording) {
            Animated.loop(
                Animated.sequence([
                    Animated.timing(recordingOpacity, { toValue: 0.2, duration: 800, useNativeDriver: true }),
                    Animated.timing(recordingOpacity, { toValue: 1, duration: 800, useNativeDriver: true }),
                ])
            ).start();
        } else {
            recordingOpacity.stopAnimation();
            recordingOpacity.setValue(1);
        }
    }, [isRecording]);

    // NEW: Effect to handle auto-progression for Stories and Audio Tracks
    useEffect(() => {
        if (ttsFinishedNaturally > 0 && readingSession) {
            // 1. LIBRARY AUDIO TAB PROGRESSION
            // Check if we are playing an orphan file (Library Audio)
            if (playingMeta?.id && playingMeta.id.startsWith('orphan_')) {
                const originalId = playingMeta.id.replace('orphan_', '');
                handleAudioTrackFinished(originalId);
                setTtsFinishedNaturally(0);
                return;
            }

            // 2. STORY PROGRESSION LOGIC
            // If we are in a story and it has a linked next chapter, load it
            if (readingSession.nextChapterId && chatSessions[readingSession.nextChapterId]) {
                const nextSession = chatSessions[readingSession.nextChapterId];
                // Small delay to allow user to process the end of the chapter
                setTimeout(() => {
                    showToast("Opening next chapter...");
                    autoPlayRef.current = true; // Signal auto-play for the next session
                    loadHistorySession(nextSession, 'reader');
                }, 1500);
                setTtsFinishedNaturally(0);
                return;
            }

            setTtsFinishedNaturally(0);
        }
    }, [ttsFinishedNaturally]);

    const [isExportingAudio, setIsExportingAudio] = useState(false);
    const [ttsDownloadProgress, setTtsDownloadProgress] = useState(0);
    const [isOnlinePlayback, setIsOnlinePlayback] = useState(false);
    const [audioProgress, setAudioProgress] = useState({ position: 0, duration: 1 });
    const isAudioPlaylistActive = useRef(false);
    const audioPlaylistDirection = useRef('up');
    const audioSessionHistory = useRef(new Set<any>());
    const speechState = useRef<any>({ chunks: [], index: 0, offsets: [], isActive: false, isPaused: false, resumeOffsetInChunk: 0, baseOffset: 0, id: 0, title: "", pendingDownloads: new Set() });
    const speechSessionId = useRef(0);
    const audioPlaybackId = useRef(0); // NEW: Track audio file playback sessions to prevent overlap
    const currentSound = useRef<any>(null);
    const onlineTTSBroken = useRef(false);
    const [showAppearance, setShowAppearance] = useState(false);
    const [showHistory, setShowHistory] = useState(false);
    const [libraryTab, setLibraryTab] = useState("chats");
    const [showWordModal, setShowWordModal] = useState(false);
    const [showImageSourceModal, setShowImageSourceModal] = useState(false);
    const [showVisionDraft, setShowVisionDraft] = useState(false);
    const [toastMessage, setToastMessage] = useState<any>(null);
    const [visionDraft, setVisionDraft] = useState<any>({ uris: [], prompt: "" });
    const [customVisionPrompts, setCustomVisionPrompts] = useState<any[]>([]);
    const [customSubjectPrompts, setCustomSubjectPrompts] = useState<any>({});
    const [customToolPrompts, setCustomToolPrompts] = useState<any>({});
    const [customTools, setCustomTools] = useState<any[]>([]);
    const [showRoleCreator, setShowRoleCreator] = useState(false);
    const [isDictionaryExpanded, setIsDictionaryExpanded] = useState(false);
    const [visibleWordCount, setVisibleWordCount] = useState(25);
    const [newRoleData, setNewRoleData] = useState({ title: "", instructions: "", icon: "Bot" });
    const [showPromptCreator, setShowPromptCreator] = useState(false);
    const [newPromptData, setNewPromptData] = useState({ label: "", prompt: "" });



    // Pagination Removed: visibleLibraryCount reset logic deleted.


    const [selectedNoteIds, setSelectedNoteIds] = useState<string[]>([]);
    const [isSelectionMode, setIsSelectionMode] = useState(false);
    const [selectedLibraryIds, setSelectedLibraryIds] = useState<string[]>([]);
    const [isLibrarySelectionMode, setIsLibrarySelectionMode] = useState(false);
    const [homeToolIds, setHomeToolIds] = useState<any[]>([]);

    const [lastUsedTools, setLastUsedTools] = useState<any[]>([]); // NEW: MRU Sorting State

    // NEW: Load Last Used Tools
    useEffect(() => {
        try {
            AsyncStorage.getItem('lastUsedTools').then(data => {
                if (data) {
                    setLastUsedTools(JSON.parse(data));
                }
            });
        } catch (e) { }
    }, []);

    // NEW: Save Last Used Tools
    useEffect(() => {
        if (lastUsedTools.length > 0) {
            AsyncStorage.setItem('lastUsedTools', JSON.stringify(lastUsedTools)).catch(e => { });
        }
    }, [lastUsedTools]);

    // NEW: Persistence for Saved Questions (Flashcards)
    // Load on mount
    useEffect(() => {
        const loadSavedQuestions = async () => {
            try {
                const stored = await AsyncStorage.getItem('savedQuestions');
                if (stored) {
                    setSavedQuestions(JSON.parse(stored));
                }
            } catch (e) {
                console.log("Failed to load saved questions", e);
            }
        };
        loadSavedQuestions();

        const subscription = DeviceEventEmitter.addListener('refreshFlashcards', loadSavedQuestions);
        return () => subscription.remove();
    }, []);

    // Save on change
    useEffect(() => {
        const saveSavedQuestions = async () => {
            // Only save if we have data or if we want to support clearing (careful with initial empty state)
            // To be safe against overwriting with empty initial state before load, we could add a loaded flag,
            // but here we just check if it's not empty, or simple logic.
            // Actually, simplest is to just save. But if initial load is async and state is [], we might overwrite.
            // However, checking a "isLoaded" flag is better.
            // For now, let's assume standard pattern.
            if (savedQuestions.length > 0) {
                AsyncStorage.setItem('savedQuestions', JSON.stringify(savedQuestions)).catch(e => { });
            }
        };
        saveSavedQuestions();
    }, [savedQuestions]);

    const [expandedTableData, setExpandedTableData] = useState<any>(null);
    const [storyMode, setStoryMode] = useState('narrator');
    const [teacherMode, setTeacherMode] = useState('lesson'); // RESTORED
    const [expandedStoryGroups, setExpandedStoryGroups] = useState<any>({}); // NEW: State for expanding/collapsing story groups
    const [expandedAudioGroups, setExpandedAudioGroups] = useState<any>({}); // NEW: State for expanding/collapsing audio groups
    // FIXED: Added missing state for Journal Groups
    const [expandedJournalGroups, setExpandedJournalGroups] = useState<any>({});

    const [showResetWarning, setShowResetWarning] = useState(false);
    const [showUnsavedChangesModal, setShowUnsavedChangesModal] = useState(false);
    const [bookParams, setBookParams] = useState({ title: "", chapter: "", description: "", genre: "Mythology" }); // UPDATED: Added description
    const [storyQuery, setStoryQuery] = useState(""); // NEW: Unified story generator input
    const [storyTabMode, setStoryTabMode] = useState('story'); // 'story' or 'editorial'
    const [editorialParams, setEditorialParams] = useState({ topic: "", stance: "Balanced", tone: "Professional", length: "Medium" });

    // --- MISSING HANDLERS & STATE ---
    const [quizTopics, setQuizTopics] = useState<string[]>([]);

    useEffect(() => {
        AsyncStorage.getItem('quizTopics').then(data => {
            if (data) {
                try { setQuizTopics(JSON.parse(data)); } catch (e) { }
            }
        });
    }, []);

    // --- MISSING HANDLERS & STATE ---
    // (Consolidated into existing logic below)


    // NEW: Handle Editorial Generation
    // NEW: Random Editorial Topic Generator



    // Shared Helper for Saving Editorial Session
    const saveEditorialSession = async (title: string, content: string) => {
        const newSession = {
            id: generateId(),
            title: title,
            messages: [{ role: 'model', content: content }],
            timestamp: new Date().toISOString(),
            lastOpened: new Date().toISOString(),
            toolId: 'editorial_writer',
            pinned: false,
            voice: displaySettings.voice,
            hasAudio: false
        };

        setChatSessions((prev: any) => ({ ...prev, [newSession.id]: newSession }));

        if (persistSessionRef.current) {
            await persistSessionRef.current(newSession);
        }

        setReadingSession(newSession);
        setGenerationData(null);
        setAppMode('reader');
    };

    const handleGenerateEditorial = async () => {
        const topic = editorialParams.topic.trim();

        const key = customApiKey || apiKey;
        if (!key) {
            Alert.alert("API Key Required", "Please add your Gemini API Key in Settings.");
            return;
        }

        setAppMode("generating");
        setGenerationData(topic ? `Writing Editorial: ${topic}...` : "Brainstorming & Writing Editorial...");

        try {
            let prompt = "";
            let systemRole = "Professional Author";

            if (!topic) {
                // INTEGRATED BRAINSTORMING + GENERATION
                const existingTopics = Object.values(chatSessions)
                    .filter((s: any) => s.toolId === 'editorial_writer')
                    .map((s: any) => s.title)
                    .slice(0, 30)
                    .join(", ");

                prompt = `
                Task: 
                1. Brainstorm ONE unique, controversial, or thought-provoking editorial topic. (Constraint: Must NOT be similar to: [${existingTopics}]).
                2. Act as a senior Editor-in-Chief. Write a comprehensive ${editorialParams.length} editorial piece on that topic immediately.

                Key Requirements:
                - Stance: ${editorialParams.stance}
                - Tone: ${editorialParams.tone}
                - Structure: Catchy Headline, Engaging Introduction, 3-4 Clear Arguments, Counter-argument rebuttal (if balanced), and a Strong Conclusion.
                - Formatting: Use Markdown (## Headers, **Bold** for emphasis).
                - Vocabulary: Use advanced, sophisticated vocabulary (B1-C2 level).
                - **IMPORTANT**: Return your response such that the first line is exactly "EDITORIAL_TITLE: [Your Creative Headline]".
                `;
            } else {
                prompt = `
                Act as a senior Editor-in-Chief. Write a comprehensive ${editorialParams.length} editorial piece on the topic: "${topic}".
                
                Key Requirements:
                - Stance: ${editorialParams.stance}
                - Tone: ${editorialParams.tone}
                - Structure: Catchy Headline, Engaging Introduction, 3-4 Clear Arguments, Counter-argument rebuttal (if balanced), and a Strong Conclusion.
                - Formatting: Use Markdown (## Headers, **Bold** for emphasis).
                - Style: Professional, articulate, and thought-provoking.
                - Vocabulary: Use advanced, sophisticated vocabulary (B1-C2 level). Demonstrate complex sentence structures and precise language.
                - **IMPORTANT**: Do NOT use Concept Cards or special widget formats. Write in a continuous, flowing newspaper editorial style.
                `;
            }

            const response = await callLLM(prompt, "You are a professional editor.", false, null);

            if (!response || response.startsWith("Error")) {
                throw new Error("Generation failed: " + response);
            }

            let finalTopic = topic;
            let finalContent = response;

            // Robust title extraction handling various model output formats
            // Handles: EDITORIAL_TITLE, EDITORIAL-TITLE, EDITORIAL TITLE, TITLE, HEADLINE
            const titleRegex = /(?:EDITORIAL[_\s-]?TITLE|TITLE|HEADLINE):\s*(.*)/i;
            const titleMatch = response.match(titleRegex);

            if (titleMatch) {
                finalTopic = titleMatch[1].trim();
                // Remove the matched title line from the content
                finalContent = response.replace(titleMatch[0], '').trim();
            }

            if (!finalTopic) finalTopic = "Untitled Editorial";

            await saveEditorialSession(finalTopic, finalContent);

        } catch (error) {
            setGenerationData(null);
            setAppMode('idle');
            Alert.alert("Error", "Failed to generate editorial. Please try again.");
            console.error(error);
        }
    };
    // NEW: Sync Audio Status (Checks if files exist and updates hasAudio flag)
    const syncAudioAvailability = useCallback(async () => {
        // Optimization: Check if sessions are loaded
        if (Object.keys(chatSessions).length === 0) return;

        try {
            const docDir = fs.documentDirectory || FileSystem.documentDirectory;
            const files = await fs.readDirectoryAsync(docDir || "");

            // NEW: Robust Hash Scanning
            // Create a Set of all hashes found in the file system for fast lookup.
            // File format: tts_{HASH}_{Title}.wav or tts_{HASH}.wav
            // This decouples detection from the Title part, making it 100% reliable based on Content+Voice.
            const diskHashes = new Set();

            files.forEach(f => {
                if (f.startsWith('tts_') && f.endsWith('.wav')) {
                    const parts = f.split('_');
                    // Hash is always the second part (index 1)
                    // e.g. "tts", "abc123hash", "Title.wav"
                    if (parts.length >= 2) {
                        diskHashes.add(parts[1]);
                    }
                }
            });

            if (diskHashes.size === 0) return;

            let updates = {};
            let hasUpdates = false;

            // Check ALL voices to find existing files for sessions
            const voicesToScan = [...new Set([...AVAILABLE_VOICES, "Kore"])]; // Ensure unique list

            (Object.values(chatSessions) as any[]).forEach((session: any) => {
                if (session.messages && session.messages[0]) {
                    const text = session.messages[0].content;
                    if (!text) return;

                    const cleanText = cleanTextForDisplay(text);

                    // 1. If session already has a tagged voice, verify if its file actually exists
                    if (session.voice && session.hasAudio) {
                        const currentHash = simpleHash(cleanText + session.voice);
                        if (diskHashes.has(currentHash)) {
                            return; // File confirmed, state is correct. Skip.
                        }
                        // If tag exists but file missing, we proceed to scan (maybe user deleted it, or tag is wrong)
                    }

                    // 2. Scan all voices to find a match on disk
                    let foundVoice = null;

                    for (const v of voicesToScan) {
                        const hash = simpleHash(cleanText + v);
                        if (diskHashes.has(hash)) {
                            foundVoice = v;
                            break; // Found the voice this file was generated with
                        }
                    }

                    // 3. Update Session if we found a file and state is out of sync
                    if (foundVoice) {
                        if (!session.hasAudio || session.voice !== foundVoice) {
                            (updates as any)[session.id] = { ...session, hasAudio: true, voice: foundVoice };
                            hasUpdates = true;
                        }
                    }
                }
            });

            if (hasUpdates) {
                console.log(`Restored audio links for ${Object.keys(updates).length} sessions`);
                setChatSessions((prev: any) => {
                    const newSessions = { ...prev, ...updates };
                    // Persist updates to storage asynchronously
                    const updatePairs = Object.values(updates).map((s: any) => [`session_${s.id}`, JSON.stringify(s)] as [string, string]);
                    AsyncStorage.multiSet(updatePairs).catch(e => console.warn("Failed to persist audio sync", e));
                    return newSessions;
                });
            }
        } catch (e) {
            console.warn("Audio Sync Error", e);
        }
    }, [chatSessions]); // Removed other dependencies to ensure robust full scan

    // Trigger audio sync when sessions load or voice changes
    useEffect(() => {
        // Debounce the sync to avoid running during rapid state updates or initial heavy load
        const timeout = setTimeout(() => {
            syncAudioAvailability();
        }, 3000);
        return () => clearTimeout(timeout);
    }, [chatSessions, displaySettings.voice]);

    useEffect(() => {
        if (readingSession?.image) {
            Image.getSize(readingSession.image, (width, height) => {
                if (width > 0 && height > 0) {
                    setCoverAspectRatio(width / height);
                }
            }, (err) => {
                // Ignore errors (keep default or previous)
            });
        }
    }, [readingSession?.image]);

    // FIX: Handle Android Back Button in Saved Questions
    useEffect(() => {
        const backAction = () => {
            if (activeTab === 'library' && questionsViewMode === 'saved_flashcards') {
                setQuestionsViewMode('cards');
                return true;
            }
            return false;
        };

        const backHandler = BackHandler.addEventListener(
            "hardwareBackPress",
            backAction
        );

        return () => backHandler.remove();
    }, [activeTab, questionsViewMode]);

    const filteredNotes = useMemo((): any[] => {
        return Object.values(chatSessions || {})
            .filter((s: any) => s.toolId === 'quick_notes')
            .filter((s: any) => {
                if (!noteSearchQuery.trim()) return true;
                const query = noteSearchQuery.toLowerCase();
                const titleMatch = s.title?.toLowerCase().includes(query);
                const contentMatch = s.messages[0]?.content?.toLowerCase().includes(query);
                return titleMatch || contentMatch;
            })
            .sort((a: any, b: any) => {
                if (a.pinned && !b.pinned) return -1;
                if (!a.pinned && b.pinned) return 1;
                return (b.timestamp || '').localeCompare(a.timestamp || '');
            });
    }, [chatSessions, noteSearchQuery]);

    // FIX: Corrected the SyntaxError in filteredLibraryItems
    const filteredLibraryItems = useMemo(() => {
        if (libraryTab === 'chats') {
            // 1. Get all assistant sessions (excluding notes, stories, quizzes, editorials, flashcards, and audio)
            const rawChats = (Object.values(chatSessions || {}) as any[])
                .filter(s => s.toolId !== 'quick_notes' && s.toolId !== 'story_generator' && s.toolId !== 'quiz_save' && s.toolId !== 'editorial_writer' && s.toolId !== 'flashcards' && s.toolId !== 'audio_player')
                .filter(s => {
                    // Apply Search Filter
                    if (librarySearchQuery.trim()) {
                        const q = librarySearchQuery.toLowerCase();
                        const matchesTitle = s.title?.toLowerCase().includes(q);
                        const matchesContent = s.messages?.[0]?.content?.toLowerCase().includes(q);
                        return matchesTitle || matchesContent;
                    }
                    return true;
                });

            // 2. Sort List (Pinned first, then Newest)
            return rawChats.sort((a, b) => {
                if (a.pinned && !b.pinned) return -1;
                if (!a.pinned && b.pinned) return 1;
                return (b.timestamp || '').localeCompare(a.timestamp || '');
            });

        } else if (libraryTab === 'stories') {
            // NEW: Include Editorial Writer in Studio/Stories tab
            const rawStories = Object.values(chatSessions || {})
                .filter((s: any) => (s.toolId === 'story_generator' || s.toolId === 'editorial_writer'));

            // 1. Grouping Logic
            const groups: any = {};
            const standalone: any[] = [];

            rawStories.forEach((s: any) => {
                // Apply Search Filter
                if (librarySearchQuery.trim()) {
                    const q = librarySearchQuery.toLowerCase();
                    const matchesTitle = s.title?.toLowerCase().includes(q);
                    const matchesContent = s.messages?.[0]?.content?.toLowerCase().includes(q);
                    if (!matchesTitle && !matchesContent) {
                        return;
                    }
                }

                // NEW: Group all Editorials together
                if (s.toolId === 'editorial_writer') {
                    const groupTitle = "Editorials";
                    if (!groups[groupTitle]) {
                        groups[groupTitle] = {
                            id: 'group_editorials',
                            isGroup: true,
                            title: groupTitle,
                            chapters: [],
                            timestamp: s.timestamp,
                            pinned: false,
                            image: null,
                            hasAudio: false
                        };
                    }

                    groups[groupTitle].chapters.push(s);

                    // Update group metadata
                    if (new Date(s.timestamp) > new Date(groups[groupTitle].timestamp)) {
                        groups[groupTitle].timestamp = s.timestamp;
                    }
                    if (s.pinned) groups[groupTitle].pinned = true;
                    if (s.hasAudio) groups[groupTitle].hasAudio = true;

                    return; // Skip standard processing
                }

                // Identify Book Title (Format: "Book Title: Chapter Title")
                const separatorIdx = s.title?.indexOf(':') ?? -1;
                if (separatorIdx > 0) {
                    const bookTitle = s.title.substring(0, separatorIdx).trim();

                    if (!groups[bookTitle]) {
                        groups[bookTitle] = {
                            id: `group_${simpleHash(bookTitle)}`,
                            isGroup: true,
                            title: bookTitle,
                            chapters: [],
                            timestamp: s.timestamp,
                            pinned: false,
                            image: s.image,
                            hasAudio: false
                        };
                    }

                    groups[bookTitle].chapters.push(s);

                    // Update group metadata
                    if (new Date(s.timestamp) > new Date(groups[bookTitle].timestamp)) {
                        groups[bookTitle].timestamp = s.timestamp; // Keep latest timestamp
                    }
                    if (s.pinned) groups[bookTitle].pinned = true; // Pin group if any chapter is pinned
                    if (s.hasAudio) groups[bookTitle].hasAudio = true;
                    // Use image from the first encountered chapter that has one (or keep updating to latest)
                    if (!groups[bookTitle].image && s.image) groups[bookTitle].image = s.image;

                } else {
                    standalone.push(s);
                }
            });

            // 2. Flatten Groups and handle singles
            const finalItems: any[] = [];

            Object.values(groups).forEach((g: any) => {
                if (g.chapters.length > 1) {
                    // Sort chapters inside the group by timestamp (Newest -> Oldest)
                    g.chapters.sort((a: any, b: any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
                    finalItems.push(g);
                } else {
                    // Only 1 chapter found for this book? Treat as standalone session
                    finalItems.push(g.chapters[0]);
                }
            });

            finalItems.push(...standalone);

            // 3. Sort Final List (Newest modified books/stories first)
            return finalItems.sort((a, b) => {
                if (a.pinned && !b.pinned) return -1;
                if (!a.pinned && b.pinned) return 1;
                return (b.timestamp || '').localeCompare(a.timestamp || '');
            });
        } else if (libraryTab === 'audio') {
            // Audio files are permanent delete only
            return audioFiles;
        } else if (libraryTab === 'questions') {
            if (questionsViewMode === 'quizzes') {
                return (Object.values(chatSessions || {}) as any[])
                    .filter(s => s.toolId === 'quiz_save')
                    .filter(s => {
                        if (!librarySearchQuery.trim()) return true;
                        const q = librarySearchQuery.toLowerCase();
                        return s.title?.toLowerCase().includes(q);
                    })
                    .sort((a, b) => {
                        if (a.pinned && !b.pinned) return -1;
                        if (!a.pinned && b.pinned) return 1;
                        return (b.timestamp || '').localeCompare(a.timestamp || '');
                    });
            } else if (questionsViewMode === 'saved') {
                return [...(savedQuestions || [])]
                    .filter(q => {
                        if (!librarySearchQuery.trim()) return true;
                        const query = librarySearchQuery.toLowerCase();
                        return q.question?.toLowerCase().includes(query) || q.explanation?.toLowerCase().includes(query);
                    })
                    .reverse();
            } else if (questionsViewMode === 'cards') {
                const flashcardSessions = (Object.values(chatSessions || {}) as any[])
                    .filter((s: any) => s.toolId === 'flashcards')
                    .filter((s: any) => {
                        if (!librarySearchQuery.trim()) return true;
                        const q = librarySearchQuery.toLowerCase();
                        return s.title?.toLowerCase().includes(q);
                    })
                    .sort((a, b) => {
                        if (a.pinned && !b.pinned) return -1;
                        if (!a.pinned && b.pinned) return 1;
                        return (b.timestamp || '').localeCompare(a.timestamp || '');
                    });

                // Inject Saved Questions Group if valid
                // Inject Saved Questions Group if valid
                // Inject Saved Questions Group if valid
                if (true) {
                    const savedFlashcardsCount = (savedQuestions || []).filter(q => !q.options || q.options.length === 0).length;
                    if (savedFlashcardsCount > 0 && (!librarySearchQuery.trim() || "saved questions".includes(librarySearchQuery.toLowerCase()))) {
                        const groupItem = {
                            id: 'saved_questions_group',
                            title: 'Saved Questions',
                            timestamp: new Date().toISOString(), // Always display as recent
                            toolId: 'flashcards', // Keep generic
                            isGroup: true,
                            count: savedFlashcardsCount
                        };
                        return [groupItem, ...flashcardSessions];
                    }
                }
                return flashcardSessions;
            } else {

                return [...(savedWords || [])]
                    .filter(w => {
                        if (!librarySearchQuery.trim()) return true;
                        const query = librarySearchQuery.toLowerCase();
                        return w.word?.toLowerCase().includes(query) || w.definition?.toLowerCase().includes(query);
                    })
                    .reverse();
            }
        }
        return [];
    }, [libraryTab, chatSessions, librarySearchQuery, audioFiles, questionsViewMode, savedQuestions, savedWords, customTools]);

    // FIX: Removed duplicate 'const recentSearchesRef' declaration here.
    // It is already declared at the top of the App component.
    const dictionaryCacheRef = useRef(dictionaryCache);
    const savedWordsRef = useRef(savedWords);
    const displaySettingsRef = useRef(displaySettings);

    // Debug: List available models to find a working TTS one
    // Debug: List available models to find a working TTS one - DISABLED
    // useEffect(() => {
    //     const checkModels = async () => {
    //         console.log("Checking available Gemini models..."); 
    //     };
    //     // checkModels();
    // }, []);

    // Sync refs with state
    useEffect(() => { recentSearchesRef.current = recentSearches; }, [recentSearches]);
    useEffect(() => { dictionaryCacheRef.current = dictionaryCache; }, [dictionaryCache]);
    useEffect(() => { savedWordsRef.current = savedWords; }, [savedWords]);
    useEffect(() => { displaySettingsRef.current = displaySettings; }, [displaySettings]);

    const dictionarySuggestions = useMemo(() => {
        if (!dictionaryInput.trim()) return [];
        const query = dictionaryInput.toLowerCase().trim();
        const localWords = (savedWords || []).map(w => w.word);
        const historyWords = recentSearches.map(item => typeof item === 'string' ? item : item.word);
        const allWords = Array.from(new Set([...localWords, ...historyWords]));
        return allWords
            .filter(w => w && w.toLowerCase().startsWith(query))
            .sort()
            .slice(0, 5);
    }, [dictionaryInput, savedWords, recentSearches]);

    const librarySuggestions = useMemo(() => {
        if (!quickSearchQuery.trim()) return [];
        const query = quickSearchQuery.toLowerCase().trim();
        const matches = Object.values(chatSessions || {})
            .filter((s: any) => s.title && s.title.toLowerCase().includes(query))
            .sort((a: any, b: any) => {
                const aStarts = a.title.toLowerCase().startsWith(query);
                const bStarts = b.title.toLowerCase().startsWith(query);
                if (aStarts && !bStarts) return -1;
                if (!aStarts && bStarts) return 1;
                return 0;
            })
            .slice(0, 5);
        return matches;
    }, [quickSearchQuery, chatSessions]);

    useEffect(() => {
        if (activeTab === 'settings') {
            const calculateStorage = async () => {
                try {
                    const free = await fs.getFreeDiskStorageAsync();
                    // Calculate JSON Data Size
                    const used = JSON.stringify(chatSessions).length +
                        JSON.stringify(savedWords).length +
                        JSON.stringify(savedQuestions).length +
                        JSON.stringify(recentSearches).length;

                    // NEW: Calculate Audio Files Size
                    let audioSize = 0;
                    const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                    const files = await fs.readDirectoryAsync(docDir || "");
                    const ttsFiles = files.filter(f => f.startsWith('tts_') && f.endsWith('.wav'));

                    // Calculate size of audio files in parallel
                    const audioSizes = await Promise.all(ttsFiles.map(async (f) => {
                        try {
                            const info = await fs.getInfoAsync(docDir + f);
                            return (info as any).size || 0;
                        } catch (e: any) { return 0; }
                    }));

                    audioSize = audioSizes.reduce((a: number, b: number) => a + b, 0);

                    setStorageStats({ free, used, audio: audioSize });
                } catch (e: any) {
                    console.log("Storage calc error", e);
                }
            };
            calculateStorage();
        }
    }, [activeTab, chatSessions, savedWords, savedQuestions, recentSearches]);

    const [isTableLandscape, setIsTableLandscape] = useState(true);
    const [modalLanguage, setModalLanguage] = useState("English");

    const readerListRef = useRef<any>(null);
    const scrollOffsets = useRef<any>({});
    const ignoreScrollRef = useRef(false);
    const isUserScrolling = useRef(false);
    const lastScrolledParagraph = useRef(-1);
    const savedTableWidths = useRef<any>({});
    const pendingRestoreOffset = useRef<any>(null);
    const shouldScrollToNewContentRef = useRef(false);
    const prevParagraphCountRef = useRef(0);
    const speakRef = useRef<any>(null);
    const stopTTSRef = useRef<any>(null);
    const jumpRef = useRef<any>(null);
    const highlightSaveTimeout = useRef<any>(null);
    const toastTimeoutRef = useRef<any>(null);

    useEffect(() => {
        persistSessionRef.current = persistSession;
    }, [persistSession]);

    useEffect(() => {
        const manageOrientation = async () => {
            try {
                if (expandedTableData) {
                    if (isTableLandscape) {
                        await ScreenOrientation.lockAsync(ScreenOrientation.OrientationLock.LANDSCAPE);
                    } else {
                        await ScreenOrientation.lockAsync(ScreenOrientation.OrientationLock.PORTRAIT_UP);
                    }
                } else {
                    await ScreenOrientation.unlockAsync();
                    const currentOffset = (readingSession?.id && (scrollOffsets.current as any)[readingSession.id]) || 0;
                    if (appMode === 'reader' && currentOffset > 0) {
                        setTimeout(() => {
                            readerListRef.current?.scrollToOffset({
                                offset: currentOffset,
                                animated: false
                            });
                        }, 600);
                    }
                }
            } catch (e) {
                console.log("Orientation change ignored (Activity unavailable):", e);
            }
        };
        manageOrientation();
        return () => {
            ScreenOrientation.unlockAsync().catch(() => { });
        };
    }, [expandedTableData, isTableLandscape]);

    useEffect(() => {
        const targetOffset = (readingSession?.id && (scrollOffsets.current as any)[readingSession.id]) || 0;
        isUserScrolling.current = false;
        lastScrolledParagraph.current = -1;
        pendingRestoreOffset.current = targetOffset;
        setShowStoryAd(false); // NEW: Reset ad visibility when opening a new session/chapter
        if (appMode === 'reader' && readerListRef.current) {
            setTimeout(() => {
                if (readerListRef.current) {
                    (readerListRef.current as any).scrollToOffset({ offset: targetOffset, animated: false });
                }
            }, 0);
        }
    }, [readingSession?.id]); // UPDATED: Removed displaySettings.theme to prevent scroll jump on theme switch

    const handleWordHighlight = useCallback(({ start, end, text }: any) => {
        setReadingSession((prev: any) => {
            if (!prev) return prev;
            const currentHighlights = prev.highlights || [];
            const overlaps = currentHighlights.filter((h: any) =>
                (start < h.end && end > h.start)
            );
            let newHighlights;
            if (overlaps.length > 0) {
                newHighlights = currentHighlights.filter((h: any) => !(start < h.end && end > h.start));
            } else {
                newHighlights = [...currentHighlights, { start, end, text, color: activeHighlightColorRef.current, id: generateId() }];
            }
            const updatedSession = { ...prev, highlights: newHighlights };
            if (highlightSaveTimeout.current) clearTimeout(highlightSaveTimeout.current);
            highlightSaveTimeout.current = setTimeout(() => {
                if (persistSessionRef.current) {
                    persistSessionRef.current(updatedSession);
                }
            }, 1500);
            return updatedSession;
        });
    }, []);


    const [showImageEditor, setShowImageEditor] = useState(false);
    const [editorTarget, setEditorTarget] = useState<{ uri: string; width: number; height: number; } | null>(null);
    const [editorRotation, setEditorRotation] = useState(0);
    const [editingImageIndex, setEditingImageIndex] = useState<number | null>(null);
    const [editorContainerSize, setEditorContainerSize] = useState({ width: 0, height: 0 });
    const [cropRegion, setCropRegion] = useState<{ x: number; y: number; width: number; height: number; effectiveW?: number; effectiveH?: number; } | null>(null);
    const [displayedImageRect, setDisplayedImageRect] = useState<{ x: number; y: number; width: number; height: number; effectiveW?: number; effectiveH?: number; } | null>(null);
    const cropRegionRef = useRef<{ x: number; y: number; width: number; height: number; effectiveW?: number; effectiveH?: number; } | null>(null);
    const displayedImageRectRef = useRef<{ x: number; y: number; width: number; height: number; effectiveW?: number; effectiveH?: number; } | null>(null);
    const dragStartRef = useRef<{ x: number; y: number; width: number; height: number; effectiveW?: number; effectiveH?: number; } | null>(null);
    useEffect(() => { cropRegionRef.current = cropRegion; }, [cropRegion]);
    useEffect(() => { displayedImageRectRef.current = displayedImageRect; }, [displayedImageRect]);
    const reviewListRef = useRef<any>(null);
    const prevLanguageRef = useRef(displaySettings.language);
    const viewabilityConfig = useRef({ itemVisiblePercentThreshold: 50 }).current;
    const onViewableItemsChanged = useRef(({ viewableItems }: any) => {
        if (viewableItems && viewableItems.length > 0) {
            const firstItem = viewableItems[0];
            if (firstItem.index !== null && firstItem.index !== undefined) {
                setQuizState((prev: any) => {
                    if (!prev || prev.currentIndex === firstItem.index) return prev;
                    return { ...prev, currentIndex: firstItem.index };
                });
            }
        }
    }).current;

    // ... (readerParagraphs useMemo logic) ...
    const readerParagraphs = useMemo(() => {
        const hasMessages = readingSession?.messages && readingSession.messages[0] && readingSession.messages[0].content;
        const hasDirectContent = readingSession?.content;
        if (appMode !== 'reader' || !readingSession || (!hasMessages && !hasDirectContent)) return [];

        const rawContent = hasMessages ? readingSession.messages[0].content : readingSession.content;
        const content = rawContent.replace(/RESOURCE_LINK:\s*https?:\/\/[^\s]+/, '').trim();
        const lines = content.split('\n');
        const data = [];
        let offset = 0;

        let inTable = false;
        let tableBuffer: any[] = [];

        let inConceptCard = false;
        let conceptCardBuffer: any[] = [];
        let conceptCardTitle = "";

        let textBuffer: any[] = [];
        let textStartOffset = 0;

        let nextTableHidden = false;
        let nextTableLabel = "Show Answers";
        let hasSkippedHeader = false;

        const flushTextBuffer = () => {
            if (textBuffer.length > 0) {
                const blockText = textBuffer.join('\n');
                data.push({
                    id: `txt-${textStartOffset}-${data.length}`,
                    type: 'text',
                    text: blockText,
                    offset: textStartOffset
                });
                textBuffer = [];
            }
        };

        lines.forEach((line: string, idx: number) => {
            const trimmed = line.trim();
            const cleanLineContent = cleanTextForDisplay(line);
            const lenToAdd = cleanLineContent.length > 0 ? cleanLineContent.length + 1 : 0;

            if (!hasSkippedHeader && trimmed.startsWith('#')) {
                flushTextBuffer();
                hasSkippedHeader = true;
                offset += lenToAdd;
                return;
            }

            const toggleMatch = trimmed.match(/^\[\[TOGGLE_TABLE(?::(.*))?\]\]$/);
            if (toggleMatch) {
                flushTextBuffer();
                nextTableHidden = true;
                nextTableLabel = toggleMatch[1] ? toggleMatch[1].trim() : "Show Answers";
                return;
            }

            // NEW: Concept Card Parsing
            const conceptStartMatch = trimmed.match(/^\[\[CONCEPT_CARD(?::(.*))?\]\]$/);
            if (conceptStartMatch) {
                flushTextBuffer();
                inConceptCard = true;
                conceptCardTitle = conceptStartMatch[1] ? conceptStartMatch[1].trim() : "";
                conceptCardBuffer = [];
                return;
            }

            const conceptEndMatch = trimmed.match(/^\[\[END_CARD\]\]$/);
            if (conceptEndMatch && inConceptCard) {
                const cardContent = conceptCardBuffer.join('\n');

                // NEW: Calculate full text length including title to match cleanTextForDisplay
                // This ensures TTS highlights align with the visual blocks
                let titleText = "";
                if (conceptCardTitle) {
                    titleText = `${conceptCardTitle}. `;
                }

                data.push({
                    id: `cc-${idx}`,
                    type: 'concept-card',
                    title: conceptCardTitle, // Store original title (without period)
                    titleText: titleText,    // Store text version for rendering/offsets
                    content: cardContent,
                    offset: offset,
                    chapterName: currentNoteTitle
                });

                // Advance offset by full length (Title + Content)
                const cleanContent = cleanTextForDisplay(cardContent);
                const fullCardText = titleText + cleanContent;

                if (fullCardText.length > 0) offset += fullCardText.length + 1;

                inConceptCard = false;
                conceptCardBuffer = [];
                conceptCardTitle = "";
                return;
            }

            if (inConceptCard) {
                conceptCardBuffer.push(trimmed);
                return;
            }

            const isTableLine = trimmed.startsWith('|');

            if (isTableLine) {
                flushTextBuffer();
                if (!inTable) {
                    inTable = true;
                    tableBuffer = [];
                }
                tableBuffer.push(trimmed);
            } else {
                if (inTable) {
                    const tableText = tableBuffer.join('\n');
                    const cleanTableText = cleanTextForDisplay(tableText);

                    data.push({
                        id: `tbl-${idx}`,
                        type: 'table',
                        rows: [...tableBuffer],
                        offset: offset,
                        initiallyHidden: nextTableHidden,
                        toggleLabel: nextTableLabel
                    });

                    nextTableHidden = false;
                    nextTableLabel = "Show Answers";

                    if (cleanTableText.length > 0) {
                        offset += cleanTableText.length + 1;
                    }

                    tableBuffer = [];
                    inTable = false;
                }

                if (textBuffer.length === 0) {
                    textStartOffset = offset;
                }

                textBuffer.push(formatMathForDisplay(line));

                if (cleanLineContent.length > 0) {
                    offset += lenToAdd;
                }

                if (textBuffer.length >= 1) {
                    flushTextBuffer();
                }
            }
        });

        flushTextBuffer();

        if (inTable && tableBuffer.length > 0) {
            const tableText = tableBuffer.join('\n');
            const cleanTableText = cleanTextForDisplay(tableText);

            data.push({
                id: `tbl-end`,
                type: 'table',
                rows: [...tableBuffer],
                offset: offset,
                initiallyHidden: nextTableHidden,
                toggleLabel: nextTableLabel
            });

            if (cleanTableText.length > 0) {
                offset += cleanTableText.length + 1;
            }
        }

        return data;
    }, [readingSession?.messages, readingSession?.id, appMode]);

    useEffect(() => {
        if (appMode === 'reader' && speechRange && readerListRef.current && !isUserScrolling.current) {
            const currentPos = speechRange.start;
            let targetIndex = -1;
            for (let i = 0; i < readerParagraphs.length; i++) {
                if (readerParagraphs[i].offset <= currentPos) {
                    targetIndex = i;
                } else {
                    break;
                }
            }
            if (targetIndex !== -1 && targetIndex !== lastScrolledParagraph.current) {
                lastScrolledParagraph.current = targetIndex;
                try {
                    readerListRef.current.scrollToIndex({
                        index: targetIndex,
                        animated: true,
                        viewPosition: 0.2
                    });
                } catch (e: any) {
                }
            }
        }
    }, [speechRange, appMode, readerParagraphs]);

    const readerFullText = useMemo(() => {
        const hasMessages = readingSession?.messages && readingSession.messages[0] && readingSession.messages[0].content;
        const hasDirectContent = readingSession?.content;
        if (!readingSession || (!hasMessages && !hasDirectContent)) return "";

        const rawContent = hasMessages ? readingSession.messages[0].content : readingSession.content;
        return cleanTextForDisplay(
            rawContent
                .trim()
        );
    }, [readingSession]);

    const activeSentence = useMemo(() => {
        if (!speechRange || appMode !== 'reader' || isOnlinePlayback) return null;
        if (!playingMeta || playingMeta.id !== readingSession?.id) return null;
        return getSentenceBounds(readerFullText, speechRange.start);
    }, [speechRange, readerFullText, appMode, isOnlinePlayback, playingMeta, readingSession]);

    useEffect(() => {
        let interval: any;
        if (appMode === 'live' && quizState && !quizState.completed) {
            interval = setInterval(() => {
                setQuizSecondsElapsed((prev: number) => prev + 1);
            }, 1000);
        }
        return () => clearInterval(interval);
    }, [appMode, quizState?.completed]);

    useEffect(() => {
        let interval: any;
        if (isRateLimited) {
            const checkRecovery = async () => {
                const key = customApiKey || apiKey;
                if (!key) return;
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${TEXT_MODELS[0]}:generateContent?key=${key}`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: [{ parts: [{ text: "hi" }] }] })
                    });

                    if (response.ok) {
                        setIsRateLimited(false);
                        console.log("API Limit recovered: System is back online.");
                    }
                } catch (e: any) {
                }
            };
            interval = setInterval(checkRecovery, 60000);
        }
        return () => clearInterval(interval);
    }, [isRateLimited, customApiKey]);

    // NEW: Effect to handle auto-translation when language changes in Settings
    useEffect(() => {
        const handleLanguageAutoSwitch = async () => {
            const targetLang = displaySettings.language;
            const prevLang = prevLanguageRef.current;
            const isLanguageChange = targetLang !== prevLang;

            // Update ref immediately so future runs know current state
            prevLanguageRef.current = targetLang;

            const key = customApiKey || apiKey;

            if (!key) return;

            // Reader Mode Logic
            // Reader Mode Logic
            if (appMode === 'reader' && readingSession) {
                // SAFETY: If session is "Lite" or malformed, skip logic to avoid crash
                if (!readingSession.messages || !readingSession.messages.length) return;

                // Initialize translations if missing
                if (!readingSession.translations) {
                    const initialLang = readingSession.language || 'English'; // Default to English if untagged
                    readingSession.translations = { [initialLang]: readingSession.messages[0].content };
                    readingSession.language = initialLang;
                }

                if (readingSession.language === targetLang) {
                    // already current
                } else if (readingSession.translations[targetLang]) {
                    // Translation exists in cache, swap instantly
                    const newContent = readingSession.translations[targetLang];
                    const updatedSession = {
                        ...readingSession,
                        messages: [{ role: 'ai', content: newContent }],
                        language: targetLang
                    };
                    setReadingSession(updatedSession);
                    await persistSession(updatedSession); // Save current view state
                } else {
                    // Need to translate
                    // Only proceed if this was triggered by an explicit language change by the user
                    if (isLanguageChange) {
                        setIsTranslating(true);
                        try {
                            const sourceText = readingSession.translations[readingSession.language] || readingSession.messages[0].content;
                            const prompt = `Translate the following Markdown text to ${targetLang}. Maintain all Markdown formatting (headers, bold, bullet points) exactly as is:\n\n${sourceText}`;

                            const translatedText = await callLLM(prompt, "Expert Translator");

                            if (!translatedText.startsWith("Error")) {
                                const updatedTranslations = { ...readingSession.translations, [targetLang]: translatedText };
                                const updatedSession = {
                                    ...readingSession,
                                    translations: updatedTranslations,
                                    messages: [{ role: 'ai', content: translatedText }],
                                    language: targetLang
                                };
                                setReadingSession(updatedSession);
                                await persistSession(updatedSession);
                            }
                        } catch (e: any) {
                            console.error("Translation error", e);
                        } finally {
                            setIsTranslating(false);
                        }
                    }
                }
            }

            // Quiz Mode Logic
            if (appMode === 'live' && quizState) {
                // NEW: Check if translation is prevented for this quiz (Language-Specific)
                if (quizState.preventTranslation) {
                    const quizLang = quizState.language || 'English';
                    // Show message if language settings changed OR if current quiz language differs from app language (e.g. shared quiz)
                    if (isLanguageChange || quizLang !== targetLang) {
                        showToast(`Language Learning On: Translation skipped (${quizLang}).`);
                    }
                    return; // EXIT: Do not translate
                }

                // Initialize translations if missing
                if (!quizState.translations) {
                    const initialLang = quizState.language || 'English';
                    quizState.translations = { [initialLang]: quizState.questions };
                    quizState.language = initialLang;
                }

                if (quizState.language === targetLang) {
                    // already current
                } else if (quizState.translations[targetLang]) {
                    // Swap questions but Preserve User State (selections, scores, time)
                    const translatedQuestions = quizState.translations[targetLang];
                    const currentQuestions = quizState.questions;

                    // Merge state: Take text from translated, state from current
                    const mergedQuestions = translatedQuestions.map((q: any, idx: number) => ({
                        ...q, // New text
                        selected: currentQuestions[idx]?.selected ?? null,
                        markedForReview: currentQuestions[idx]?.markedForReview ?? false,
                        visited: currentQuestions[idx]?.visited ?? false
                    }));

                    const updatedState = {
                        ...quizState,
                        questions: mergedQuestions,
                        language: targetLang,
                        title: quizState.title
                    };
                    setQuizState(updatedState);

                    // Persist the language switch
                    if (quizState.originId && chatSessions[quizState.originId]) {
                        const session = chatSessions[quizState.originId];
                        session.quizData = mergedQuestions;
                        session.language = targetLang;
                        session.translations = quizState.translations;
                        await persistSession(session);
                    }
                } else {
                    // Translate Quiz JSON
                    // Only proceed if triggered by explicit language change
                    if (isLanguageChange) {
                        setIsTranslating(true);
                        try {
                            const sourceQuestions = quizState.translations[quizState.language] || quizState.questions;
                            // Strip user state before sending to LLM to save tokens/avoid confusion
                            const cleanSource = sourceQuestions.map(({ question, options, correctOptionIndex, explanation }: any) => ({ question, options, correctOptionIndex, explanation }));

                            const prompt = `Translate this JSON quiz content to ${targetLang}. 
                          Strictly maintain JSON structure: [{"question":"...","options":["..."],"correctOptionIndex":0,"explanation":"..."}].
                          Do NOT change 'correctOptionIndex'. Translate 'question', 'options', and 'explanation'.
                          Output ONLY valid JSON.
                          
                          Source JSON:
                          ${JSON.stringify(cleanSource)}`;

                            const raw = await callLLM(prompt, "Translator");
                            const cleanJson = extractJSON(raw);
                            const newQuestionsData = JSON.parse(cleanJson);

                            if (Array.isArray(newQuestionsData) && newQuestionsData.length === sourceQuestions.length) {
                                const updatedTranslations = { ...quizState.translations, [targetLang]: newQuestionsData };

                                // Merge state
                                const currentQuestions = quizState.questions;
                                const mergedQuestions = newQuestionsData.map((q, idx) => ({
                                    ...q,
                                    selected: currentQuestions[idx]?.selected ?? null,
                                    markedForReview: currentQuestions[idx]?.markedForReview ?? false,
                                    visited: currentQuestions[idx]?.visited ?? false
                                }));

                                const updatedState = {
                                    ...quizState,
                                    translations: updatedTranslations,
                                    questions: mergedQuestions,
                                    language: targetLang
                                };
                                setQuizState(updatedState);

                                if (quizState.originId && chatSessions[quizState.originId]) {
                                    const session = chatSessions[quizState.originId];
                                    session.quizData = mergedQuestions;
                                    session.language = targetLang;
                                    session.translations = updatedTranslations;
                                    await persistSession(session);
                                }
                            }
                        } catch (e: any) {
                            console.error("Quiz translation error", e);
                            Alert.alert("Translation Failed", "Could not translate quiz content.");
                        } finally {
                            setIsTranslating(false);
                        }
                    }
                }
            }

            // Dictionary Auto-Translation
            if (isLanguageChange) {
                const getCleanData = (d: any) => {
                    if (!d) return null;
                    const { translations, ...rest } = d;
                    return rest;
                };

                const updateDictionaryHistory = async (word: string, fullData: any) => {
                    const lowerWord = word.toLowerCase();
                    // Update Cache
                    setDictionaryCache((prev: any) => ({ ...prev, [lowerWord]: fullData }));

                    // Update Recent Searches
                    // Update Recent Searches
                    // 1. Use existing state as source of truth (more reliable than reading file potentially mid-write)
                    // (But we filter from it)
                    const filtered = recentSearches.filter(item => {
                        const w = typeof item === 'string' ? item : item.word;
                        return w.toLowerCase() !== lowerWord;
                    });

                    // UPDATED: Create Lite Data to prevent massive JSON files (though FS can handle 2MB+, keep it clean)
                    const createLiteWordData = (data: any) => {
                        if (!data) return null;
                        return {
                            word: data.word,
                            phonetic: data.phonetic,
                            phonetics: data.phonetics ? data.phonetics.map((p: any) => ({ text: p.text, audio: p.audio })) : [], // keep only audio links
                            meanings: data.meanings ? data.meanings.map((m: any) => ({
                                partOfSpeech: m.partOfSpeech,
                                definitions: m.definitions ? m.definitions.slice(0, 3).map((d: any) => ({ definition: d.definition, example: d.example })) : []
                            })) : [],
                            simple: data.simple // Keep generated simple defs
                        };
                    };

                    const liteData = createLiteWordData(fullData);

                    // UPDATED: Use dynamic dictionaryLimit from Ref to avoid stale closure in async callback
                    const limit = displaySettingsRef.current.dictionaryLimit || 1000;
                    // Save LITE data to FILE
                    const updated = [{ word: fullData.word || word, data: liteData }, ...filtered].slice(0, limit);

                    setRecentSearches(updated);
                    await saveRecentSearchesToFile(updated);
                };

                // 1. Dictionary Tab
                if (activeTab === 'dictionary' && dictionaryResult && !dictionaryResult.error && dictionaryCurrentWord) {
                    // Init translations if missing
                    let currentTranslations = dictionaryResult.translations;
                    if (!currentTranslations) {
                        const originLang = dictionaryResult.language || prevLang || 'English';
                        currentTranslations = { [originLang]: getCleanData(dictionaryResult) };
                    }

                    if (currentTranslations[targetLang]) {
                        // Restore from cache
                        const restoredData = {
                            ...currentTranslations[targetLang],
                            language: targetLang,
                            translations: currentTranslations
                        };
                        setDictionaryResult(restoredData);
                        // Update active cache references
                        updateDictionaryHistory(dictionaryCurrentWord, restoredData);
                    } else {
                        setIsDictionaryLoading(true);
                        try {
                            const newData = await getDictionaryData(dictionaryCurrentWord);
                            const completeData = { ...newData, word: newData.word || dictionaryCurrentWord };

                            if (!newData.error) {
                                const cleanNewData = getCleanData(completeData);
                                const updatedTranslations = { ...currentTranslations, [targetLang]: cleanNewData };

                                const finalData = {
                                    ...cleanNewData,
                                    language: targetLang,
                                    translations: updatedTranslations
                                };

                                setDictionaryResult(finalData);
                                updateDictionaryHistory(dictionaryCurrentWord, finalData);
                            }
                        } catch (e: any) {
                            console.error("Dictionary translation error", e);
                        } finally {
                            setIsDictionaryLoading(false);
                        }
                    }
                }

                // 2. Word Popup Modal
                if (showWordModal && wordData && !wordData.error && selectedWord?.word) {
                    // Init translations if missing
                    let currentTranslations = wordData.translations;
                    if (!currentTranslations) {
                        const originLang = wordData.language || prevLang || 'English';
                        currentTranslations = { [originLang]: getCleanData(wordData) };
                    }

                    if (currentTranslations[targetLang]) {
                        const restoredData = {
                            ...currentTranslations[targetLang],
                            language: targetLang,
                            translations: currentTranslations
                        };
                        setWordData(restoredData);
                        // Update cache silently
                        setDictionaryCache((prev: any) => ({ ...prev, [selectedWord.word.toLowerCase()]: restoredData }));
                    } else {
                        setIsDefining(true);
                        try {
                            const newData = await getDictionaryData(selectedWord.word);
                            const completeData = { ...newData, word: newData.word || selectedWord.word };

                            if (!newData.error) {
                                const cleanNewData = getCleanData(completeData);
                                const updatedTranslations = { ...currentTranslations, [targetLang]: cleanNewData };

                                const finalData = {
                                    ...cleanNewData,
                                    language: targetLang,
                                    translations: updatedTranslations
                                };

                                setWordData(finalData);
                                // Update cache
                                const cacheKey = selectedWord.word.toLowerCase();
                                setDictionaryCache((prev: any) => ({ ...prev, [cacheKey]: finalData }));

                                // We don't necessarily need to update History List for modal lookups unless explicitly searched before, 
                                // but updating the cache is good.
                            }
                        } catch (e: any) {
                            console.error("Modal translation error", e);
                        } finally {
                            setIsDefining(false);
                        }
                    }
                }
            }
        };

        handleLanguageAutoSwitch();
    }, [displaySettings.language, appMode, activeTab, showWordModal]);

    // Init Audio for Gemini TTS (Updated for expo-audio)
    useEffect(() => {
        const setupAudio = async () => {
            try {
                await setAudioModeAsync({
                    allowsRecording: false,
                    shouldPlayInBackground: true,
                    playsInSilentMode: true,
                    interruptionMode: 'duckOthers',
                    shouldRouteThroughEarpiece: false,
                });
            } catch (e) {
                console.warn("Audio Config Error:", e);
            }
        };
        setupAudio();

        return () => {
            if (currentSound.current) {
                currentSound.current.remove();
                currentSound.current = null;
            }
            Speech.stop();
        };
    }, []);

    // NEW: Robust Effect to handle Keep Awake state with delay and error handling
    useEffect(() => {
        let isMounted = true;
        const manageKeepAwake = async () => {
            try {
                // Add a small delay to allow the native activity to initialize fully
                await new Promise(resolve => setTimeout(resolve, 2000));
                if (!isMounted) return;

                if (displaySettings.preventSleep) {
                    // Explicitly catch the promise rejection to prevent "Uncaught" error
                    // CHANGED: Removed custom tag 'ReaderApp' to use default tag for better stability
                    try {
                        await activateKeepAwakeAsync();
                    } catch (e: any) {
                        console.log("Keep awake activation deferred:", e && typeof e === 'object' && 'message' in e ? (e as any).message : "Unknown error");
                    }
                } else {
                    // CHANGED: Removed custom tag
                    try {
                        await deactivateKeepAwake();
                    } catch (e: any) {
                        // Ignore deactivation errors
                    }
                }
            } catch (e) {
                console.log("Keep Awake Error Safe Handled:", e);
            }
        };
        manageKeepAwake();
        return () => { isMounted = false; };
    }, [displaySettings.preventSleep]);

    // Reset online TTS failure flag when reading session changes (New Chapter / Content)
    useEffect(() => {
        onlineTTSBroken.current = false;

        if (readingSession && autoPlayRef.current) {
            autoPlayRef.current = false;
            // Auto-play TTS for the new chapter after a delay to allow UI to settle
            setTimeout(() => {
                const textToSpeak = readingSession.messages[0].content;
                if (textToSpeak) {
                    speak(textToSpeak);
                    // NEW: Set playing meta for auto-play
                    setPlayingMeta({ id: readingSession.id, title: readingSession.title });
                }
            }, 1000);
        }
    }, [readingSession?.id]);

    const updateQuizTime = (currentIndex: number) => {
        if (!quizState) return { newTimeSpent: [], now: Date.now() }; // Return consistent shape
        const now = Date.now();
        const duration = now - quizState.activeQuestionStartTime;
        const newTimeSpent = [...quizState.timeSpent];
        if (newTimeSpent[currentIndex] !== undefined) {
            newTimeSpent[currentIndex] += duration;
        }
        return { newTimeSpent, now };
    };

    // NEW: Function to restart the quiz
    const handleRetakeQuiz = (questionsToUse: any = null) => {
        // Use provided questions or current state
        const baseQuestions = questionsToUse || quizState?.questions || [];
        if (baseQuestions.length === 0) return;

        const resetQuestions = baseQuestions.map((q: any) => ({
            ...q,
            selected: null,
            markedForReview: false,
            visited: false
        }));

        setQuizState((prev: any) => ({
            ...prev,
            questions: resetQuestions,
            currentIndex: 0,
            score: 0,
            completed: false,
            timeSpent: new Array(resetQuestions.length).fill(0),
            activeQuestionStartTime: Date.now(),
            attempts: (prev.attempts || 1) + 1, // Increment Attempt Count
            autoSubmitted: false // NEW: Clear error flag on retake
        }));
        setQuizSecondsElapsed(0);
    };

    // NEW: Handle Saving Quiz Password
    const handleSaveQuizPassword = async () => {
        if (!quizPassword.trim()) {
            Alert.alert("Input Required", "Please enter a password.");
            return;
        }

        if (quizState?.originId && chatSessions[quizState.originId]) {
            const updatedSession = {
                ...chatSessions[quizState.originId],
                password: quizPassword.trim()
            };
            await persistSession(updatedSession);
            setQuizPassword(""); // Clear input
            setIsReviewUnlocked(false); // Lock immediately
            showToast("Password Saved & Review Locked");
            Keyboard.dismiss();
        } else {
            Alert.alert("Error", "Could not find quiz session to save.");
        }
    };

    // NEW: Handle Unlocking Quiz Review
    const handleUnlockReview = () => {
        if (!quizState?.originId) return;
        const session = chatSessions[quizState.originId];

        if (session && session.password === quizUnlockInput.trim()) {
            setIsReviewUnlocked(true);
            setQuizUnlockInput("");
            showToast("Review Unlocked");
            Keyboard.dismiss();
        } else {
            Alert.alert("Access Denied", "Incorrect Password.");
        }
    };

    const handleNextQuestion = () => {
        if (!quizState) return;

        // FIX: Debounce to prevent double-click / race conditions
        if (quizProcessingRef.current) return;
        quizProcessingRef.current = true;

        // Reset the lock after a short delay (e.g. 500ms) to allow next interaction
        setTimeout(() => {
            quizProcessingRef.current = false;
        }, 500);

        const { newTimeSpent, now } = updateQuizTime((quizState as any).currentIndex) as any;

        const newQuestions = [...(quizState as any).questions];
        newQuestions[quizState.currentIndex].visited = true;

        if (quizState.currentIndex < quizState.questions.length - 1) {
            setQuizState((prev: any) => ({
                ...prev,
                questions: newQuestions,
                currentIndex: prev.currentIndex + 1,
                timeSpent: newTimeSpent,
                activeQuestionStartTime: now
            }));
        } else {
            const finalTime = quizSecondsElapsed;

            // IMPROVEMENT: Ask user for next step instead of auto-completing
            Alert.alert(
                "Quiz Completed!",
                `You scored ${quizState.score}/${quizState.questions.length}.\n\nWhat would you like to do?`,
                [
                    {
                        text: "Test Again",
                        onPress: () => handleRetakeQuiz(newQuestions)
                    },
                    {
                        text: "Review Answers",
                        onPress: () => {
                            const completedState = {
                                ...quizState,
                                questions: newQuestions,
                                completed: true,
                                timeSpent: newTimeSpent,
                                autoSubmitted: false // NEW: Ensure clean finish
                            };
                            setQuizState(completedState);

                            if ((completedState as any).originId && (chatSessions as any)[(completedState as any).originId]) {
                                const updatedSession = {
                                    ...(chatSessions as any)[(completedState as any).originId],
                                    quizData: (completedState as any).questions,
                                    currentIndex: (completedState as any).currentIndex,
                                    score: (completedState as any).score,
                                    timeSpent: (completedState as any).timeSpent,
                                    completed: true,
                                    totalTime: finalTime,
                                    toolId: 'quiz_save',
                                    timestamp: new Date().toISOString(),
                                    attempts: (completedState as any).attempts || 1,
                                    isExamMode: (completedState as any).isExamMode,
                                    modeLocked: (completedState as any).modeLocked,
                                    autoSubmitted: false // NEW: Save clean state
                                };
                                persistSession(updatedSession);
                            }
                        }
                    }
                ]
            );
        }
    };

    const handleReviewAndNext = () => {
        if (!quizState) return;
        const { newTimeSpent, now } = updateQuizTime(quizState.currentIndex);

        const newQuestions = [...quizState.questions];
        newQuestions[quizState.currentIndex].markedForReview = true;
        newQuestions[quizState.currentIndex].visited = true;

        if (quizState.currentIndex < quizState.questions.length - 1) {
            setQuizState((prev: any) => ({
                ...prev,
                questions: newQuestions,
                currentIndex: prev.currentIndex + 1,
                timeSpent: newTimeSpent,
                activeQuestionStartTime: now
            }));
        } else {
            // NEW: Add confirmation for last question review finish
            Alert.alert(
                "Finish Exam",
                "You have marked the last question for review. Do you want to submit and finish the exam?",
                [
                    { text: "Cancel", style: "cancel" },
                    {
                        text: "Finish",
                        onPress: () => {
                            const finalTime = quizSecondsElapsed;
                            const completedState = {
                                ...quizState,
                                questions: newQuestions,
                                completed: true,
                                timeSpent: newTimeSpent
                            };
                            setQuizState(completedState);

                            if ((completedState as any).originId && (chatSessions as any)[(completedState as any).originId]) {
                                const updatedSession = {
                                    ...(chatSessions as any)[(completedState as any).originId],
                                    quizData: (completedState as any).questions,
                                    currentIndex: (completedState as any).currentIndex,
                                    score: (completedState as any).score,
                                    timeSpent: (completedState as any).timeSpent,
                                    completed: true,
                                    totalTime: finalTime,
                                    toolId: 'quiz_save',
                                    timestamp: new Date().toISOString(),
                                    attempts: completedState.attempts || 1 // Save attempts
                                };
                                persistSession(updatedSession);
                            }
                        }
                    }
                ]
            );
        }
    };

    const handlePreviousQuestion = () => {
        if (!quizState || quizState.currentIndex <= 0) return;
        const { newTimeSpent, now } = updateQuizTime(quizState.currentIndex);

        const newQuestions = [...quizState.questions];
        newQuestions[quizState.currentIndex].visited = true;

        setQuizState((prev: any) => ({
            ...prev,
            questions: newQuestions,
            currentIndex: prev.currentIndex - 1,
            timeSpent: newTimeSpent,
            activeQuestionStartTime: now
        }));
    };

    const jumpToQuestion = (targetIndex: number) => {
        if (!quizState || targetIndex === quizState.currentIndex) return;
        const { newTimeSpent, now } = updateQuizTime(quizState.currentIndex);

        const newQuestions = [...quizState.questions];
        newQuestions[quizState.currentIndex].visited = true;

        setQuizState((prev: any) => ({
            ...prev,
            questions: newQuestions,
            currentIndex: targetIndex,
            timeSpent: newTimeSpent,
            activeQuestionStartTime: now
        }));
    };

    const handleQuizOptionSelect = (questionIndex: number, optionIndex: number) => {
        const newQs = [...(quizState as any).questions];
        const currentQ = newQs[questionIndex];

        const previousSelection = currentQ.selected;
        const correctIndex = currentQ.correctOptionIndex;

        let newSelection = optionIndex;
        if (previousSelection === optionIndex) {
            newSelection = null as any;
        }

        currentQ.selected = newSelection;

        // Calculate Score Change with Negative Marking (-0.25 for wrong answers)
        const getContribution = (selection: number | null | undefined) => {
            if (selection === null || selection === undefined) return 0;
            return selection === correctIndex ? 1 : -0.25;
        };

        const oldContribution = getContribution(previousSelection);
        const newContribution = getContribution(newSelection);

        const newScore = quizState.score - oldContribution + newContribution;

        setQuizState((prev: any) => ({
            ...prev,
            questions: newQs,
            score: newScore
        }));
    };

    const handleRefreshDefinition = async (wordToRefresh: string) => {
        if (!wordToRefresh) return;

        const isModal = showWordModal;

        if (isModal) {
            setIsDefining(true);
            setWordData(null);
        } else {
            setIsDictionaryLoading(true);
            setDictionaryResult(null);
        }

        try {
            // Determine language: if modal, use local state; else use global
            const targetLang = isModal ? modalLanguage : displaySettings.language;

            // Force Fetch by calling API directly
            const data = await getDictionaryData(wordToRefresh, targetLang);

            // Prepare complete object ensuring word property exists
            const cleanData = { ...data, word: data.word || wordToRefresh };
            const completeData = {
                ...cleanData,
                language: targetLang,
                translations: { [targetLang]: cleanData }
            };

            if (!data.error) {
                const lower = wordToRefresh.trim().toLowerCase();

                // Update Runtime Cache
                setDictionaryCache((prev: any) => ({ ...prev, [lower]: completeData }));

                // Update History (Storage)
                setRecentSearches(prev => {
                    const filtered = (prev as any[]).filter(item => {
                        const w = typeof item === 'string' ? item : item.word;
                        return w.toLowerCase() !== lower;
                    });
                    // UPDATED: Use dynamic dictionaryLimit
                    const limit = displaySettingsRef.current.dictionaryLimit || 1000;
                    const updated = [{ word: completeData.word, data: completeData }, ...filtered].slice(0, limit);
                    AsyncStorage.setItem('recentSearches', JSON.stringify(updated));
                    return updated;
                });
            }

            if (isModal) {
                setWordData(completeData);
                setIsDefining(false);
            } else {
                setDictionaryResult(completeData);
                setIsDictionaryLoading(false);
            }
        } catch (e) {
            console.error("Refresh failed", e);
            const errorData = { error: "Could not refresh definition." };
            if (isModal) {
                setWordData(errorData);
                setIsDefining(false);
            } else {
                setDictionaryResult(errorData);
                setIsDictionaryLoading(false);
            }
        }
    };

    const deleteRecentSearch = (wordToDelete: string) => {
        Alert.alert(
            "Delete Word",
            `Remove "${wordToDelete}" from your personal dictionary?`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: 'destructive',
                    onPress: async () => {
                        const updated = recentSearches.filter(item => {
                            const w = typeof item === 'string' ? item : item.word;
                            return w.toLowerCase() !== wordToDelete.toLowerCase();
                        });
                        setRecentSearches(updated);
                        await saveRecentSearchesToFile(updated); // Update File
                    }
                }
            ]
        );
    };

    // ... (customVisionPrompts helper functions remain same)
    // NEW: Helper functions for custom vision prompts
    const addCustomVisionPrompt = async (prompt: string) => {
        if (customVisionPrompts.includes(prompt)) {
            Alert.alert("Exists", "Prompt already saved.");
            return;
        }
        const newPrompts = [...customVisionPrompts, prompt];
        setCustomVisionPrompts(newPrompts);
        await AsyncStorage.setItem('customVisionPrompts', JSON.stringify(newPrompts));
    };

    const removeCustomVisionPrompt = async (prompt: string) => {
        Alert.alert(
            "Delete Prompt",
            "Remove this prompt?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: "destructive",
                    onPress: async () => {
                        const newPrompts = customVisionPrompts.filter(p => p !== prompt);
                        setCustomVisionPrompts(newPrompts);
                        await AsyncStorage.setItem('customVisionPrompts', JSON.stringify(newPrompts));
                    }
                }
            ]
        );
    };

    const saveVisionPromptToHistory = async (prompt: string) => {
        if (!prompt || !prompt.trim()) return;
        const text = prompt.trim();
        // Remove existing to avoid duplicates, add to top
        const filtered = customVisionPrompts.filter(p => p !== text);
        const updated = [text, ...filtered].slice(0, 20); // Keep recent 20
        setCustomVisionPrompts(updated);
        await AsyncStorage.setItem('customVisionPrompts', JSON.stringify(updated));
    };

    // NEW: Generate Role from Profession (LLM)
    const handleGenerateRoleFromProfession = async () => {
        const profession = displaySettings.userProfession;

        if (!profession || !profession.trim()) {
            Alert.alert(
                "Profession Required",
                "To use Auto-Generate, please set your Profession in Settings > User Profile.",
                [
                    { text: "Cancel", style: "cancel" },
                    { text: "Open Settings", onPress: () => setActiveTab('settings') },
                    { text: "Create Manually", onPress: () => setShowRoleCreator(true) }
                ]
            );
            return;
        }

        setAppMode("generating");
        setGenerationData(`Designing AI Assistant for ${profession}...`);

        try {
            // NEW: Contextualize with existing roles to prevent duplicates and ensure progression
            const existingRolesSummary = (customTools as any[]).map(t => `- ${t.title} (Role: ${t.systemPrompt.substring(0, 50)}...)`).join('\n');

            const progressionInstruction = customTools.length > 0
                ? `
            EXISTING TEAM (Do NOT Duplicate):
            ${existingRolesSummary}
            
            EVOLUTION STRATEGY:
            The user already has the above assistants. You MUST create a **NEW** role that is:
            1. **Distinct**: Covers a completely different aspect of the profession (e.g., if 'Writer' exists, create 'Editor' or 'Researcher').
            2. **Advanced/Specialized**: Represents a higher level of expertise or specific niche (e.g., if 'Junior Dev' exists, create 'Senior Architect' or 'Security Auditor').
            3. **Complementary**: Fills a gap in the workflow.
            `
                : "Create the essential primary assistant for this profession.";

            const prompt = `Act as an Expert AI Persona Designer.
          User Profession: "${profession}"
          
          ${progressionInstruction}
          
          Task: Create a highly useful custom AI Role/Persona that would assist this user in their daily work.
          
          Return strictly a JSON Object with keys:
          - "title": Short title (max 15 chars, e.g. "Code Helper").
          - "instructions": System prompt describing the persona's behavior, tone, and expertise.
          - "icon": One of these exact strings: 'Bot', 'Code', 'PenLine', 'Globe', 'Briefcase', 'Lightbulb', 'Heart', 'Smile', 'Music', 'Rocket', 'Hammer', 'Wrench', 'Coffee', 'Utensils', 'Dumbbell', 'Gavel', 'Stethoscope', 'Calculator', 'Gamepad2', 'Clapperboard', 'Microscope', 'Megaphone', 'User', 'Plane'. Choose the most relevant.
          - "quickPrompts": An array of 6 objects { "label": "Short Label", "prompt": "Full prompt text" }.
          
          Output VALID JSON ONLY.`;

            const raw = await callLLM(prompt, "System Architect", true);

            if (raw.startsWith("Error")) {
                throw new Error(raw);
            }

            const clean = extractJSON(raw);
            const parsed = JSON.parse(clean);

            // Validation
            if (!parsed.title || !parsed.instructions) throw new Error("Invalid generation format");

            // Auto-assign color
            const colorIndex = customTools.length % AUTO_COLORS.length;
            const assignedColor = AUTO_COLORS[colorIndex];

            const newTool = {
                id: `custom_${generateId()}`,
                title: parsed.title.substring(0, 15),
                role: "Custom Role",
                type: "lesson",
                actionLabel: "Start",
                systemPrompt: parsed.instructions,
                placeholder: `Ask ${parsed.title}...`,
                color: assignedColor,
                iconName: ICON_MAP[parsed.icon] ? parsed.icon : 'Bot',
                isCustom: true,
                quickPrompts: Array.isArray(parsed.quickPrompts) ? parsed.quickPrompts.slice(0, 8) : []
            };

            const updatedTools = [...customTools, newTool];
            setCustomTools(updatedTools);
            await AsyncStorage.setItem('customTools', JSON.stringify(updatedTools));

            setAppMode("idle");
            Alert.alert("Success", `Created "${parsed.title}" to expand your team!`);

        } catch (e) {
            console.error("Auto-Role Gen Error", e);
            setAppMode("idle");
            Alert.alert("Error", "Could not auto-generate role. Try manual creation?", [
                { text: "Cancel", style: "cancel" },
                { text: "Create Manually", onPress: () => setShowRoleCreator(true) }
            ]);
        }
    };



    // NEW: Save Custom Quick Prompt (Unified for Roles and Quiz)
    const handleSaveCustomPrompt = async () => {
        // 1. Logic for Quiz Topics
        if (selectedScenario?.id === 'examiner') {
            if (!newPromptData.label.trim() || !newPromptData.prompt.trim()) {
                Alert.alert("Incomplete", "Please provide both a label and a prompt.");
                return;
            }

            const subject = (schoolConfig as any).subject || "General";
            const currentPrompts = (customSubjectPrompts as any)[subject] || SUBJECT_QUICK_PROMPTS[subject] || SUBJECT_QUICK_PROMPTS["General"] || [];

            // Prevent duplicates by label
            if (currentPrompts.some((p: any) => p.label.toLowerCase() === newPromptData.label.toLowerCase())) {
                Alert.alert("Exists", "A topic with this label already exists.");
                return;
            }

            const updatedPrompts = [...currentPrompts, newPromptData];

            setCustomSubjectPrompts((prev: any) => {
                const updated = { ...prev, [subject]: updatedPrompts };
                AsyncStorage.setItem('customSubjectPrompts', JSON.stringify(updated));
                return updated;
            });

            setShowPromptCreator(false);
            setNewPromptData({ label: "", prompt: "" });
            return;
        }

        // 2. Logic for Custom Roles
        if (selectedScenario?.isCustom) {
            if (!newPromptData.label.trim() || !newPromptData.prompt.trim()) {
                Alert.alert("Incomplete", "Please provide both a label and a prompt.");
                return;
            }

            const updatedTools = (customTools as any[]).map(t => {
                if (t.id === (selectedScenario as any).id) {
                    const existing = t.quickPrompts || [];
                    return { ...t, quickPrompts: [...existing, newPromptData] };
                }
                return t;
            });

            setCustomTools(updatedTools);
            await AsyncStorage.setItem('customTools', JSON.stringify(updatedTools));

            // Update the currently selected scenario reference so the UI updates immediately
            const updatedScenario = updatedTools.find(t => t.id === selectedScenario.id);
            setSelectedScenario(updatedScenario);

            setShowPromptCreator(false);
            setNewPromptData({ label: "", prompt: "" });
            return;
        }

        // 3. Logic for Standard Tools (NEW)
        if (selectedScenario) {
            if (!newPromptData.label.trim() || !newPromptData.prompt.trim()) {
                Alert.alert("Incomplete", "Please provide both a label and a prompt.");
                return;
            }

            setCustomToolPrompts((prev: any) => {
                const current = prev[selectedScenario.id] || [];
                if (current.some((p: any) => p.label === newPromptData.label)) {
                    Alert.alert("Exists", "Label already exists.");
                    return prev;
                }
                const updated = [...current, newPromptData];
                const newState = { ...prev, [selectedScenario.id]: updated };
                AsyncStorage.setItem('customToolPrompts', JSON.stringify(newState));
                return newState;
            });
            setShowPromptCreator(false);
            setNewPromptData({ label: "", prompt: "" });
        }
    };

    // NEW: Delete Custom Quick Prompt
    const handleDeleteCustomPrompt = async (promptLabel: string) => {
        // 1. Custom Roles
        if (selectedScenario?.isCustom) {
            Alert.alert(
                "Delete Prompt",
                `Remove "${promptLabel}"?`,
                [
                    { text: "Cancel", style: "cancel" },
                    {
                        text: "Delete",
                        style: "destructive",
                        onPress: async () => {
                            const updatedTools = customTools.map(t => {
                                if (t.id === selectedScenario.id) {
                                    const existing = t.quickPrompts || [];
                                    return { ...t, quickPrompts: existing.filter((p: any) => p.label !== promptLabel) };
                                }
                                return t;
                            });

                            setCustomTools(updatedTools);
                            await AsyncStorage.setItem('customTools', JSON.stringify(updatedTools));

                            const updatedScenario = updatedTools.find(t => t.id === selectedScenario.id);
                            setSelectedScenario(updatedScenario);
                        }
                    }
                ]
            );
            return;
        }

        // 2. Standard Tools
        if (selectedScenario) {
            Alert.alert(
                "Delete Prompt",
                `Remove "${promptLabel}"?`,
                [
                    { text: "Cancel", style: "cancel" },
                    {
                        text: "Delete",
                        style: "destructive",
                        onPress: async () => {
                            setCustomToolPrompts((prev: any) => {
                                const current = prev[selectedScenario.id] || [];
                                const updated = current.filter((p: any) => p.label !== promptLabel);
                                const newState = { ...prev, [selectedScenario.id]: updated };
                                AsyncStorage.setItem('customToolPrompts', JSON.stringify(newState));
                                return newState;
                            });
                        }
                    }
                ]
            );
        }
    };

    // NEW: Delete Quiz Topic
    const handleDeleteQuizTopic = async (label: string) => {
        const subject = schoolConfig.subject || "General";

        Alert.alert("Delete Topic", `Remove "${label}" from ${subject}?`, [
            { text: "Cancel", style: "cancel" },
            {
                text: "Delete",
                style: 'destructive',
                onPress: async () => {
                    const currentPrompts = customSubjectPrompts[subject] || SUBJECT_QUICK_PROMPTS[subject] || SUBJECT_QUICK_PROMPTS["General"] || [];
                    const updatedPrompts = currentPrompts.filter((p: any) => p.label !== label);

                    setCustomSubjectPrompts((prev: any) => {
                        const updated = { ...prev, [subject]: updatedPrompts };
                        AsyncStorage.setItem('customSubjectPrompts', JSON.stringify(updated));
                        return updated;
                    });
                }
            }
        ]);
    };

    // NEW: Delete Custom Tool
    const deleteCustomTool = async (id: string) => {
        Alert.alert(
            "Delete Role",
            "Remove this custom button?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: "destructive",
                    onPress: async () => {
                        // 1. Remove from Custom Tools List
                        const updatedCustomTools = customTools.filter(t => t.id !== id);
                        setCustomTools(updatedCustomTools);
                        await AsyncStorage.setItem('customTools', JSON.stringify(updatedCustomTools));

                        // 2. Manage Home Grid
                        let newHomeIds = [...homeToolIds];
                        const wasOnHome = newHomeIds.includes(id);

                        // Helper to find valid candidates from Studio (Standard + Custom)
                        // Excludes 'visual_learner' and items already on home
                        const getCandidates = (currentHomeList: any[]) => {
                            const allTools = [...SCHOOL_TOOLS, ...updatedCustomTools];
                            return allTools.filter(t =>
                                t.id !== 'visual_learner' &&
                                !currentHomeList.includes(t.id) &&
                                t.id !== id
                            );
                        };

                        if (wasOnHome) {
                            // Step A: Immediate Replacement (Swap in place to maintain order)
                            const candidates = getCandidates(newHomeIds);
                            const replacement = candidates.length > 0 ? candidates[0] : null;

                            if (replacement) {
                                newHomeIds = newHomeIds.map(currId => currId === id ? replacement.id : currId);
                            } else {
                                // No replacement available immediately, remove the slot
                                newHomeIds = newHomeIds.filter(currId => currId !== id);
                            }
                        }

                        // Step B: Auto-Fill Ragged Rows (The "Free Space" Logic)
                        // If the grid row is incomplete (e.g. 3 items in a 4-col grid), try to fill it.
                        const remainder = newHomeIds.length % 4;
                        if (remainder !== 0) {
                            const needed = 4 - remainder;
                            const fillCandidates = getCandidates(newHomeIds); // Re-fetch as Step A might have used one

                            // Take up to 'needed' items to complete the row
                            for (let i = 0; i < needed && i < fillCandidates.length; i++) {
                                newHomeIds.push(fillCandidates[i].id);
                            }
                        }

                        // 3. Save Changes
                        setHomeToolIds(newHomeIds);
                        await AsyncStorage.setItem('homeToolIds', JSON.stringify(newHomeIds));
                    }
                }
            ]
        );
    };

    useEffect(() => {
        const loadData = async () => {
            try {
                const storedSettings = await AsyncStorage.getItem('settings');
                if (storedSettings) {
                    const parsed = JSON.parse(storedSettings);

                    // ... (migration logic) ...
                    let family = parsed.fontFamily || "Modern";
                    let loadedCustomModel = parsed.customTextModel || "";
                    if (loadedCustomModel === "meta-llama/Meta-Llama-3-8B-Instruct") loadedCustomModel = "Qwen/Qwen2.5-72B-Instruct";
                    if (loadedCustomModel === "meta-llama/Llama-3.2-3B-Instruct") loadedCustomModel = "Qwen/Qwen2.5-72B-Instruct";
                    if (loadedCustomModel === "llama3-8b-8192") loadedCustomModel = "llama-3.1-8b-instant";

                    let loadedSavedModels = parsed.savedCustomModels || [];
                    loadedSavedModels = loadedSavedModels.map((m: string) =>
                        (m === "meta-llama/Meta-Llama-3-8B-Instruct" || m === "meta-llama/Llama-3.2-3B-Instruct") ? "Qwen/Qwen2.5-72B-Instruct" :
                            (m === "llama3-8b-8192" ? "llama-3.1-8b-instant" : m)
                    );

                    setDisplaySettings((prev: any) => ({
                        ...prev,
                        ...parsed,
                        customTextModel: loadedCustomModel,
                        savedCustomModels: loadedSavedModels,
                        preventSleep: parsed.preventSleep || false,
                        dictionaryLimit: parsed.dictionaryLimit || 10000,
                        libraryLimit: parsed.libraryLimit || 2000,
                        onlineTtsEnabled: parsed.onlineTtsEnabled !== undefined ? parsed.onlineTtsEnabled : true,
                        imageGenerationEnabled: parsed.imageGenerationEnabled !== undefined ? parsed.imageGenerationEnabled : true,
                        tapToDefine: parsed.tapToDefine !== undefined ? parsed.tapToDefine : true,
                        keepLabelsEnglish: parsed.keepLabelsEnglish !== undefined ? parsed.keepLabelsEnglish : false,
                        userName: parsed.userName || "",
                        userProfession: parsed.userProfession || "",
                        userGoal: parsed.userGoal || "",
                        userBio: parsed.userBio || "",
                        nameLocked: parsed.nameLocked || false,
                        isOnboarded: parsed.isOnboarded || false,
                        smartBio: parsed.smartBio || ""
                    }));
                }
                setIsSettingsLoaded(true);

                const storedKey = await AsyncStorage.getItem('apiKey');
                if (storedKey) setCustomApiKey(storedKey);

                // NEW: Load Quiz History Tracking
                try {
                    const historyJson = await AsyncStorage.getItem('quiz_history_tracking');
                    if (historyJson) {
                        const history = JSON.parse(historyJson);
                        const now = Date.now();
                        const TEN_DAYS = 10 * 24 * 60 * 60 * 1000;

                        const cleanHistory: any = {};
                        let changed = false;

                        // Prune entries older than 10 days
                        Object.keys(history).forEach((key: string) => {
                            if (history[key].timestamp && (now - history[key].timestamp < TEN_DAYS)) {
                                cleanHistory[key] = history[key];
                            } else {
                                changed = true; // Mark for save if we dropped items
                            }
                        });

                        quizHistoryRef.current = cleanHistory;

                        if (changed) {
                            AsyncStorage.setItem('quiz_history_tracking', JSON.stringify(cleanHistory));
                        }
                    }
                } catch (historyErr) {
                    console.warn("Quiz History Load Error", historyErr);
                }

                // --- DICTIONARY MIGRATION & LOADING LOGIC ---
                const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                const indexUri = docDir + 'dictionary_index.json';
                let wordsList = [];
                let loadedFromFile = false;

                // 1. Try loading Index from File System (Unlimited Size)
                try {
                    const fileInfo = await fs.getInfoAsync(indexUri);
                    if (fileInfo.exists) {
                        const content = await fs.readAsStringAsync(indexUri);
                        wordsList = JSON.parse(content);
                        loadedFromFile = true;
                    }
                } catch (e: any) { console.warn("Index load failed", e); }

                // 2. If file missing, check AsyncStorage (Migration from DB to File)
                if (!loadedFromFile) {
                    // Check Legacy Monolithic Data
                    const legacyWordsJson = await AsyncStorage.getItem('savedWords');
                    if (legacyWordsJson) {
                        try {
                            const legacyWords = JSON.parse(legacyWordsJson);
                            console.log(`Migrating ${legacyWords.length} words to file system...`);

                            const newIndex: any[] = [];

                            // Migrate each word to a file
                            await Promise.all(legacyWords.map(async (wordObj: any) => {
                                const id = wordObj.id || generateId();
                                const fileName = `word_${id}.json`;

                                // Ensure ID exists in object
                                const fullData = { ...wordObj, id };

                                // Save Full Data to File
                                await fs.writeAsStringAsync(docDir + fileName, JSON.stringify(fullData));

                                // Create Lite Entry for Index
                                newIndex.push({
                                    id: id,
                                    word: wordObj.word,
                                    definition: wordObj.definition || wordObj.simple?.definition || "Definition available",
                                    partOfSpeech: wordObj.partOfSpeech,
                                    forms: wordObj.forms || [],
                                    timestamp: wordObj.timestamp || new Date().toISOString()
                                });
                            }));

                            wordsList = newIndex;
                            // Save new index to FILE
                            await fs.writeAsStringAsync(indexUri, JSON.stringify(newIndex));

                            // Remove legacy key
                            await AsyncStorage.removeItem('savedWords');
                            console.log("Dictionary migration complete.");

                        } catch (e: any) {
                            console.error("Dictionary Migration Failed", e);
                            wordsList = JSON.parse(legacyWordsJson); // Fallback to memory
                        }
                    } else {
                        // Initialize with 10 default words for new users
                        const newIndex: any[] = [];

                        await Promise.all(DEFAULT_VOCABULARY.map(async (w: any) => {
                            const id = generateId();
                            const fullData = {
                                ...w,
                                id,
                                timestamp: new Date().toISOString(),
                                examples: w.simple?.examples || [],
                                translations: { "English": w }
                            };

                            await fs.writeAsStringAsync(docDir + `word_${id}.json`, JSON.stringify(fullData));

                            newIndex.push({
                                id,
                                word: w.word,
                                definition: w.definition,
                                partOfSpeech: w.partOfSpeech,
                                forms: [],
                                timestamp: fullData.timestamp
                            });
                        }));

                        wordsList = newIndex;
                        await fs.writeAsStringAsync(indexUri, JSON.stringify(newIndex));
                    }
                }
                setSavedWords(wordsList);
                // --- END DICTIONARY LOGIC ---

                const storedQuestions = await AsyncStorage.getItem('savedQuestions');
                if (storedQuestions) setSavedQuestions(JSON.parse(storedQuestions));

                // NEW: Load saved table widths
                const storedTableWidths = await AsyncStorage.getItem('savedTableWidths');
                if (storedTableWidths) savedTableWidths.current = JSON.parse(storedTableWidths);

                const storedSubjects = await AsyncStorage.getItem('availableSubjects');
                if (storedSubjects) {
                    const parsed: string[] = JSON.parse(storedSubjects);
                    // Migration: Ensure English, Reasoning, and Basic Computer are present for legacy users
                    const missingDefaults = ['English', 'Reasoning', 'Basic Computer'].filter(s => !parsed.includes(s));
                    if (missingDefaults.length > 0) {
                        // Insert them after 'General' or at the start
                        const generalIdx = parsed.indexOf('General');
                        const insertPos = generalIdx !== -1 ? generalIdx + 1 : 0;
                        parsed.splice(insertPos, 0, ...missingDefaults);

                        parsed.sort((a, b) => a.localeCompare(b)); // Sort alphabetically
                        setAvailableSubjects(parsed);
                        AsyncStorage.setItem('availableSubjects', JSON.stringify(parsed));
                    } else {
                        parsed.sort((a, b) => a.localeCompare(b)); // Sort alphabetically
                        setAvailableSubjects(parsed);
                    }
                }

                // NEW: Load Quiz Settings (schoolConfig)
                const storedSchoolConfig = await AsyncStorage.getItem('schoolConfig');
                if (storedSchoolConfig) {
                    try {
                        const parsed = JSON.parse(storedSchoolConfig);
                        setSchoolConfig((prev: any) => ({
                            ...prev,
                            ...parsed,
                            input: "" // Keep topic input fresh on each session
                        }));
                    } catch (e) {
                        console.warn("Failed to parse schoolConfig", e);
                    }
                }

                // NEW: Load last quiz subject preference
                const storedLastSubject = await AsyncStorage.getItem('lastQuizSubject');
                if (storedLastSubject) {
                    setLastQuizSubject(storedLastSubject);
                }

                // NEW: Load custom vision prompts
                const storedCustomPrompts = await AsyncStorage.getItem('customVisionPrompts');
                if (storedCustomPrompts) setCustomVisionPrompts(JSON.parse(storedCustomPrompts));

                // NEW: Load custom subject prompts
                const storedSubjectPrompts = await AsyncStorage.getItem('customSubjectPrompts');
                if (storedSubjectPrompts) setCustomSubjectPrompts(JSON.parse(storedSubjectPrompts));

                // NEW: Load custom standard tool prompts
                const storedToolPrompts = await AsyncStorage.getItem('customToolPrompts');
                if (storedToolPrompts) setCustomToolPrompts(JSON.parse(storedToolPrompts));

                // NEW: Load custom tools
                const storedCustomTools = await AsyncStorage.getItem('customTools');
                let loadedCustomTools = [];
                if (storedCustomTools) {
                    loadedCustomTools = JSON.parse(storedCustomTools);
                    setCustomTools(loadedCustomTools);
                }

                // NEW: Load Home Grid Configuration
                const storedHomeIds = await AsyncStorage.getItem('homeToolIds');
                if (storedHomeIds) {
                    setHomeToolIds(JSON.parse(storedHomeIds));
                } else {
                    // Default configuration based on user request (Top 2 Rows)
                    const priorityIds = [
                        'writer',
                        'examiner',
                        'email_pro',
                        'editorial_writer',
                        'summarizer',
                        'word_help',
                        'health_guide',
                        'visual_learner'
                    ];

                    // Apps hidden by default (accessible via Studio)
                    // 'visual_learner' removed from hidden as it's now in priority
                    const hiddenIds = [
                        'ai_usage',
                        'ai_for_everyone',
                        'prompt_engineer',
                        'ml_tutor',
                        'tech_guide'
                    ];

                    // Get any other tools that are not in priority and not hidden
                    const otherIds = SCHOOL_TOOLS
                        .filter(t => !priorityIds.includes(t.id) && !hiddenIds.includes(t.id))
                        .map(t => t.id);

                    setHomeToolIds([...priorityIds, ...otherIds]);
                }

                // CRASH RECOVERY & MIGRATION: Load recentSearches from FileSystem
                // If FileSystem is empty, try migrating from AsyncStorage
                // If AsyncStorage fails (CursorWindow error), start fresh
                let loadedSearches = null;

                // Step 1: Try loading from FileSystem first
                loadedSearches = await loadRecentSearchesFromFile();

                if (!loadedSearches) {
                    // Step 2: FileSystem is empty, try migrating from AsyncStorage
                    try {
                        const storedRecentSearches = await AsyncStorage.getItem('recentSearches');
                        if (storedRecentSearches) {
                            const parsed = JSON.parse(storedRecentSearches);
                            // Migration: Convert old string array to object array if needed
                            if (Array.isArray(parsed) && parsed.length > 0 && typeof parsed[0] === 'string') {
                                loadedSearches = parsed.map(w => ({ word: w, data: null }));
                            } else {
                                loadedSearches = parsed;
                            }

                            // Save to FileSystem and remove from AsyncStorage
                            await saveRecentSearchesToFile(loadedSearches);
                            await AsyncStorage.removeItem('recentSearches');
                            console.log("âœ… Migrated recentSearches from AsyncStorage to FileSystem");
                        }
                    } catch (asyncStorageError) {
                        // CRASH RECOVERY: If AsyncStorage read fails (e.g., CursorWindow error)
                        console.error("âš ï¸ Failed to load recentSearches from AsyncStorage (likely too big):", asyncStorageError);

                        // Try to delete the corrupt key to prevent future crashes
                        try {
                            await AsyncStorage.removeItem('recentSearches');
                            console.log("ðŸ—‘ï¸ Removed corrupt recentSearches from AsyncStorage");
                        } catch (removeError) {
                            console.error("Failed to remove corrupt key:", removeError);
                        }

                        // Start fresh with default vocabulary
                        loadedSearches = null;
                    }
                }

                // Step 3: Set state (either loaded data or default vocabulary)
                // Step 3: Set state (either loaded data or default vocabulary)
                if (loadedSearches && loadedSearches.length > 0) {
                    setRecentSearches(loadedSearches);
                    recentSearchesRef.current = loadedSearches; // SYNC REFERENCE
                } else {
                    // NEW: Initialize recentSearches with DEFAULT_VOCABULARY for new users
                    const defaultRecents = DEFAULT_VOCABULARY.map(w => ({
                        word: w.word,
                        data: {
                            ...w,
                            translations: { "English": w }
                        }
                    }));
                    setRecentSearches(defaultRecents);
                    recentSearchesRef.current = defaultRecents; // SYNC REFERENCE
                    await saveRecentSearchesToFile(defaultRecents);
                }

                let legacySessions: Record<string, any> = {};
                try {
                    const legacy = await AsyncStorage.getItem('chatSessions');
                    if (legacy) {
                        legacySessions = JSON.parse(legacy);
                        const keys = Object.keys(legacySessions);
                        const pairs = keys.map(id => [`session_${id}`, JSON.stringify(legacySessions[id])]);
                        await AsyncStorage.multiSet(pairs as [string, string][]);

                        const existingIndexJson = await AsyncStorage.getItem('session_index');
                        let existingIndex = existingIndexJson ? JSON.parse(existingIndexJson) : [];
                        const newIndex: any[] = [...new Set([...existingIndex, ...keys])];
                        await AsyncStorage.setItem('session_index', JSON.stringify(newIndex));

                        await AsyncStorage.removeItem('chatSessions');
                        console.log("Migration successful: chatSessions split into individual keys.");

                        // CLEAR LEGACY FROM MEMORY: Force reload via split logic to respect pagination
                        legacySessions = {};
                    }
                } catch (legacyError) {
                    console.error("Legacy Migration Failed (likely Row too big):", legacyError);
                    Alert.alert("Data Error", "Could not migrate old data. It may be too large.");
                }

                let splitSessions: Record<string, any> = {};
                const corruptKeys: string[] = []; // NEW: Track bad keys
                try {
                    try {
                        // STRATEGY: Monolithic Metadata Index (Dictionary Style)
                        // Goal: <1s load time for 1000 items.
                        // We try to load a single JSON file containing ALL session metadata.

                        const metaIndexJson = await AsyncStorage.getItem('library_metadata_index');
                        if (metaIndexJson) {
                            const metaMap = JSON.parse(metaIndexJson);
                            // VALIDATION: Ensure it's a map/object
                            if (metaMap && typeof metaMap === 'object' && !Array.isArray(metaMap)) {

                                // NEW: Verify Index Integrity (Fix for "Ghost" Data)
                                // If we have a session_index, check if counts match roughly.
                                // If metadata is missing items that exist in session_index, we MUST rebuild.
                                const masterIndexJson = await AsyncStorage.getItem('session_index');
                                const masterIndex = masterIndexJson ? JSON.parse(masterIndexJson) : [];
                                const metaKeys = Object.keys(metaMap);

                                // Tolerance: If we have significantly more items in master than metadata, assume stale.
                                // (Master might have 105, Meta 100 - acceptable if 5 were just deleted?) 
                                // Actually, NO. Master is truth. If Master > Meta, we are missing data in UI.
                                if (masterIndex.length > metaKeys.length) {
                                    console.log(`âš ï¸ Index Desync Detected: Master (${masterIndex.length}) > Meta (${metaKeys.length}). Forcing Rebuild.`);
                                    // Throw error to trigger catch block -> fallback crawl
                                    throw new Error("Index Desync");
                                }

                                console.log("âš¡ Instant Load: Loaded library from metadata index.");
                                const ids = metaKeys;
                                // Sort by recent first (Ids are chronological or timestamps are separate)
                                // We can use the 'lastOpened' or 'timestamp' from metadata to sort accurately
                                ids.sort((a, b) => {
                                    const ta = metaMap[a].lastOpened || metaMap[a].timestamp;
                                    const tb = metaMap[b].lastOpened || metaMap[b].timestamp;
                                    return new Date(tb).getTime() - new Date(ta).getTime();
                                });

                                setAllSessionIds(ids);
                                setChatSessions(metaMap);
                                setLoadedSessionCount(ids.length);
                                return; // EXIT: Success!
                            }
                        }

                        // FALLBACK / MIGRATION: No Index Found (First run or post-restore)
                        // We must crawl all individual keys to build the index.
                    } catch (metaCheckError) {
                        console.log("âš ï¸ Metadata Index check failed (Desync/Error). Proceeding to crawl...", metaCheckError);
                    }

                    // FALLBACK / MIGRATION: No Index Found (First run or post-restore)
                    // We must crawl all individual keys to build the index.
                    console.log("Starting migration crawl...");
                    try {
                        const indexJson = await AsyncStorage.getItem('session_index');
                        if (indexJson) {
                            const ids = JSON.parse(indexJson);
                            if (Array.isArray(ids)) {
                                // Reverse to prioritize newest, but we will load ALL eventually
                                const reversedIds = [...ids].reverse();
                                setAllSessionIds(reversedIds);

                                // Crawler Config
                                const BATCH_SIZE = 12; // Keep safe for Android CursorWindow
                                let fullMetadataMap: Record<string, any> = {};

                                console.log(`Crawl Started: Index contains ${reversedIds.length} items. Fetching in batches...`);

                                for (let i = 0; i < reversedIds.length; i += BATCH_SIZE) {
                                    const batchIds = reversedIds.slice(i, i + BATCH_SIZE);
                                    const batchKeys = batchIds.map(id => `session_${id}`);

                                    try {
                                        const chunks = await AsyncStorage.multiGet(batchKeys);
                                        let batchSuccessCount = 0;
                                        chunks.forEach(([key, value]) => {
                                            if (value) {
                                                try {
                                                    const id = key.replace('session_', '');
                                                    const liteSession = parseSessionLite(value);
                                                    if (liteSession) {
                                                        fullMetadataMap[id] = liteSession;
                                                        batchSuccessCount++;
                                                    }
                                                } catch (parseError) {
                                                    console.error(`Corrupt session JSON for key ${key}:`, parseError);
                                                }
                                            }
                                        });
                                        // console.log(`Batch ${i} loaded: ${batchSuccessCount} items.`);

                                        // Incremental Update (Visual Progress)
                                        setChatSessions((prev: any) => ({ ...prev, ...fullMetadataMap }));

                                        // Yield to UI
                                        await new Promise(resolve => setTimeout(resolve, 10));

                                    } catch (batchError) {
                                        console.error("Error loading batch:", batchError);
                                    }
                                }

                                // FINISH: Save the newly built index for next time
                                if (Object.keys(fullMetadataMap).length > 0) {
                                    await AsyncStorage.setItem('library_metadata_index', JSON.stringify(fullMetadataMap));
                                    console.log("âœ… Migration Complete: Saved NEW library_metadata_index.");
                                } else {
                                    console.warn("âš ï¸ Migration finished but no items loaded. Index might be empty.");
                                }
                                setLoadedSessionCount(reversedIds.length);
                            }
                        }
                    } catch (crawlError) {
                        console.error("Crawl logic failed:", crawlError);
                    }

                } catch (e) {
                    console.error("General Load Error:", e);
                    Alert.alert("Load Error", "There was an issue loading your data.");
                }
            } catch (err) {
                console.error("Critical Data Load Error:", err);
            }
        };
        loadData();
    }, []);

    // Pagination Removed: loadMoreSessions & loadMoreLibrary deleted.








    // NEW: Helper to exit quiz mode cleanly (Shared logic)
    const exitQuizMode = () => {
        if (navOrigin === 'setup') {
            setAppMode('setup');
        } else if (navOrigin === 'reader') {
            setAppMode('reader');
        } else {
            setAppMode('idle');
        }
        setQuizState(null);
        setShowReferenceText(false);
    };

    // NEW: Auto-Submit Logic for Exam Mode
    // UPDATED: Added isManual parameter to distinguish between user actions and background triggers
    const handleAutoSubmitExam = async (shouldExitToHome = false, isManual = false) => {
        // Use direct state if available (fresher in render cycle), fallback to ref
        const currentQState = quizState || quizStateRef.current;

        // If no active quiz or already completed, just exit if requested
        if (!currentQState || currentQState.completed) {
            if (shouldExitToHome) exitQuizMode();
            return;
        }

        // Mark as completed in memory - Ensure new object reference
        const completedState = {
            ...currentQState,
            completed: true,
            // Flag as auto-submitted ONLY if it's NOT a manual user action
            autoSubmitted: !isManual
        };

        // Update UI to show results immediately (Critical step)
        setQuizState(completedState);

        // Persist to Storage in background
        const saveProcess = async () => {
            const originId = completedState.originId;
            let sessionToSave = null;

            if (originId && chatSessionsRef.current && chatSessionsRef.current[originId]) {
                // Normal case: Update existing session
                sessionToSave = {
                    ...chatSessionsRef.current[originId],
                    id: originId,
                    quizData: completedState.questions,
                    currentIndex: completedState.currentIndex,
                    score: completedState.score,
                    timeSpent: completedState.timeSpent,
                    completed: true,
                    totalQuestions: completedState.questions.length,
                    totalTime: quizSecondsElapsedRef.current,
                    toolId: 'quiz_save',
                    timestamp: new Date().toISOString(),
                    attempts: completedState.attempts || 1,
                    isExamMode: true,
                    autoSubmitted: !isManual,
                    modeLocked: completedState.modeLocked || false
                };
            } else if (originId) {
                // Fallback
                sessionToSave = {
                    id: originId,
                    title: completedState.title || "Quiz Result",
                    toolId: 'quiz_save',
                    timestamp: new Date().toISOString(),
                    quizData: completedState.questions,
                    currentIndex: completedState.currentIndex,
                    score: completedState.score,
                    completed: true,
                    totalTime: quizSecondsElapsedRef.current,
                    attempts: completedState.attempts || 1,
                    isExamMode: true,
                    autoSubmitted: !isManual,
                    messages: [{ role: "ai", content: "Interactive Quiz Result" }],
                    language: displaySettings.language
                };
            }

            if (sessionToSave) {
                if (persistSessionRef.current) {
                    await persistSessionRef.current(sessionToSave);
                } else {
                    await persistSession(sessionToSave);
                }
            }
        };

        // Execute save
        await saveProcess();

        if (shouldExitToHome) {
            exitQuizMode();
            showToast("Exam Submitted");
        } else {
            // Stay on screen (Result View)
            if (isManual) {
                // Feedback provided visually by screen change
            } else {
                console.log("Exam auto-submitted due to app switch");
            }
        }
    };

    // NEW: Keep Handler Ref Updated (Fixes Stale Closure in Listener)
    useEffect(() => {
        handleAutoSubmitExamRef.current = handleAutoSubmitExam;
    }, [handleAutoSubmitExam]);

    // NEW: AppState Listener for Background Detection (Auto-Submit)
    useEffect(() => {
        const subscription = AppState.addEventListener('change', nextAppState => {
            if (nextAppState.match(/inactive|background/)) {
                // Check if in active Exam Mode and not yet completed
                const currentQ = quizStateRef.current;
                // We check against the ref to get the latest state without re-binding the listener
                if (currentQ?.isExamMode && !currentQ?.completed) {
                    console.log("Auto-submitting exam due to background switch");
                    // Passed false for isManual to trigger "Action Detected" warning
                    // UPDATED: Use Ref to call the latest handler function
                    if (handleAutoSubmitExamRef.current) {
                        handleAutoSubmitExamRef.current(false, false);
                    }
                }
            }
        });
        return () => subscription.remove();
    }, []);

    const saveCurrentQuizProgress = async () => {
        if (!quizState || !quizState.originId) return;

        const existingSession = chatSessions[quizState.originId] || {};

        const updatedSession = {
            ...existingSession,
            id: quizState.originId,
            quizData: quizState.questions,
            currentIndex: quizState.currentIndex,
            score: quizState.score,
            timeSpent: quizState.timeSpent,
            completed: quizState.completed,
            totalTime: quizSecondsElapsed,
            toolId: 'quiz_save',
            timestamp: new Date().toISOString(),
            attempts: quizState.attempts || 1,
            isExamMode: quizState.isExamMode,
            modeLocked: quizState.modeLocked,
            autoSubmitted: quizState.autoSubmitted || false // NEW: Persist flag
        };

        if (!updatedSession.title) updatedSession.title = quizState.title || "Quiz";

        await persistSession(updatedSession);
    };

    const closeQuizSession = async () => {
        // UPDATED: Strict Exam Mode Handling for Close Button
        if (quizState?.isExamMode && !quizState.completed) {
            // If closing an active Exam, treat as submission
            Alert.alert(
                "Submit Exam?",
                "Closing the quiz in Exam Mode will submit your current score.",
                [
                    { text: "Cancel", style: "cancel" },
                    // CHANGED: Pass 'true' for isManual so it doesn't trigger the cheat warning
                    { text: "Submit & Exit", onPress: () => handleAutoSubmitExam(false, true) }
                ]
            );
        } else {
            // Practice Mode or Completed: Just save and close
            await saveCurrentQuizProgress();
            exitQuizMode();
        }
    };

    // NEW: Helper to discard changes
    const discardNoteChanges = () => {
        setIsEditingNote(false);
        setCurrentNoteInput("");
        setCurrentNoteTitle("");
        setCurrentNoteSummary("");
        setCurrentNoteId(null);
        setCurrentNoteImages([]);
        setCustomNotePrompt("");
        resetHistory(""); // Reset history
    };

    // NEW: Helper to confirm closing
    const confirmCloseNote = () => {
        if (!currentNoteInput.trim() && currentNoteImages.length === 0) {
            discardNoteChanges();
            return;
        }
        setShowUnsavedChangesModal(true);
    };

    useEffect(() => {
        const backAction = () => {
            if (showWordModal) { setShowWordModal(false); return true; }
            if (showHistory) { setShowHistory(false); return true; }
            if (showAppearance) { setShowAppearance(false); return true; }
            if (showImageSourceModal) { setShowImageSourceModal(false); return true; }
            if (showVisionDraft) { setShowVisionDraft(false); return true; }
            if (showUnsavedChangesModal) { setShowUnsavedChangesModal(false); return true; } // Handle back press on new modal

            if (appMode === 'setup') {
                setAppMode('idle');
                return true;
            }

            if (appMode === 'live') {
                closeQuizSession();
                return true;
            }

            if (appMode === 'reader') {
                // UPDATED: Handle Minimized Session on Back Press
                if (minimizedSession) {
                    // FIX: Restore the minimized session and clear the minimized slot (Pop behavior)
                    // Previously it swapped, creating an infinite loop. Now it closes the top layer.
                    setReadingSession(minimizedSession);
                    setMinimizedSession(null);
                    return true;
                }

                // UPDATED: Do NOT stop TTS on back press to allow background play
                // stopTTS(); 

                // IMPROVEMENT: Logic to return to setup if that was origin
                if (navOrigin === 'setup') {
                    setAppMode('setup');
                } else {
                    // For 'vision' origin or 'idle' origin, just go back to idle (Home/Studio)
                    setAppMode("idle");
                }
                return true;
            }

            if (appMode === 'generating') {
                setAppMode("idle");
                return true;
            }

            if (appMode === 'idle' && (activeTab === 'library' || activeTab === 'notes' || activeTab === 'dictionary' || activeTab === 'story' || activeTab === 'settings' || activeTab === 'studio')) {
                if (activeTab === 'notes') {
                    if (isEditingNote) {
                        // CHANGED: Use confirmation instead of direct discard
                        confirmCloseNote();
                        return true;
                    }

                    // NEW: Handle Selection Mode Back Press
                    if (isSelectionMode) {
                        setIsSelectionMode(false);
                        setSelectedNoteIds([]);
                        return true;
                    }
                }

                if (activeTab === 'library') {
                    if (isLibrarySelectionMode) {
                        setIsLibrarySelectionMode(false);
                        setSelectedLibraryIds([]);
                        return true;
                    }
                }


                setActiveTab('home');
                return true;
            }

            return false;
        };

        const backHandler = BackHandler.addEventListener(
            "hardwareBackPress",
            backAction
        );

        return () => backHandler.remove();
    }, [appMode, activeTab, showWordModal, showHistory, showAppearance, dictionaryResult, isEditingNote, showImageSourceModal, showVisionDraft, quizState, currentNoteInput, currentNoteTitle, currentNoteId, navOrigin, currentNoteImages, minimizedSession, showUnsavedChangesModal, isSelectionMode, isLibrarySelectionMode]);

    // OPTIMIZATION: Memoize the Hash Map generation to prevent re-calculation on every file load
    // This runs only when chatSessions change, which is much less frequent than file I/O
    const ttsHashMap = useMemo(() => {
        const map: any = {};
        if (!chatSessions) return map;

        // Unified Chunk Limit (User requested to keep only 3000)
        const CHUNK_LIMIT = 3000;

        (Object.values(chatSessions) as any[]).forEach((session: any) => {
            if (session.messages && session.messages[0]) {
                const text = session.messages[0].content;
                const cleanText = cleanTextForDisplay(text);

                // Use session-specific voice if available, otherwise fallback to global
                const voice = session.voice || displaySettings.voice || "Kore";

                // 1. Hash for MERGED file (Full Text)
                const fullHash = simpleHash(cleanText + voice);
                map[fullHash] = { title: session.title, id: session.id, isMerged: true };

                // 2. Hash for CHUNKS (Only 3000 limit as requested)
                let currentChunk = "";
                const chunks = [];
                const lines = cleanText.split('\n');

                for (let i = 0; i < lines.length; i++) {
                    const isLast = i === lines.length - 1;
                    const lineBlock = lines[i] + (isLast ? "" : "\n");
                    if ((currentChunk + lineBlock).length <= CHUNK_LIMIT) {
                        currentChunk += lineBlock;
                    } else {
                        if (currentChunk.length > 0) chunks.push(currentChunk);
                        currentChunk = lineBlock;
                    }
                }
                if (currentChunk.length > 0) chunks.push(currentChunk);

                chunks.forEach((chunk, idx) => {
                    const chunkHash = simpleHash(chunk + voice);
                    map[chunkHash] = { title: session.title, id: session.id, part: idx + 1, total: chunks.length, isMerged: false };
                });
            }
        });
        return map;
    }, [chatSessions, displaySettings.voice]); // Re-run if sessions or global voice changes

    // NEW: Function to load audio files from file system for the Audio Tab
    const loadAudioFiles = useCallback(async () => {
        setIsAudioLoading(true);
        try {
            const docDir = (fs.documentDirectory || FileSystem.documentDirectory) || "";
            const files = await fs.readDirectoryAsync(docDir);
            const ttsFiles = files.filter(f => f.startsWith('tts_') && f.endsWith('.wav'));

            // Use the MEMOIZED hash map instead of rebuilding it here
            const hashMap = ttsHashMap;

            const fileDataPromises = ttsFiles.map(async (filename) => {
                const uri = docDir + filename;
                const info = await fs.getInfoAsync(uri);

                const rawName = filename.replace('.wav', '');
                const parts = rawName.split('_');

                const hash = parts[1];
                let fileTitle = null;

                if (parts.length > 2) {
                    // NEW: Smarter reconstruction to preserve "Book: Chapter" structure from filenames
                    const titleParts = parts.slice(2);
                    let reconstructed = "";

                    for (let i = 0; i < titleParts.length; i++) {
                        const p = titleParts[i];
                        if (p === "") {
                            if (reconstructed.length > 0 && !reconstructed.endsWith(": ")) {
                                reconstructed = reconstructed.trim() + ": ";
                            }
                        } else {
                            reconstructed += p + " ";
                        }
                    }
                    fileTitle = reconstructed.trim();
                }

                const match = (hashMap as any)[hash];
                const displayTitle = match ? match.title : (fileTitle || "Unknown Recording");

                return {
                    id: filename,
                    uri: uri,
                    filename: filename,
                    size: (info as any).size,
                    modificationTime: (info as any).modificationTime || Date.now() / 1000,
                    matchedTitle: displayTitle,
                    sessionId: match ? match.id : null,
                    partInfo: match && match.total > 1 && !match.isMerged ? `Part ${match.part}` : null,
                    partIndex: match ? match.part : 0,
                    isMerged: match ? match.isMerged : false
                };
            });

            const rawFiles = await Promise.all(fileDataPromises);

            const groups: any = {};
            const ungrouped: any[] = [];

            rawFiles.forEach(file => {
                if (file.sessionId) {
                    if (!groups[file.sessionId]) {
                        groups[file.sessionId] = {
                            id: file.sessionId,
                            isGroup: true,
                            title: file.matchedTitle,
                            files: [],
                            totalSize: 0,
                            modificationTime: 0,
                            sessionId: file.sessionId,
                            matchedTitle: file.matchedTitle
                        };
                    }
                    groups[file.sessionId].files.push(file);
                    groups[file.sessionId].totalSize += file.size;
                    if (file.modificationTime > groups[file.sessionId].modificationTime) {
                        groups[file.sessionId].modificationTime = file.modificationTime;
                    }
                } else {
                    ungrouped.push(file);
                }
            });

            // Sort files within groups (Merged files first, then chunks)
            Object.values(groups).forEach((group: any) => {
                group.files.sort((a: any, b: any) => {
                    if (a.isMerged && !b.isMerged) return -1;
                    if (!a.isMerged && b.isMerged) return 1;
                    return a.partIndex - b.partIndex;
                });

                // If group contains a merged file, hide the chunks to avoid duplication in playback
                if (group.files.some((f: any) => f.isMerged)) {
                    group.files = group.files.filter((f: any) => f.isMerged);
                }
            });

            const groupedList = Object.values(groups);

            // --- NEW: Group by Book Title & Sort Ascending ---
            const bookGroups: any = {};
            const standaloneAudio: any[] = [];

            // Helper to get title
            const getTitle = (item: any) => item.matchedTitle || "Unknown";

            (groupedList.concat(ungrouped) as any[]).forEach((item: any) => {
                const title = getTitle(item);
                const sepIdx = title.indexOf(':');

                if (sepIdx > 0) {
                    const bookTitle = title.substring(0, sepIdx).trim();
                    if (!bookGroups[bookTitle]) {
                        bookGroups[bookTitle] = {
                            id: `book_audio_${simpleHash(bookTitle)}`,
                            title: bookTitle,
                            isBook: true,
                            chapters: [],
                            totalSize: 0,
                            modificationTime: 0
                        };
                    }
                    bookGroups[bookTitle].chapters.push(item);
                    bookGroups[bookTitle].totalSize += (item.totalSize || item.size);
                    // Keep latest time
                    if (item.modificationTime > bookGroups[bookTitle].modificationTime) {
                        bookGroups[bookTitle].modificationTime = item.modificationTime;
                    }
                } else {
                    standaloneAudio.push(item);
                }
            });

            const finalAudioList = [];

            // Sort Book Groups A-Z
            const sortedBooks = Object.values(bookGroups).sort((a: any, b: any) => a.title.localeCompare(b.title));

            sortedBooks.forEach((book: any) => {
                // Sort Chapters A-Z (or try to detect number)
                book.chapters.sort((a: any, b: any) => {
                    const tA = getTitle(a);
                    const tB = getTitle(b);
                    return tA.localeCompare(tB, undefined, { numeric: true, sensitivity: 'base' });
                });
                finalAudioList.push(book);
            });

            // Sort Standalone A-Z
            standaloneAudio.sort((a: any, b: any) => getTitle(a).localeCompare(getTitle(b), undefined, { numeric: true, sensitivity: 'base' }));

            finalAudioList.push(...standaloneAudio);

            setAudioFiles(finalAudioList);

        } catch (e) {
            console.error("Error loading audio files", e);
        } finally {
            setIsAudioLoading(false);
        }
    }, [chatSessions, displaySettings.voice]);

    // NEW: Helper to play next file in the active queue (Multi-part support)
    const playNextInQueue = async (explicitId: number | null = null) => {
        // Use explicit ID if passed (new request), otherwise use current (internal continuation)
        const currentId = explicitId !== null ? explicitId : audioPlaybackId.current;

        // Check if a newer request has come in since this was queued
        if (currentId !== audioPlaybackId.current) return;

        const { uris, index, itemId } = activeAudioQueue.current;

        // If queue finished, trigger next Library Item
        if (index >= uris.length) {
            if (itemId) handleAudioTrackFinished(itemId);
            return;
        }

        const uri = uris[index];

        try {
            // NEW: Ensure any active Native TTS is stopped
            Speech.stop();

            if (currentSound.current) {
                try {
                    currentSound.current.pause(); // Explicitly pause
                    currentSound.current.remove();
                } catch (e: any) { }
                currentSound.current = null;
            }

            // Check again before expensive load
            if (currentId !== audioPlaybackId.current) return;

            // IMPROVEMENT: Explicitly set audio mode to stay active in background before playing
            // This helps persist playback on Android when screen turns off
            try {
                await setAudioModeAsync({
                    allowsRecording: false,
                    shouldPlayInBackground: true,
                    playsInSilentMode: true,
                    interruptionMode: 'duckOthers',
                    shouldRouteThroughEarpiece: false,
                });
            } catch (modeErr) {
                console.warn("Background Audio Config Error:", modeErr);
            }

            const player = createAudioPlayer(uri);
            const actualRate = displaySettings.ttsRate || 1.0;

            // Try setting shouldCorrectPitch directly on the player object
            try {
                (player as any).shouldCorrectPitch = true;
            } catch (e) {
                console.log('[TTS Debug] Could not set shouldCorrectPitch property:', e);
            }

            console.log(`[TTS Debug] Setting playback rate to: ${actualRate}`);
            player.setPlaybackRate(actualRate);

            // Log actual player properties for debugging
            console.log('[TTS Debug] Player properties:', {
                playbackRate: (player as any).playbackRate,
                shouldCorrectPitch: (player as any).shouldCorrectPitch
            });

            // CRITICAL: Check race condition again after await. 
            // If user clicked another file while this was loading, stop immediately.
            if (currentId !== audioPlaybackId.current) {
                player.remove();
                return;
            }

            // Expo Audio doesn't have an async loading state in the same way, it's ready or it emits events
            currentSound.current = player;
            setTtsStatus('playing');
            setIsOnlinePlayback(true);

            (player as any).addListener('statusChange', (status: any) => {
                if (status === 'playing' || status === 'paused') {
                    setAudioProgress({ position: player.currentTime * 1000, duration: (player.duration || 0.001) * 1000 });
                }
                if (status === 'finished') {
                    // Move to next file in queue
                    activeAudioQueue.current.index += 1;
                    playNextInQueue(); // No explicit ID needed for continuation
                }
            });

            player.play();

        } catch (e) {
            console.log("Error playing queue file", e);
            // Skip error file and try next
            activeAudioQueue.current.index += 1;
            playNextInQueue(currentId);
        }
    };

    // NEW: Handler for when a track finishes (Orphan or Session)
    const handleAudioTrackFinished = (finishedItemId: string) => {
        if (!isAudioPlaylistActive.current) return;

        // 1. Create a flattened list of all playable audio items for simple indexing
        // This includes chapters inside books and standalone files
        const playlist: any[] = [];
        audioFiles.forEach((item: any) => {
            if (item.isBook && item.chapters) {
                item.chapters.forEach((chapter: any) => playlist.push(chapter));
            } else {
                playlist.push(item);
            }
        });

        // 2. Find current index in this flattened playlist
        const index = playlist.findIndex((f: any) => f.id === finishedItemId);
        if (index === -1) {
            isAudioPlaylistActive.current = false;
            return;
        }

        // 3. Move to the next item
        const nextIndex = index + 1;

        if (nextIndex < playlist.length) {
            // Play next item
            const nextItem = playlist[nextIndex];
            // Add small delay for natural transition
            setTimeout(() => {
                showToast(`Next: ${nextItem.matchedTitle || "Unknown"}`);
                playLibraryItem(nextItem, false); // isManual = false (maintains playlist mode)
            }, 1500);
        } else {
            showToast("End of playlist");
            isAudioPlaylistActive.current = false;
            audioSessionHistory.current.clear();
        }
    };

    // NEW: Unified Handler to play audio items from Library and manage auto-play
    const playLibraryItem = async (item: any, isManual = false) => {
        // Stop Everything First
        try {
            Speech.stop();
            if (currentSound.current) {
                currentSound.current.pause();
                currentSound.current.remove();
                currentSound.current = null;
            }
        } catch (e) { }

        // Increment Playback ID to invalidate any pending loads from previous clicks
        audioPlaybackId.current += 1;
        const newPlaybackId = audioPlaybackId.current;

        // Manage Playlist State
        if (isManual) {
            isAudioPlaylistActive.current = true;
            audioSessionHistory.current.clear();
        } else {
            isAudioPlaylistActive.current = true;
        }

        // Add to history
        audioSessionHistory.current.add(item.id);

        // 1. Prepare Queue
        let uris = [];
        if (item.isGroup) {
            uris = item.files.map((f: any) => f.uri);
        } else {
            uris = [item.uri];
        }

        // Set Global Queue
        activeAudioQueue.current = { uris, index: 0, itemId: item.id };

        // 2. Determine Display Info
        let targetTitle = item.matchedTitle || "Unknown Recording";
        // If session exists in memory, use its title for better formatting
        if ((chatSessions as any)[item.sessionId]) {
            targetTitle = (chatSessions as any)[item.sessionId].title;
        }

        // 3. Construct Dummy "Orphan" Session
        const targetId = `orphan_${item.id}`;

        const targetSession = {
            id: targetId,
            title: targetTitle,
            messages: [{ role: 'ai', content: "" }], // No text content
            toolId: 'orphan_audio', // Force Audio UI
            timestamp: new Date(item.modificationTime * 1000).toISOString(),
            hasAudio: true
        };

        setPlayingMeta({ id: targetId, title: targetTitle });

        // 4. Start Playback with new ID
        playNextInQueue(newPlaybackId);

        // 5. Load UI
        setNavOrigin('library');
        setReadingSession(targetSession);
        setAppMode('reader');
    };

    // Trigger load when switching to Audio tab
    useEffect(() => {
        if (activeTab === 'library' && libraryTab === 'audio') {
            loadAudioFiles();
        }
    }, [activeTab, libraryTab, loadAudioFiles]);

    // UPDATED: Async loader to handle external file content
    const loadHistorySession = async (session: any, origin = 'idle') => {
        // NEW: Instant load for help guides to skip loading screen
        if (session.toolId === 'help_guide') {
            setNavOrigin(origin);
            setReadingSession(session);
            setAppMode('reader');
            return;
        }

        let fullSession = session;

        // ON-DEMAND LOAD: If session is "Lite" (missing messages/fat content), fetch full object
        // Check for isLite flag OR missing messages (fallback)
        if (session.isLite || (!session.messages && !session.contentPath)) {
            try {
                const fullJson = await AsyncStorage.getItem(`session_${session.id}`);
                if (fullJson) {
                    fullSession = JSON.parse(fullJson);
                    console.log(`Deep Loaded session: ${session.id}`);
                }
            } catch (deepLoadErr) {
                console.error("Deep Load Failed:", deepLoadErr);
                // Fallback to what we have, though it might be broken
            }
        }

        setIsLoadingHistory(true);
        setNavOrigin(origin); // Track origin


        setIsLoadingHistory(true);
        setNavOrigin(origin); // Track origin

        // UPDATED: Track last access for Recent Activity sorting
        const lastOpenedTime = new Date().toISOString();
        setChatSessions((prev: any) => {
            if (!session.id || !prev[session.id]) return prev;
            const updatedSession = {
                ...prev[session.id],
                lastOpened: lastOpenedTime
            };

            // CRITICAL FIX: Do NOT overwrite the full session on disk with this "Lite" object.
            // We use mergeItem to ONLY update the lastOpened field without touching the rest
            AsyncStorage.mergeItem(`session_${session.id}`, JSON.stringify({ lastOpened: lastOpenedTime })).catch(err => console.error("Recent Access Save error", err));

            return {
                ...prev,
                [session.id]: updatedSession
            };
        });

        // Allow UI to update to loading state
        await new Promise(resolve => setTimeout(resolve, 50));

        try {
            // CHECK FOR EXTERNAL CONTENT (Large File Handling)
            // BUG FIX: Use 'fullSession' (potentially deep loaded) instead of 'session' (potentially Lite)
            let loadedSession = { ...fullSession };

            if (loadedSession.contentPath) {
                try {
                    // BUG FIX: Ensure we have a full URI. If it's just a filename, prepend documentDirectory.
                    const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                    const fullPath = loadedSession.contentPath.startsWith('file://')
                        ? loadedSession.contentPath
                        : (docDir + loadedSession.contentPath);

                    // Check if file exists
                    const info = await fs.getInfoAsync(fullPath);
                    if (info.exists) {
                        const fullContent = await fs.readAsStringAsync(fullPath, { encoding: fs.EncodingType.UTF8 });
                        // Restore content into the first message
                        if (!loadedSession.messages || loadedSession.messages.length === 0) {
                            loadedSession.messages = [{ role: 'user', content: '' }];
                        }
                        loadedSession.messages[0].content = fullContent;
                    } else {
                        console.warn("Content file missing for session", session.id);
                        if (!loadedSession.messages || loadedSession.messages.length === 0) {
                            loadedSession.messages = [{ role: 'system', content: '' }];
                        }
                        loadedSession.messages[0].content += "\n\n[Error: Original content file not found on device]";
                    }
                } catch (err) {
                    console.error("Failed to read external content", err);
                }
            }

            // Load images from files if they are file paths
            if (loadedSession.image && !loadedSession.image.startsWith('data:') && !loadedSession.image.startsWith('http')) {
                try {
                    const base64Data = await fs.readAsStringAsync(loadedSession.image, { encoding: 'base64' });
                    loadedSession.image = `data:image/jpeg;base64,${base64Data}`;
                } catch (e: any) {
                    console.error('Failed to load session.image from file:', e);
                }
            }

            if (loadedSession.images && Array.isArray(loadedSession.images)) {
                const loadedImages: string[] = [];
                for (const imgPath of loadedSession.images) {
                    if (imgPath && !imgPath.startsWith('data:') && !imgPath.startsWith('http')) {
                        try {
                            const base64Data = await fs.readAsStringAsync(imgPath, { encoding: 'base64' });
                            loadedImages.push(`data:image/jpeg;base64,${base64Data}`);
                        } catch (e: any) {
                            console.error('Failed to load image from file:', e);
                            loadedImages.push(imgPath); // Keep original if load fails
                        }
                    } else {
                        loadedImages.push(imgPath); // Keep data URIs and URLs as-is
                    }
                }
                loadedSession.images = loadedImages;
            }


            if (loadedSession.toolId === 'audio_player') {
                // NEW: Handle Audio Player Session
                const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                // Ensure audioFile property exists
                if (loadedSession.audioFile) {
                    const fullUri = docDir + loadedSession.audioFile;
                    const playItem = {
                        id: loadedSession.id,
                        uri: fullUri,
                        matchedTitle: loadedSession.title,
                        modificationTime: new Date(loadedSession.timestamp).getTime() / 1000,
                        sessionId: loadedSession.id, // Link back to session
                        isGroup: false
                    };
                    playLibraryItem(playItem, true);
                    return;
                }
            }

            if (loadedSession.toolId === 'flashcards') {
                if (loadedSession.items && Array.isArray(loadedSession.items) && loadedSession.items.length > 0) {
                    // Handle Flashcard Sessions
                    setFlashcardSession({
                        items: loadedSession.items,
                        currentIndex: 0,
                        flipped: false,
                        type: 'generated',
                        topic: loadedSession.title,
                        originId: loadedSession.id
                    });
                    setAppMode('flashcards');
                } else {
                    Alert.alert("Data Empty", "This flashcard session has no items. It may have been corrupted or incorrectly saved.");
                }
                setIsLoadingHistory(false);
                return;
            } else if (loadedSession.toolId === 'quiz_save' && loadedSession.quizData) {
                const restoredQuestions = (loadedSession.quizData as any[]).map((q: any) => ({
                    ...q,
                    selected: q.selected !== undefined ? q.selected : null,
                    markedForReview: q.markedForReview || false,
                    visited: q.visited || false
                }));

                const safeTimeSpent = (Array.isArray(loadedSession.timeSpent) && loadedSession.timeSpent.length === restoredQuestions.length)
                    ? loadedSession.timeSpent
                    : new Array(restoredQuestions.length).fill(0);

                const defaultLang = loadedSession.language || 'English';
                const translations = loadedSession.translations || { [defaultLang]: restoredQuestions };

                // Logic: If session has a challenger AND challengeStarted is not explicitly true, show Challenge Screen
                // If user has already started (loadedSession.challengeStarted === true), skip screen.
                const hasChallenger = !!loadedSession.challenger;
                const isStarted = loadedSession.challengeStarted !== undefined ? loadedSession.challengeStarted : !hasChallenger;

                setQuizState({
                    questions: restoredQuestions,
                    currentIndex: loadedSession.currentIndex || 0,
                    score: loadedSession.score || 0,
                    completed: loadedSession.completed || false,
                    title: loadedSession.title,
                    timeSpent: safeTimeSpent,
                    activeQuestionStartTime: Date.now(),
                    originId: loadedSession.id,
                    translations: translations,
                    language: defaultLang,
                    contextText: loadedSession.contextText || null,
                    attempts: loadedSession.attempts || 1,
                    isExamMode: loadedSession.isExamMode !== undefined ? loadedSession.isExamMode : false,
                    modeLocked: loadedSession.modeLocked || false,
                    autoSubmitted: loadedSession.autoSubmitted || false, // NEW: Restore flag
                    challenger: loadedSession.challenger || null,
                    challengeStarted: isStarted,
                    preventTranslation: loadedSession.preventTranslation || false, // NEW: Restore translation lock
                    subject: loadedSession.subject || "General" // NEW: Restore subject for context
                });
                setQuizSecondsElapsed(loadedSession.totalTime || 0);
                setAppMode('live');
                setShowReferenceText(false);
            } else {
                const defaultLang = loadedSession.language || 'English';

                if (loadedSession.storyMode) {
                    setStoryMode(loadedSession.storyMode);
                }

                setReadingSession(loadedSession);
                setAppMode('reader');
            }
        } catch (e) {
            console.error("Error loading session", e);
            Alert.alert("Load Error", "Could not open this item.");
        } finally {
            setIsLoadingHistory(false);
        }
    };

    const generateSmartBio = async (providedSettings?: any, manual = false) => {
        const settings = providedSettings || displaySettings;
        if (!settings.userName && !settings.userProfession && !settings.userGoal && !settings.userBio) return;

        // NEW: Abort if no API key is available (Avoids "No Key" error text as bio)
        const key = customApiKey || apiKey;
        if (!key) {
            if (manual) {
                Alert.alert("API Key Required", "Please add a Gemini API Key in Settings to generate your Smart Bio.");
            }
            console.log("Skipping Smart Bio generation: No API Key.");
            return;
        }

        setIsGeneratingBio(true);
        try {
            const profileContext = `
Name: ${settings.userName || 'N/A'}
Profession: ${settings.userProfession || 'N/A'}
Goal: ${settings.userGoal || 'N/A'}
Instructions: ${settings.userBio || 'N/A'}`;

            const prompt = `Act as if you are the user themselves writing their own bio. 
Summarize the following profile information into a single, cohesive, and friendly paragraph (max 2-3 sentences). 
Focus on who you are and how you want to use AI. 
CRITICAL: Write in the first person (use "I", "my", "me"). Do NOT use the name from the profile. 

PROFILE DATA:
${profileContext}

RETURN ONLY THE SUMMARY TEXT starting with "I...".`;

            const systemRole = "Biographer";
            // Use callLLM with jsonMode=false
            const bio = await callLLM(prompt, systemRole, false);

            if (bio && bio.trim().length > 0) {
                await saveSettings({ smartBio: bio.trim() });
            }
        } catch (error) {
            console.error("Failed to generate smart bio:", error);
        } finally {
            setIsGeneratingBio(false);
        }
    };

    const saveSettings = async (newSettings: any) => {
        // NEW: Reset active model tracking if model preferences change
        if (newSettings.modelPriority !== undefined || newSettings.customTextModel !== undefined) {
            setActiveModelId(null);
        }

        // Critical: Use functional update to avoid stale closure issues
        setDisplaySettings((prev: any) => {
            const updated = { ...prev, ...newSettings };
            // Save to storage immediately inside the update to ensure consistency
            AsyncStorage.setItem('settings', JSON.stringify(updated));
            return updated;
        });
    };

    const saveSchoolConfig = async (newConfig: any) => {
        setSchoolConfig((prev: any) => {
            const updated = { ...prev, ...newConfig };
            AsyncStorage.setItem('schoolConfig', JSON.stringify(updated));
            return updated;
        });
    };

    const addLanguage = (lang: string) => {
        if (displaySettings.availableLanguages.includes(lang)) {
            Alert.alert("Exists", "Language already added.");
            return;
        }

        // NEW: Limit to 2 languages
        if (displaySettings.availableLanguages.length >= 2) {
            Alert.alert(
                "Limit Reached",
                "You can only add up to 2 languages.\n\nLong press an existing language to delete it first."
            );
            return;
        }

        const newLangs = [...displaySettings.availableLanguages, lang];
        saveSettings({ availableLanguages: newLangs, language: lang });
    };

    const removeLanguage = (langToRemove: string) => {
        if (displaySettings.availableLanguages.length <= 1) {
            Alert.alert("Cannot delete", "You must have at least one language.");
            return;
        }
        Alert.alert(
            "Delete Language",
            `Remove ${langToRemove}?`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: 'destructive',
                    onPress: () => {
                        const newLangs = displaySettings.availableLanguages.filter((l: string) => l !== langToRemove);
                        let newCurrent = displaySettings.language;
                        if (newCurrent === langToRemove) {
                            newCurrent = newLangs[0];
                        }
                        saveSettings({ availableLanguages: newLangs, language: newCurrent });

                        // NEW: Cleanup cache for this language from storage
                        setUiCache((prev: any) => {
                            const updated = { ...prev };
                            (updated as any)[`${langToRemove}_true`] = null;
                            (updated as any)[`${langToRemove}_false`] = null;
                            AsyncStorage.setItem('ui_translations_cache', JSON.stringify(updated));
                            return updated;
                        });
                    }
                }
            ]
        );
    };

    // NEW: Function to generate topics for a new subject
    const generateQuickTopicsForSubject = async (subject: string) => {
        setAppMode("generating");
        setGenerationData(`Brainstorming topics for ${subject}...`);

        const prompt = `Act as a Curriculum Designer.
      Generate 10 interesting and diverse quiz topics for the subject "${subject}".
      
      Return strictly a JSON Array of objects with keys:
      - "label": Short title (max 15 chars)
      - "prompt": Full topic description for quiz generation
      
      Example: [{"label": "Basics", "prompt": "Fundamental concepts of..."}]
      
      Output VALID JSON ONLY.`;

        try {
            const raw = await callLLM(prompt, "Curriculum Designer", true);
            const clean = extractJSON(raw);
            const topics = JSON.parse(clean);

            if (Array.isArray(topics)) {
                setCustomSubjectPrompts((prev: any) => {
                    const updated = { ...prev, [subject]: topics };
                    AsyncStorage.setItem('customSubjectPrompts', JSON.stringify(updated));
                    return updated;
                });

                // Return to setup mode
                setAppMode("setup");
            } else {
                throw new Error("Invalid format");
            }
        } catch (e) {
            console.error("Topic Gen Error", e);
            Alert.alert("Error", "Could not generate topics. Please try again or use manual input.");
            setAppMode("setup");
        } finally {
            setGenerationData(null);
        }
    };

    const addSubject = async (subject: string) => {
        if (availableSubjects.includes(subject)) {
            Alert.alert("Exists", "Subject already added.");
            return;
        }
        const newSubjects = [...availableSubjects, subject].sort((a, b) => a.localeCompare(b)); // Sort alphabetically
        setAvailableSubjects(newSubjects);
        saveSchoolConfig({ subject });
        await AsyncStorage.setItem('availableSubjects', JSON.stringify(newSubjects));

        // NEW: Ask user to generate topics
        Alert.alert(
            "Generate Topics?",
            `Would you like AI to suggest quiz topics for "${subject}"?`,
            [
                { text: "No", style: "cancel" },
                {
                    text: "Yes, Generate",
                    onPress: () => generateQuickTopicsForSubject(subject)
                }
            ]
        );
    };

    const removeSubject = (subjectToRemove: string) => {
        if (availableSubjects.length <= 1) {
            Alert.alert("Cannot delete", "You must have at least one subject.");
            return;
        }

        Alert.alert(
            "Delete Subject",
            `Remove ${subjectToRemove}?`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: 'destructive',
                    onPress: async () => {
                        const newSubjects = availableSubjects.filter(s => s !== subjectToRemove);
                        setAvailableSubjects(newSubjects);
                        if (schoolConfig.subject === subjectToRemove) {
                            saveSchoolConfig({ subject: newSubjects[0] });
                        }
                        await AsyncStorage.setItem('availableSubjects', JSON.stringify(newSubjects));

                        // Also remove custom prompts for this subject if they exist
                        setCustomSubjectPrompts((prev: any) => {
                            const updated = { ...prev };
                            delete updated[subjectToRemove];
                            AsyncStorage.setItem('customSubjectPrompts', JSON.stringify(updated));
                            return updated;
                        });
                    }
                }
            ]
        );
    };


    const deleteSession = async (id: string, requireConfirmation = true) => {
        const performDelete = async () => {
            // PERMANENT DELETE
            const newSessions = { ...chatSessions };
            if (newSessions[id]) {
                const sessionToDelete = newSessions[id];
                delete newSessions[id];
                setChatSessions(newSessions);

                try {
                    // 1. Remove session file
                    await AsyncStorage.removeItem(`session_${id}`);

                    // 2. Remove from session_index
                    const sessionIndexStr = await AsyncStorage.getItem('session_index');
                    if (sessionIndexStr) {
                        let index = JSON.parse(sessionIndexStr);
                        if (!Array.isArray(index)) index = []; // Safety check
                        const newIndex = index.filter((sid: string) => sid !== id);
                        await AsyncStorage.setItem('session_index', JSON.stringify(newIndex));
                    }

                    // 3. Remove from library_metadata_index if it exists
                    const metadataIndexStr = await AsyncStorage.getItem('library_metadata_index');
                    if (metadataIndexStr) {
                        let mIndex = JSON.parse(metadataIndexStr);
                        if (!Array.isArray(mIndex)) mIndex = []; // Safety check
                        const newMIndex = mIndex.filter((m: any) => m.id !== id);
                        await AsyncStorage.setItem('library_metadata_index', JSON.stringify(newMIndex));
                    }

                    // 4. Handle Audio Cleanup if it's an audio player session
                    if (sessionToDelete.toolId === 'audio_player' && sessionToDelete.audioUri) {
                        try {
                            const exists = await FileSystem.getInfoAsync(sessionToDelete.audioUri);
                            if (exists.exists) {
                                await FileSystem.deleteAsync(sessionToDelete.audioUri);
                            }
                        } catch (audioErr) {
                            console.error("Audio deletion error during single delete", audioErr);
                        }
                    }

                    // 5. Handle Custom Uploaded Audio Cleanup
                    if (customAudioUris[id]) {
                        try {
                            const audioUri = customAudioUris[id];
                            await FileSystem.deleteAsync(audioUri, { idempotent: true });

                            const newAudioUris = { ...customAudioUris };
                            delete newAudioUris[id];
                            if (setCustomAudioUris) setCustomAudioUris(newAudioUris);
                            await AsyncStorage.setItem('customAudioUris', JSON.stringify(newAudioUris));
                        } catch (audioErr) {
                            console.error("Custom audio deletion error during single delete", audioErr);
                        }
                    }

                    showToast("Deleted Permanently");
                } catch (e: any) {
                    console.error("Delete Error", e);
                }
            }
        };
        if (requireConfirmation) {
            Alert.alert(
                "Delete Permanent?",
                "This cannot be undone. Delete this item?",
                [
                    { text: "Cancel", style: "cancel" },
                    {
                        text: "Delete",
                        style: "destructive",
                        onPress: performDelete
                    }
                ]
            );
        } else {
            performDelete();
        }
    };

    const deleteSavedWord = async (id: string) => {
        try {
            // 1. Remove File
            const docDir = fs.documentDirectory || FileSystem.documentDirectory;
            const fileName = `word_${id}.json`;
            await fs.deleteAsync(docDir + fileName, { idempotent: true });

            // 2. Update Index
            const newWords = savedWords.filter(w => w.id !== id);
            setSavedWords(newWords);

            // 3. Save Index to File System
            await fs.writeAsStringAsync(docDir + 'dictionary_index.json', JSON.stringify(newWords));
        } catch (e) {
            console.error("Error deleting word", e);
            Alert.alert("Error", "Could not delete word.");
        }
    };

    const toggleSaveWord = async (word: any, def?: string, examples?: string[]) => {
        let wordToSave = "";
        let dataToSave: any = {};

        // 1. Resolve Input
        if (typeof word === 'object' && word !== null) {
            // Passed as object (from dictionary render)
            // Check if the object has a 'word' property that is a valid string
            if (word.word && typeof word.word === 'string' && word.word.trim()) {
                wordToSave = word.word;
            }
            dataToSave = word;

            // NORMALIZE: Ensure definition and examples are top-level so they are saved correctly
            if (!dataToSave.definition && dataToSave.advanced?.definition) {
                dataToSave.definition = dataToSave.advanced.definition;
            }
            if ((!dataToSave.examples || dataToSave.examples.length === 0) && dataToSave.advanced?.examples) {
                dataToSave.examples = dataToSave.advanced.examples;
            }
        } else {
            // Passed as arguments
            wordToSave = word;
            dataToSave = { word: word, definition: def, examples: examples || [] };
        }

        // 2. Strict Validation & Recovery
        if (!wordToSave || typeof wordToSave !== 'string' || !wordToSave.trim()) {
            // Attempt to recover word from context state
            if (showWordModal && selectedWord?.word) {
                wordToSave = selectedWord.word;
            } else if (activeTab === 'dictionary' && dictionaryCurrentWord) {
                wordToSave = dictionaryCurrentWord;
            }

            // Final Check: If still empty, abort save
            if (!wordToSave || typeof wordToSave !== 'string' || !wordToSave.trim()) {
                Alert.alert("Cannot Save", "The word text is missing.");
                return;
            }
        }

        dataToSave = { ...dataToSave, word: wordToSave };

        // Check Existence
        const existingIndexItem = savedWords.find(w => w.word.toLowerCase() === wordToSave.toLowerCase());

        if (existingIndexItem) {
            // DELETE logic
            await deleteSavedWord(existingIndexItem.id);
        } else {
            // SAVE logic
            // Enforce limit
            let currentWords = savedWords;
            // UPDATED: Fixed limit of 100 for Saved Words (Starred) as per user request
            const SAVED_WORDS_LIMIT: number = 100;

            if (currentWords.length >= SAVED_WORDS_LIMIT) {
                // Remove oldest (index 0) to maintain limit
                await deleteSavedWord(currentWords[0].id);
                currentWords = currentWords.slice(1);
            }

            const id = generateId();
            const fullData = {
                id,
                ...dataToSave,
                timestamp: new Date().toISOString()
            };

            const liteData = {
                id,
                word: wordToSave,
                definition: fullData.simple?.definition || fullData.definition || "No definition",
                partOfSpeech: fullData.partOfSpeech,
                forms: fullData.forms || [],
                examples: fullData.examples || [], // ADDED: Include examples in index for Flashcards
                timestamp: fullData.timestamp
            };

            try {
                const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                // 1. Write Full Data File
                await fs.writeAsStringAsync(docDir + `word_${id}.json`, JSON.stringify(fullData));

                // 2. Update Index in Memory
                const newWords = [...currentWords, liteData];
                setSavedWords(newWords);

                // 3. Save Index to File System
                await fs.writeAsStringAsync(docDir + 'dictionary_index.json', JSON.stringify(newWords));
            } catch (e: any) { // Cast e to any as per instruction
                console.error("Save Word Error", e);
                Alert.alert("Error", "Could not save word to storage.");
            }
        }
    };

    // OPTIMIZED: Use O(1) Set lookup
    const isWordSaved = (word: string) => wordMap.has(word?.trim().toLowerCase());

    const toggleSaveQuestion = async (question: any) => {
        const isSaved = savedQuestions.some((q: any) => q.question === question.question);
        let newQuestions;
        if (isSaved) {
            newQuestions = savedQuestions.filter((q: any) => q.question !== question.question);
        } else {
            // Enforce limit
            let currentQuestions = savedQuestions;
            // UPDATED: Fixed limit for Questions (200)
            const limit = 200;

            if (currentQuestions.length >= limit) {
                currentQuestions = currentQuestions.slice(1); // Remove oldest
            }
            // NEW: Add unique ID to saved question for better list rendering
            newQuestions = [...currentQuestions, { ...question, id: generateId(), savedAt: new Date().toISOString() }];
        }
        setSavedQuestions(newQuestions);
        await AsyncStorage.setItem('savedQuestions', JSON.stringify(newQuestions));
    };

    const handleGenerateBookChapter = async () => {
        let title = "";
        let description = "";
        const query = storyQuery.trim();

        if (!query) {
            // PROFILE-BASED GENERATION
            const { userName, userProfession, userGoal, userBio } = displaySettings as any;
            description = `Create a story tailored to the user profile:
            - Name: ${userName || "User"}
            - Profession: ${userProfession || "Learner"}
            - Goal: ${userGoal || "Self-improvement"}
            - Bio: ${userBio || "No bio provided."}
            Write a story that resonates with this person's background and aspirations. Use the ${bookParams.genre} genre.`;
        } else {
            // Parsing logic: look for separator, otherwise check length
            const separatorIdx = query.indexOf(':') !== -1 ? query.indexOf(':') : query.indexOf('-');
            if (separatorIdx !== -1) {
                title = query.substring(0, separatorIdx).trim();
                description = query.substring(separatorIdx + 1).trim();
            } else if (query.length < 60) {
                title = query;
            } else {
                description = query;
            }
        }

        const effectiveChapter = "Chapter 1: The Beginning";

        setAppMode("generating");
        setGenerationData(`Writing ${effectiveChapter}...`);

        let prompt = "";
        let systemRole = "Professional Author";

        const titleContext = title
            ? `titled "${title}"`
            : `and invent a creative, fitting title for this book based on the description provided. Start your response with "BOOK_TITLE: [Your Creative Title]" on the first line.`;

        const descriptionContext = description
            ? `\n\nPLOT/SCENE DESCRIPTION: The user has provided the following details:\n"${description}"\nEnsure these events or details are incorporated naturally into the narrative.`
            : "";

        if (storyMode === 'narrator') {
            systemRole = "Master Narrator";
            prompt = `Act as a master storyteller. 
        Write "${effectiveChapter}" for a ${bookParams.genre} book ${titleContext}.
        ${descriptionContext}
        
        MODE: NARRATOR
        - Style: Classic storytelling.
        - Perspective: Third-Person Omniscient (or appropriate for genre).
        - Focus: Descriptive prose, world-building, internal monologues, and narrative arc.
        - Tone: The narrator guides the reader through the events.
        
        Guidelines:
        - Genre Style: ${bookParams.genre}.
        - Length: Comprehensive and detailed.
        - Vocabulary: Use strict A1/A2 beginner vocabulary. Short sentences, simple words, and clear grammar. Focus on clarity and emotion over complex vocabulary.
        - Format: Use Markdown with a clear chapter title header.
        `;
        } else {
            systemRole = "Scriptwriter";
            prompt = `Act as a professional Scriptwriter.
        Write "${effectiveChapter}" for a ${bookParams.genre} book ${titleContext}.
        ${descriptionContext}
        
        MODE: AUDIO DRAMA SCRIPT
        
        STRICT RULES:
        1. **DIALOGUE DRIVEN**: The story must be told primarily through what characters SAY.
        2. **SEPARATE NARRATION**: Use "**Narrator:**" for all scene settings, actions, and non-spoken descriptions.
        3. **REALISTIC SPEECH**: Characters must speak naturally. Do NOT write internal thoughts as dialogue.
        4. **FORMAT**: 
           - **[Character Name]:** "Dialogue..."
           - **Narrator:** [Description of scene or action].
        5. **NO GENERIC LABELS**: Do NOT use "Scene:" or "Action:" as speaker names. Use "Narrator:" instead.
        
        Guidelines:
        - Genre Style: ${bookParams.genre}.
        - Length: Comprehensive script.
        - Vocabulary: Use strict A1/A2 beginner vocabulary.
        `;
        }

        // Add Visual Requirement to prompt
        prompt += `\n\nVISUAL REQUIREMENT:
    At the very end of your response, strictly on a new line, provide a detailed image generation prompt to create a cover or scene for this chapter. Format: IMAGE_PROMPT: <prompt>`;

        const rawContent = await callLLM(prompt, systemRole);

        // NEW: Check for error before saving
        if (rawContent.startsWith("Error")) {
            setGenerationData(null);
            setAppMode("idle"); // Return to story tab
            Alert.alert("Generation Failed", rawContent);
            return;
        }

        let content = rawContent;
        let finalTitle = title;

        // NEW: Extract BOOK_TITLE if inferred by AI
        const titleMatch = content.match(/BOOK_TITLE:\s*(.*)/);
        if (titleMatch) {
            finalTitle = titleMatch[1].trim();
            content = content.replace(/BOOK_TITLE:.*$/, '').trim();
        }

        if (!finalTitle) finalTitle = "Untitled Story";

        let image = null;
        const imgMatch = content.match(/IMAGE_PROMPT:\s*(.*)/);
        if (imgMatch) {
            const imgPrompt = imgMatch[1].trim();
            content = content.replace(/IMAGE_PROMPT:.*$/, '').trim();
            setGenerationData("Illustrating...");
            image = await generateImage(imgPrompt);
        }

        // NEW: Calculate Sequence Number (Footer)
        const bookPrefix = `${finalTitle}:`;
        const existingChaptersCount = Object.values(chatSessions).filter((s: any) =>
            s.toolId === 'story_generator' &&
            s.title.startsWith(bookPrefix)
        ).length;

        // Append Footer
        content += `\n\n---\n*Sequence: ${existingChaptersCount} previous chapters*`;

        const newSession = {
            id: generateId(),
            timestamp: new Date().toISOString(),
            messages: [{ role: "ai", content }],
            title: `${finalTitle}: ${effectiveChapter}`,
            toolId: 'story_generator',
            image: image,
            translations: { [displaySettings.language]: content },
            language: displaySettings.language,
            storyMode: storyMode,
        };
        await persistSession(newSession);

        autoPlayRef.current = true;
        loadHistorySession(newSession);
        setGenerationData(null);
        setStoryQuery(""); // NEW: Clear query after generation
    };

    // ... (playLibraryItem function) ...

    const handleNextChapter = async (autoPlay: boolean = false) => {
        if (!readingSession) return;

        // CHECK: Does a next chapter already exist?
        // If we have generated this before, load it instead of creating a new one.
        if (readingSession.nextChapterId && chatSessions[readingSession.nextChapterId]) {
            const nextSession = chatSessions[readingSession.nextChapterId];
            loadHistorySession(nextSession, 'reader');
            return;
        }

        const separatorIndex = readingSession.title.indexOf(':');
        let bookTitle = readingSession.title;
        let previousChapterTitle = "the beginning";

        if (separatorIndex !== -1) {
            bookTitle = readingSession.title.substring(0, separatorIndex).trim();
            previousChapterTitle = readingSession.title.substring(separatorIndex + 1).trim();
        }

        setAppMode("generating");
        setGenerationData(`Drafting the next chapter of "${bookTitle}"...`);

        const prevContent = readingSession.messages[0].content;

        // IMPROVED: Context Window
        // Increase context from 500 chars to 8000 chars (~2000 words) to ensure the AI 
        // understands the full context of the previous chapter to avoid skipping/repeating.
        const contextSlice = prevContent.length > 8000 ? "..." + prevContent.slice(-8000) : prevContent;

        // NEW: Use session mode if available to persist continuity, otherwise fallback to current UI toggle
        const effectiveStoryMode = readingSession.storyMode || storyMode;

        // NEW: User Direction Logic - Inject user input into prompt
        const userDirection = nextChapterInput.trim()
            ? `\n\nUSER PLOT DIRECTION: The user specifically requested: "${nextChapterInput.trim()}". You MUST incorporate this event, theme, or direction naturally into the next chapter.`
            : "";

        // UPDATED: Format Instruction (Removed Ambience)
        const formatInstruction = `
      REQUIRED OUTPUT FORMAT:
      1. First line MUST be: "# [Chapter Title]"
      2. Then the story content...
      
      Example:
      # Chapter 3: The Siege
      **Narrator:** The drums of war echoed.
      **General:** Hold the line!
      `;

        let prompt = "";
        let systemRole = "Professional Author";

        if (effectiveStoryMode === 'narrator') {
            systemRole = "Master Narrator";
            prompt = `Act as a professional author. 
          You are writing the DIRECT SEQUEL / NEXT CHAPTER for the book titled "${bookTitle}".
          
          MODE: NARRATOR (Classic Prose)
          ${userDirection}
          
          PREVIOUS CHAPTER CONTENT (For Context Only - Do Not Repeat):
          """
          ${contextSlice}
          """
          
          Task:
          1. Write the logical next chapter.
          2. Invent a suitable Title for this new chapter.
          3. Maintain the genre, tone, and narrative flow.
          4. Ensure it is a complete chapter (approx 800-1200 words).
          
          CRITICAL PLOT RULES:
          - **CONTINUITY**: Pick up the story EXACTLY where the previous chapter ended.
          - **NO REPETITION**: Do NOT re-write the ending of the previous chapter. Move the plot FORWARD immediately.
          - **NO SKIPPING**: Do not skip important bridge scenes unless it's a calculated time jump. If the characters were in the middle of a conversation or action, finish it.
          
          Guidelines:
          - Vocabulary: Use strict A1/A2 beginner vocabulary. Short sentences, simple words, and clear grammar. Keep sentences clear and engaging.

          ${formatInstruction}
          `;
        } else {
            // IMPROVED: Stronger prompt for Live Character mode next chapter
            systemRole = "Scriptwriter";
            prompt = `You are writing the NEXT SCENE for the book titled "${bookTitle}".
          
          MODE: AUDIO DRAMA SCRIPT
          ${userDirection}
          
          PREVIOUS SCENE CONTENT (For Context Only - Do Not Repeat):
          """
          ${contextSlice}
          """
          
          Task:
          1. Continue the story IMMEDIATELY from the last action/dialogue.
          2. **FORMAT**: Use "**Narrator:**" for descriptions/actions and "**[Character]:**" for dialogue.
          3. **DIALOGUE FOCUS**: Drive the plot through conversation and interaction.
          4. Invent a suitable Title for this new chapter.
          5. Ensure it is a complete script (approx 800-1200 words).

          Guidelines:
          - Vocabulary: Use strict A1/A2 beginner vocabulary. Short sentences, simple words, and clear grammar.
          - Do NOT use "Scene:" or "Action:" as labels. Use "Narrator:".
          
          ${formatInstruction}
          `;
        }

        prompt += `\n\nVISUAL REQUIREMENT:
      At the very end of your response, strictly on a new line, provide a detailed image generation prompt for a cover image for this chapter. Format: IMAGE_PROMPT: <prompt>`;

        try {
            const rawContent = await callLLM(prompt, systemRole);

            if (!rawContent || rawContent.startsWith("Error")) {
                throw new Error("Failed to generate text");
            }

            let content = rawContent;

            // REMOVED: Ambience Extraction

            let image = null;
            const imgMatch = content.match(/IMAGE_PROMPT:\s*(.*)/);
            if (imgMatch) {
                const imgPrompt = imgMatch[1].trim();
                content = content.replace(/IMAGE_PROMPT:.*$/, '').trim();
                setGenerationData("Illustrating...");
                image = await generateImage(imgPrompt);
            }

            // NEW: Calculate Sequence Number (Footer) for Next Chapter
            const bookPrefix = `${bookTitle}:`;
            const existingChaptersCount = Object.values(chatSessions).filter((s: any) =>
                s.toolId === 'story_generator' &&
                s.title.startsWith(bookPrefix)
            ).length;

            // Append Footer
            content += `\n\n---\n*Sequence: ${existingChaptersCount} previous chapters*`;

            let newChapterTitle = "Next Chapter";
            const lines = content.split('\n');
            const titleLine = lines.find((l: string) => l.trim().startsWith('#'));
            if (titleLine) {
                newChapterTitle = titleLine.replace(/^#+\s*/, '').trim();
            }

            const newTitle = `${bookTitle}: ${newChapterTitle}`;

            // 1. Create the new (Next) Session
            const newSession = {
                id: generateId(),
                timestamp: new Date().toISOString(),
                messages: [{ role: "ai", content }],
                title: newTitle,
                toolId: 'story_generator',
                image: image,
                translations: { [displaySettings.language]: content },
                language: displaySettings.language,
                storyMode: effectiveStoryMode, // Save the mode for the next chapter
                previousChapterId: readingSession.id, // Link BACK to current
                // REMOVED: ambience property
            };

            await persistSession(newSession);

            // 2. Update the CURRENT Session to link FORWARD to the new session
            const updatedCurrentSession = {
                ...readingSession,
                nextChapterId: newSession.id
            };
            await persistSession(updatedCurrentSession); // This updates chatSessions/Storage

            // Clear input after successful generation
            setNextChapterInput("");
            setShowStoryAd(false); // NEW: Hide ad after generating

            autoPlayRef.current = false;
            loadHistorySession(newSession);

        } catch (e) {
            console.error("Next Chapter Error", e);
            Alert.alert("Error", "Could not generate the next chapter. Please try again.");
            setAppMode('reader');
        } finally {
            setGenerationData(null);
        }
    };

    const handlePreviousChapter = () => {
        if (!readingSession || !readingSession.previousChapterId) return;
        const prevSession = chatSessions[readingSession.previousChapterId];
        if (prevSession) {
            loadHistorySession(prevSession, 'reader');
        } else {
            Alert.alert("History Error", "Previous chapter data not found.");
        }
    };

    // REMOVED: manageBackgroundAudio useEffect

    const performLibraryReset = async () => {
        setShowResetWarning(false);

        // NEW: Create automatic backup of Notes before reset
        try {
            const noteSessions = Object.values(chatSessions).filter((session: any) => session.toolId === 'quick_notes');

            if (noteSessions.length > 0) {
                showToast("Creating backup...");
                await new Promise(r => setTimeout(r, 100));

                const bundle = await createShareBundle(noteSessions, 'notes');
                const content = JSON.stringify(bundle, null, 2);
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `notes_backup_${timestamp}.json`;

                if (Platform.OS === 'android') {
                    try {
                        let directoryUri = await AsyncStorage.getItem('savedExportDirectory');
                        const attemptSave = async (uri: string) => {
                            try {
                                const newFileUri = await fs.StorageAccessFramework.createFileAsync(uri, filename, 'application/json');
                                await fs.writeAsStringAsync(newFileUri, content, { encoding: fs.EncodingType.UTF8 });
                                return true;
                            } catch (e: any) {
                                return false;
                            }
                        };

                        let success = false;
                        if (directoryUri) success = await attemptSave(directoryUri);

                        if (!success) {
                            const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                            if (permissions.granted) {
                                directoryUri = permissions.directoryUri;
                                await AsyncStorage.setItem('savedExportDirectory', directoryUri);
                                success = await attemptSave(directoryUri);
                            }
                        }

                        if (success) {
                            showToast("Backup created successfully");
                        } else {
                            Alert.alert("Backup Failed", "Could not create backup file. Continue with reset?", [
                                { text: "Cancel", style: "cancel", onPress: () => setShowResetWarning(true) },
                                { text: "Reset Anyway", style: "destructive", onPress: () => continueReset() }
                            ]);
                            return;
                        }
                    } catch (e: any) {
                        console.error("Backup Error", e);
                        Alert.alert("Backup Failed", "Could not create backup. Continue with reset?", [
                            { text: "Cancel", style: "cancel", onPress: () => setShowResetWarning(true) },
                            { text: "Reset Anyway", style: "destructive", onPress: () => continueReset() }
                        ]);
                        return;
                    }
                } else {
                    // iOS: Save to cache and share
                    try {
                        const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
                        const fileUri = cacheDir + filename;
                        await fs.writeAsStringAsync(fileUri, content, { encoding: fs.EncodingType.UTF8 });
                        await Sharing.shareAsync(fileUri);
                        showToast("Backup created successfully");
                    } catch (e: any) {
                        console.error("Backup Error", e);
                        Alert.alert("Backup Failed", "Could not create backup. Continue with reset?", [
                            { text: "Cancel", style: "cancel", onPress: () => setShowResetWarning(true) },
                            { text: "Reset Anyway", style: "destructive", onPress: () => continueReset() }
                        ]);
                        return;
                    }
                }
            }
        } catch (e) {
            console.error("Backup Creation Error", e);
            Alert.alert("Backup Failed", "Could not create backup. Continue with reset?", [
                { text: "Cancel", style: "cancel", onPress: () => setShowResetWarning(true) },
                { text: "Reset Anyway", style: "destructive", onPress: () => continueReset() }
            ]);
            return;
        }

        // Continue with reset
        await continueReset();
    };

    const continueReset = async () => {
        try {
            // STOP ALL TTS/AUDIO FIRST to avoid background locks
            try { Speech.stop(); } catch (e) { }

            const docDir = fs.documentDirectory || FileSystem.documentDirectory;

            // 1. Clear AsyncStorage - Scorched Earth approach
            try {
                const allStorageKeys = await AsyncStorage.getAllKeys();
                if (allStorageKeys.length > 0) {
                    await AsyncStorage.multiRemove(allStorageKeys);
                }
            } catch (e) {
                console.error("AsyncStorage Wipe Error", e);
                // Fallback to clear if multiRemove fails
                await AsyncStorage.clear();
            }

            // 2. Clear FileSystem - Purge all internal files (Definitions, Index, etc.)
            if (docDir) {
                try {
                    const files = await fs.readDirectoryAsync(docDir);
                    for (const file of files) {
                        try {
                            await fs.deleteAsync(docDir + file, { idempotent: true });
                        } catch (e) { }
                    }
                } catch (e) {
                    console.error("FileSystem Reset Error", e);
                }
            }

            // 3. Reset React State to First-Install defaults
            setChatSessions({});
            setSavedWords([]);
            setSavedQuestions([]);
            const defaultSubjects = [
                'Art', 'Basic Computer', 'Biology', 'Chemistry', 'Computer Science',
                'English', 'General', 'Geography', 'History', 'Literature',
                'Machine Learning', 'Mathematics', 'Physics', 'Reasoning', 'Science'
            ];
            setAvailableSubjects(defaultSubjects);
            setRecentSearches([]);
            recentSearchesRef.current = [];
            setCustomTools([]);
            setCustomToolPrompts({});
            setCustomSubjectPrompts({});
            setCustomVisionPrompts([]);
            setCustomApiKey("");
            setLastQuizSubject("");
            savedTableWidths.current = {};
            quizHistoryRef.current = {};

            const defaultSettings = {
                theme: "forest",
                fontSize: 1.0,
                ttsRate: 1.0,
                fontFamily: "Modern",
                textStyles: [],
                language: "English",
                availableLanguages: ["English"],
                primaryLanguage: "English",
                isExamMode: false,
                quizTarget: 'quiz',
                modeLocked: false,
                userName: "",
                userProfession: "",
                userGoal: "",
                userBio: "",
                nameLocked: false,
                dictionaryLimit: 10000,
                libraryLimit: 2000,
                onlineTtsEnabled: true,
                imageGenerationEnabled: true,
                llmProvider: 'gemini',
                groqApiKey: '',
                hfApiKey: '',
                isOnboarded: false
            };
            setDisplaySettings(defaultSettings);

            // 4. Restore Default Home Layout
            const priorityIds = ['writer', 'examiner', 'email_pro', 'editorial_writer', 'summarizer', 'word_help', 'health_guide', 'visual_learner'];
            const hiddenIds = ['ai_usage', 'ai_for_everyone', 'prompt_engineer', 'ml_tutor', 'tech_guide'];
            const otherIds = SCHOOL_TOOLS.filter(t => !priorityIds.includes(t.id) && !hiddenIds.includes(t.id)).map(t => t.id);
            setHomeToolIds([...priorityIds, ...otherIds]);

            // 5. Re-save Essential Defaults (since we cleared all)
            await AsyncStorage.setItem('settings', JSON.stringify(defaultSettings));
            await AsyncStorage.setItem('availableSubjects', JSON.stringify(defaultSubjects));

            Alert.alert("Reset All Data Complete", "App restored to original state.\n\nâ€¢ All data deleted\nâ€¢ Settings reset\nâ€¢ Roles & Subjects restored\nâ€¢ Cache cleared");
        } catch (e) {
            console.error("Reset Error", e);
            Alert.alert("Error", "Could not fully reset library.");
        }
    };

    const handleResetLibrary = () => {
        setShowResetWarning(true);
    };

    // NEW: Helper to save table widths to storage
    const handleSaveTableWidth = useCallback((sessionId: string, tableId: string, colIndex: number, width: number | null) => {
        if (!savedTableWidths.current[sessionId]) savedTableWidths.current[sessionId] = {};
        if (!savedTableWidths.current[sessionId][tableId]) savedTableWidths.current[sessionId][tableId] = {};

        if (width === null || width === undefined) {
            delete savedTableWidths.current[sessionId][tableId][colIndex];
        } else {
            savedTableWidths.current[sessionId][tableId][colIndex] = width;
        }

        // Save entire object to async storage (could be optimized, but ok for text data)
        AsyncStorage.setItem('savedTableWidths', JSON.stringify(savedTableWidths.current));
    }, []);

    // NEW: Handle Reverse Swap (Studio Item -> Replace Home Item)
    // ... (Removed in previous turn, ensuring clean slate) ...

    // NEW: Helper to show temporary toast message
    const showToast = (message: string) => {
        // Clear any existing timeout to prevent premature hiding
        if (toastTimeoutRef.current) {
            clearTimeout(toastTimeoutRef.current);
        }

        setToastMessage(message);

        toastTimeoutRef.current = setTimeout(() => {
            setToastMessage(null);
            toastTimeoutRef.current = null;
        }, 3000);
    };

    // NEW: Handle Delete Recent Activity Item
    const handleDeleteRecentActivity = (item: any) => {
        Alert.alert(
            "Delete Item",
            `Permanently delete "${item.title || 'Untitled'}"?`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: "destructive",
                    onPress: () => deleteSession(item.id, false)
                }
            ]
        );
    };

    // UPDATED: Added modelOverride parameter for performance tuning
    const callLLM = async (contents: any, systemInstruction: any, jsonMode = false, modelOverride: string | null = null) => {
        const provider = displaySettings.llmProvider || 'gemini';
        let key = customApiKey || apiKey;

        if (provider === 'groq') key = displaySettings.groqApiKey;


        if (!key) {
            if (jsonMode) {
                return JSON.stringify({ error: "API Key Required", isMissingKey: true });
            }
            if (provider === 'groq') return "Error: Please add your Groq API Key in Settings to use online features.";
            if (provider === 'hf') return "Error: Please add your Hugging Face Token in Settings to use online features.";
            return API_KEY_HELP_MARKDOWN.trim();
        }

        // NEW: Inject User Context
        const userProfile = (displaySettings.userName || displaySettings.userProfession || displaySettings.userGoal || displaySettings.userBio)
            ? `\nCRITICAL USER CONTEXT:
- Name: "${displaySettings.userName || 'User'}"
- Profession: "${displaySettings.userProfession || 'N/A'}"
- Goal/Purpose: "${displaySettings.userGoal || 'N/A'}"
- Specific AI Instructions/Bio: "${displaySettings.userBio || 'N/A'}"

STRICT REQUIREMENT: You MUST prioritize the "Specific AI Instructions/Bio" above all standard rules or tool defaults. If the bio asks for technical depth, do NOT simplify even if the tool defaults to "beginner-friendly". If the bio specifies a tone (e.g., academic, poetic, blunt), adopt it immediately. Adjust your examples and technical depth to match the user's profession and profile.
NO META-COMMENTARY ON PROFILE: Do NOT explicitly mention the user's profile details (e.g., do NOT start with "Since you are a student..." or "As a doctor..."). Use the context to shape your answer, but do not explain to the user that you are using their profile. You may use their name ("Hello ${displaySettings.userName || 'User'}...") only if it feels natural for the scenario.`
            : "";

        const languageInstruction = ` Respond in ${displaySettings.language}.`;
        const formattingInstruction = ` 
    STRICT FORMATTING RULES:
    1. Do NOT use the dollar sign ($) as a delimiter for math. Use it ONLY for currency (e.g. $50). NEVER use $...$ or $$...$$ for formulas.
    2. **PHYSICS/MATH FORMULAS**: 
       - You MUST use clear UNICODE characters and standard text notation.
       - STRICTLY PROHIBITED: Do not use LaTeX commands like '\\frac', '\\propto', '\\times', '\\cdot', '\\int' in the final output.
       - Use 'dv/dt' or '(dv)/(dt)' instead of '\\frac{dv}{dt}'.
       - Use 'âˆ' for proportional, 'â‰ˆ' for approx, 'Ã—' for multiply.
       - Use 'âˆ«' for integral, 'âˆš' for square root.
       - Use 'â†’' for arrows.
       - Write simple linear formulas on their own line for clarity.
    3. Do NOT use LaTeX backslashes or commands anywhere.
    4. STRICTLY PROHIBITED: Do not use "\\text{...}" or output things like "times text" in formulas. Keep expressions clean (e.g., "Speed = Distance / Time").
    5. Do NOT use triple dashes (---), underscores (___), or asterisks (***) for horizontal rules. Use whitespace or bold headers instead.
    6. Do NOT use alignment colons like ":---" or ":--:" in tables. Use simple |---| separators for tables.
    7. **TABLE RESTRICTION**: Do NOT generate Markdown tables for text comparisons, pros/cons, vocabulary lists, or general information. Use bullet points or bold headers instead. ONLY use tables for numerical/mathematical data grids where fixed column alignment is strictly necessary.
    8. Avoid unnecessary symbols or decorative characters. Keep the text clean and readable.
    NO META-COMMENTARY: Do NOT output internal thought processes, analysis of the user's request, or phrases like "The user is asking...". Start DIRECTLY with the answer.
    ${jsonMode ? "10. OUTPUT VALID JSON ONLY. No Markdown code fences. No conversational text." : ""}
    `;
        const fullSystemInstruction = systemInstruction + userProfile + languageInstruction + formattingInstruction;

        // Groq fallback loop: try models from priority list, newest â†’ oldest
        if (provider === 'groq') {
            let openAiMessages = [{ role: "system", content: fullSystemInstruction }];
            if (Array.isArray(contents)) {
                contents.forEach((c: any) => {
                    const r = c.role === 'model' ? 'assistant' : 'user';
                    const t = c.parts?.[0]?.text || "";
                    openAiMessages.push({ role: r, content: t });
                });
            } else {
                openAiMessages.push({ role: "user", content: contents });
            }

            let groqModelsToTry = [...GROQ_MODELS];

            if (modelOverride) {
                // Direct override â€” use only that model
                groqModelsToTry = [modelOverride];
            } else {
                // Apply speed/quality priority
                const groqPriority = displaySettings.groqModelPriority || 'quality';
                if (groqPriority === 'speed') {
                    groqModelsToTry = groqModelsToTry.filter(m => m !== 'llama-3.1-8b-instant');
                    groqModelsToTry.unshift('llama-3.1-8b-instant');
                } else {
                    groqModelsToTry = groqModelsToTry.filter(m => m !== 'llama-3.3-70b-versatile');
                    groqModelsToTry.unshift('llama-3.3-70b-versatile');
                }
                // Custom model takes highest priority
                if (displaySettings.groqCustomModel?.trim()) {
                    const custom = displaySettings.groqCustomModel.trim();
                    groqModelsToTry = groqModelsToTry.filter(m => m !== custom);
                    groqModelsToTry.unshift(custom);
                }
            }

            let lastGroqError: any = null;
            for (const groqModel of groqModelsToTry) {
                try {
                    console.log(`Attempting LLM call with groq: ${groqModel}`);
                    const payload: any = {
                        model: groqModel,
                        messages: openAiMessages
                    };
                    if (jsonMode) {
                        payload.response_format = { type: "json_object" };
                    }
                    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
                        body: JSON.stringify(payload)
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.choices?.[0]?.message?.content) {
                            return data.choices[0].message.content;
                        }
                        throw new Error("Invalid response format");
                    }
                    const errText = await response.text();
                    // Only retry on rate-limit (429) or server errors; fail on auth (401/403)
                    if (response.status === 401 || response.status === 403) {
                        throw new Error(`Groq Auth Error: ${response.status} - ${errText}`);
                    }
                    console.log(`Groq model ${groqModel} failed (${response.status}), trying next...`);
                    lastGroqError = new Error(`Groq API Error: ${response.status} - ${errText}`);
                } catch (e: any) {
                    if (e.message?.includes('Auth Error')) {
                        console.error('Groq auth error â€” stopping fallback:', e);
                        return `Error: Groq authentication failed. Please check your API key in Settings.`;
                    }
                    lastGroqError = e;
                    console.log(`Groq model ${groqModel} threw error, trying next...`);
                }
            }
            console.error('All Groq models failed:', lastGroqError);
            return `Error: Unable to get a response from Groq. Details: ${lastGroqError?.message || lastGroqError}`;
        }

        // Determine model order based on priority (Gemini Fallback)
        let modelsToTry = [...TEXT_MODELS];

        // NEW: Handle Model Override (High Priority)
        if (modelOverride) {
            // Remove override from list if exists to avoid dupes, then unshift to top
            modelsToTry = modelsToTry.filter(m => m !== modelOverride);
            modelsToTry.unshift(modelOverride);
        } else {
            // Standard Priority Logic
            if (displaySettings.modelPriority === 'speed') {
                const speedModel = "gemini-2.5-flash-lite"; // Updated to flash-lite as primary speed model
                modelsToTry = modelsToTry.filter(m => m !== speedModel);
                modelsToTry.unshift(speedModel);
            } else {
                const qualityModel = "gemini-2.5-flash-preview-09-2025";
                modelsToTry = modelsToTry.filter(m => m !== qualityModel);
                modelsToTry.unshift(qualityModel);
            }

            // Insert User's Custom Model as First Priority (if no override)
            if (displaySettings.customTextModel && displaySettings.customTextModel.trim()) {
                const custom = displaySettings.customTextModel.trim();
                modelsToTry = modelsToTry.filter(m => m !== custom);
                modelsToTry.unshift(custom);
            }
        }

        let lastError = null; // Track the last error encountered

        for (const modelId of modelsToTry) {
            try {
                console.log(`Attempting LLM call with: ${modelId}`);

                const payload: any = {
                    systemInstruction: { parts: [{ text: fullSystemInstruction }] },
                    contents: Array.isArray(contents) ? contents : [{ role: "user", parts: [{ text: contents }] }]
                };

                // ADDED: Force JSON mode if requested
                if (jsonMode) {
                    payload.generationConfig = {
                        ...payload.generationConfig,
                        responseMimeType: "application/json"
                    };
                }

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${key}`, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                });

                if (response.status === 429) {
                    console.warn(`Model ${modelId} hit rate limit (429). Switching to fallback...`);
                    lastError = new Error("API limits reached");
                    continue;
                }

                if (response.status >= 500) {
                    console.warn(`Model ${modelId} failed with server error ${response.status}. Switching to fallback...`);
                    lastError = new Error(`Server error ${response.status}`);
                    continue;
                }

                if (!response.ok) {
                    let errorDetails = "";
                    try {
                        const errorBody = await response.json();
                        errorDetails = errorBody.error?.message || JSON.stringify(errorBody);
                    } catch (e: any) {
                        errorDetails = await response.text();
                    }
                    console.warn(`Model ${modelId} returned error status ${response.status}: ${errorDetails}`);
                    lastError = new Error(`Error status ${response.status}: ${errorDetails}`);
                    continue;
                }

                const data = await response.json();
                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content) {
                    if (isRateLimited) setIsRateLimited(false);

                    // NEW: Update active model on success
                    setActiveModelId(modelId);

                    let text = data.candidates[0].content.parts[0].text;
                    // Strictly remove double dollar signs ($$) which are often used for LaTeX block math
                    if (text) {
                        text = text.replace(/\$\$/g, '');
                    }
                    return text;
                } else {
                    console.warn(`Model ${modelId} returned no content (likely safety filter or empty).`);
                    lastError = new Error("No content returned");
                    continue;
                }

            } catch (e) {
                console.error(`Connection error with ${modelId}:`, e);
                lastError = e;
                continue;
            }
        }

        // Analyze the last error to return a specific reason
        if (lastError) {
            const errorMsg = (lastError as any).message || lastError.toString();

            if (errorMsg.includes("Network request failed") || errorMsg.includes("network")) {
                return "Error: Network request failed. Please check your internet connection.";
            }

            if (errorMsg.includes("API limits")) {
                setIsRateLimited(true);
                return "Error: API limits reached.";
            }
        }

        setIsRateLimited(true);
        return "Error: Unable to get a response. Details: " + (lastError ? ((lastError as any).message || lastError.toString()) : "Unknown Error");
    };

    const handleTestConnection = async () => {
        setApiConnectionStatus("testing");
        const provider = displaySettings.llmProvider || 'gemini';
        let key = customApiKey || apiKey;

        if (provider === 'groq') key = displaySettings.groqApiKey;


        if (!key) {
            setApiConnectionStatus("failed");
            Alert.alert("Failed", `Please enter your ${provider === 'groq' ? 'Groq' : 'Gemini'} API Key first.`);
            return;
        }

        if (provider === 'groq') {
            let groqTestModels = [...GROQ_MODELS];
            const groqPriority = displaySettings.groqModelPriority || 'quality';
            if (groqPriority === 'speed') {
                groqTestModels = groqTestModels.filter(m => m !== 'llama-3.1-8b-instant');
                groqTestModels.unshift('llama-3.1-8b-instant');
            } else {
                groqTestModels = groqTestModels.filter(m => m !== 'llama-3.3-70b-versatile');
                groqTestModels.unshift('llama-3.3-70b-versatile');
            }
            if (displaySettings.groqCustomModel?.trim()) {
                const custom = displaySettings.groqCustomModel.trim();
                groqTestModels = groqTestModels.filter(m => m !== custom);
                groqTestModels.unshift(custom);
            }

            for (const groqModel of groqTestModels) {
                try {
                    const response = await fetch(`https://api.groq.com/openai/v1/chat/completions`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
                        body: JSON.stringify({ model: groqModel, messages: [{ role: "user", content: "Hello" }] })
                    });
                    if (response.ok) {
                        setApiConnectionStatus("success");
                        setActiveModelId(groqModel);
                        Alert.alert("Success", `Connection established! (Groq: ${groqModel})`);
                        if (!displaySettings.smartBio) generateSmartBio();
                        return;
                    }
                    const errText = await response.text();
                    if (response.status === 401 || response.status === 403) {
                        setApiConnectionStatus("failed");
                        Alert.alert("Failed", "Invalid Groq API Key.");
                        return;
                    }
                    console.log(`Groq test: model ${groqModel} failed (${response.status}), trying next...`);
                } catch (e) {
                    console.log(`Groq test: ${groqModel} threw error, trying next...`);
                }
            }
            setApiConnectionStatus("failed");
            Alert.alert("Failed", "All Groq models failed. Check your API Key or network.");
            return;
        }


        // UPDATED: Check against models in correct priority order (Custom -> Priority -> Fallbacks)
        // This ensures the test validates the same model that callLLM would select first.
        let testModels = [...TEXT_MODELS];

        if (displaySettings.modelPriority === 'speed') {
            const speedModel = "gemini-2.5-flash-lite";
            testModels = testModels.filter(m => m !== speedModel);
            testModels.unshift(speedModel);
        } else {
            const qualityModel = "gemini-2.5-flash-preview-09-2025";
            testModels = testModels.filter(m => m !== qualityModel);
            testModels.unshift(qualityModel);
        }

        if (displaySettings.customTextModel && displaySettings.customTextModel.trim()) {
            const custom = displaySettings.customTextModel.trim();
            testModels = testModels.filter(m => m !== custom);
            testModels.unshift(custom);
        }

        for (const testModel of testModels) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${testModel}:generateContent?key=${key}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ role: "user", parts: [{ text: "Hello" }] }]
                    })
                });

                if (response.ok) {
                    setApiConnectionStatus("success");
                    setActiveModelId(testModel); // NEW: Update active model
                    Alert.alert("Success", `Connection established! (Active: ${testModel})`);

                    // NEW: Automatically generate bio if it's currently empty
                    if (!displaySettings.smartBio) {
                        generateSmartBio();
                    }
                    return;
                }
            } catch (e) {
                console.log(`Connection test failed for ${testModel}, trying next...`);
            }
        }

        setApiConnectionStatus("failed");
        Alert.alert("Failed", "Invalid API Key or Network Issue. Could not connect to any supported model.");
    };


    // NEW: Handler for New Role Button Press
    // NEW: Handle Delete Custom Role Logic
    const handleDeleteRole = async (roleId: string) => {
        const updatedTools = customTools.filter((r: any) => r.id !== roleId);
        setCustomTools(updatedTools);
        await AsyncStorage.setItem('customTools', JSON.stringify(updatedTools));
        showToast("Role Deleted");
    };

    const handleRoleLongPress = (tool: any) => {
        if (!tool.isCustom) return;

        Alert.alert(
            "Delete Role",
            `Are you sure you want to delete "${tool.title}"?`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: "destructive",
                    onPress: () => handleDeleteRole(tool.id)
                }
            ]
        );
    };

    const handleNewRolePress = () => {
        Alert.alert(
            "Create New Role",
            "Choose a creation method:",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Auto-Generate (AI)",
                    onPress: handleGenerateRoleFromProfession
                },
                {
                    text: "Create Manually",
                    onPress: () => setShowRoleCreator(true)
                }
            ]
        );
    };

    // NEW: Add Custom Role Function (Updated with Auto-Prompt Generation)
    const handleAddCustomRole = async () => {
        if (!newRoleData.title.trim() || !newRoleData.instructions.trim()) {
            Alert.alert("Incomplete", "Please provide a Title (e.g. 'Math Teacher') and Instructions.");
            return;
        }

        setShowRoleCreator(false); // Close modal first
        setAppMode("generating");
        setGenerationData(`Designing ${newRoleData.title}...`);

        try {
            const roleTitle = newRoleData.title.trim();
            const roleInstructions = newRoleData.instructions.trim();

            // Generate prompts automatically using LLM
            const prompt = `Act as a Prompt Engineer.
          I am creating a new AI Persona for my app.
          
          Persona Title: "${roleTitle}"
          System Instructions: "${roleInstructions}"
          
          Task: Generate 6 diverse, useful, and creative "Quick Prompts" (Quick Ideas) that a user might click to interact with this specific persona.
          
          Return strictly a JSON Array of objects with keys:
          - "label": Short title (max 15 chars)
          - "prompt": Full prompt text for the user to send.
          
          Example: [{"label": "Solve Problem", "prompt": "Help me solve this math problem step-by-step..."}]
          
          Output VALID JSON ONLY.`;

            let generatedPrompts = [];

            try {
                const raw = await callLLM(prompt, "System Architect", true);
                const clean = extractJSON(raw);
                const parsed = JSON.parse(clean);
                if (Array.isArray(parsed)) {
                    generatedPrompts = (parsed as any[]).slice(0, 8); // Limit to 8
                }
            } catch (e) {
                console.warn("Failed to generate quick prompts for role", e);
                // Fallback: No quick prompts, but role is still created
            }

            // Automatically assign a color based on index to cycle through the palette
            const colorIndex = customTools.length % AUTO_COLORS.length;
            const assignedColor = AUTO_COLORS[colorIndex];

            const newTool = {
                id: `custom_${generateId()}`,
                title: roleTitle.substring(0, 15), // Limit length
                role: "Custom Role",
                type: "lesson",
                actionLabel: "Start",
                // Store the specific system prompt defined by the user
                systemPrompt: roleInstructions,
                placeholder: `Ask ${roleTitle}...`,
                color: assignedColor, // Auto-assigned color
                iconName: newRoleData.icon,
                isCustom: true,
                quickPrompts: generatedPrompts // Save generated prompts
            };

            const updatedTools = [...customTools, newTool];
            setCustomTools(updatedTools);
            await AsyncStorage.setItem('customTools', JSON.stringify(updatedTools));

            setNewRoleData({ title: "", instructions: "", icon: "Bot" });
            setAppMode("idle");
            Alert.alert("Success", `${roleTitle} created with ${generatedPrompts.length} quick ideas!`);

        } catch (e) {
            console.error("Role Creation Error", e);
            setAppMode("idle");
            Alert.alert("Error", "Could not create role. Please try again.");
        }
    };

    // NEW: Function to check availability of custom model
    const handleCheckModelAvailability = async () => {
        const modelToCheck = displaySettings.customTextModel?.trim();
        const provider = displaySettings.llmProvider || 'gemini';
        let key = customApiKey || apiKey;

        if (provider === 'groq') key = displaySettings.groqApiKey;


        if (!modelToCheck) {
            Alert.alert("Input Required", "Please enter a Custom Model ID first.");
            return;
        }
        if (!key) {
            Alert.alert("API Key Required", `Please enter your ${provider === 'groq' ? 'Groq' : 'Gemini'} API Key first.`);
            return;
        }

        setIsCheckingModel(true);

        try {
            // 1. Check User's Custom Model
            console.log(`Verifying custom model: ${modelToCheck} on ${provider}`);
            let response;
            if (provider === 'groq') {
                response = await fetch(`https://api.groq.com/openai/v1/chat/completions`, {
                    method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
                    body: JSON.stringify({ model: modelToCheck, messages: [{ role: "user", content: "Hello" }] })
                });
            } else {
                response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelToCheck}:generateContent?key=${key}`, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
                });
            }

            if (response.ok) {
                setIsCheckingModel(false);

                // NEW: Add to saved list if not default and not already saved
                if (!TEXT_MODELS.includes(modelToCheck) && !displaySettings.savedCustomModels?.includes(modelToCheck)) {
                    const newSaved = [...(displaySettings.savedCustomModels || []), modelToCheck];
                    saveSettings({ savedCustomModels: newSaved });
                }

                Alert.alert("Success", `"${modelToCheck}" is available and active!`);
                return;
            }

            throw new Error(`Status ${response.status}`);

        } catch (e) {
            console.log("Custom model check failed, checking defaults...", e);

            // 2. Fallback: Check Standard Models to suggest alternatives
            const workingModels = [];
            for (const m of TEXT_MODELS) {
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${key}`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: [{ parts: [{ text: "Hi" }] }] })
                    });
                    if (res.ok) workingModels.push(m);
                } catch (err) {
                    // Ignore individual failures during fallback check
                }
            }

            setIsCheckingModel(false);

            let msg = `Could not connect to "${modelToCheck}".\nIt may be misspelled or your API key doesn't have access to it.`;

            if (workingModels.length > 0) {
                msg += `\n\nâœ… Verified models for your key:\nâ€¢ ${workingModels.join('\nâ€¢ ')}`;
            } else {
                msg += "\n\nâŒ No working models detected. Please check your API Key and internet connection.";
            }

            Alert.alert("Model Unavailable", msg);
        }
    };



    // UPDATED: Added voiceOverride parameter to support previews
    // UPDATED: Removed multiSpeakerConfig support as it is now obsolete
    const generateGeminiTTS = async (text: string, voiceOverride: string | null = null) => {
        const key = customApiKey || apiKey;
        if (!key) throw new Error("No API Key");

        let rateLimitHit = false; // NEW: Track rate limit specifically

        for (const modelId of TTS_MODELS) {
            try {
                console.log(`Attempting TTS with: ${modelId}`);

                // Helper to construct payload dynamically
                const buildPayload = () => {
                    const p: any = {
                        contents: [{ parts: [{ text: text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            // FIXED: Enforce LINEAR16 (PCM) and 24kHz to match WAV header and avoid artifacts
                            // Fixed: audioConfig is not supported in generationConfig for this endpoint
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: {
                                        voiceName: voiceOverride || displaySettings.voice || "Kore"
                                    }
                                }
                            }
                        }
                    };
                    return p;
                };

                let payload = buildPayload();

                let response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${key}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                });

                if (response.status === 429) {
                    console.warn(`TTS Model ${modelId} rate limited (429).`);
                    // Mark flag but try next model
                    rateLimitHit = true;
                    continue;
                }

                if (!response.ok) {
                    const errText = await response.text();
                    console.warn(`TTS Model ${modelId} failed with status ${response.status}: ${errText}`);
                    continue; // Try next model on error
                }

                const data = await response.json();
                const pcmData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;

                if (pcmData) {
                    return pcmData;
                } else {
                    console.warn(`TTS Model ${modelId} returned no audio data.`);
                    continue;
                }
            } catch (e) {
                console.warn(`TTS Error on ${modelId}:`, e);
                continue;
            }
        }

        if (rateLimitHit) throw new Error("API_LIMIT_REACHED");
        throw new Error("All TTS models failed to generate audio.");
    };

    // NEW: Function to play or generate a preview for a specific voice
    const playVoicePreview = async (voiceName: string) => {
        const key = customApiKey || apiKey;
        // Stop any currently playing sound to prevent overlap
        if (currentSound.current) {
            try {
                currentSound.current.pause();
            } catch (e) { }
            currentSound.current = null;
        }

        const docDir = fs.documentDirectory || FileSystem.documentDirectory;
        // Unique filename for this voice's preview
        const fileName = `preview_${voiceName}.wav`;
        const uri = docDir + fileName;

        try {
            // 1. Check if we already have a cached preview
            const info = await fs.getInfoAsync(uri);

            if (!info.exists) {
                // 2. If not, verify we can generate one
                if (!key) {
                    showToast("Add API Key to hear previews");
                    return;
                }

                showToast(`Generating preview for ${voiceName}...`);

                // 3. Generate short sample using the specific voice override
                const sampleText = `Hello! I am ${voiceName}. I can read your stories and notes.`;
                const pcm = await generateGeminiTTS(sampleText, voiceName);

                // 4. Save to cache
                const wav = pcmToWav(pcm);
                await fs.writeAsStringAsync(uri, wav, { encoding: fs.EncodingType.Base64 });
            } else {
                showToast(`Playing ${voiceName}...`);
            }

            // 5. Play the file (cached or newly generated)
            const player = createAudioPlayer(uri);
            player.play();
            currentSound.current = player;

        } catch (e: any) {
            console.warn("Preview generation/playback failed", e);
            if (e.message !== "API_LIMIT_REACHED") {
                showToast("Could not play preview");
            }
        }
    };

    // --- TTS Helper ---
    // Chunking logic separated to ensure consistency between Play and Download
    const getChunks = useCallback((text: string) => {
        if (!text) return { chunks: [], offsets: [] };

        const cleanText = cleanTextForDisplay(text);

        // FIXED: Reduced Limit to 3000 to prevent API 404/Length errors with Gemini TTS
        const CHUNK_LIMIT = 3000;

        const chunks = [];
        const offsets = [];

        let currentChunk = "";
        let chunkStartOffset = 0;

        // Split by logical lines (paragraphs) first to maintain flow
        // cleanTextForDisplay ensures lines are non-empty and trimmed
        const lines = cleanText.split('\n');

        for (let i = 0; i < lines.length; i++) {
            // Re-attach newline for accurate offset calculation, except for the absolute last line
            const isLast = i === lines.length - 1;
            const lineBlock = lines[i] + (isLast ? "" : "\n");

            if ((currentChunk + lineBlock).length <= CHUNK_LIMIT) {
                currentChunk += lineBlock;
            } else {
                // Current chunk is full, push it
                if (currentChunk.length > 0) {
                    chunks.push(currentChunk);
                    offsets.push(chunkStartOffset);
                    chunkStartOffset += currentChunk.length;
                    currentChunk = "";
                }

                // If the single line fits in a new chunk, use it
                if (lineBlock.length <= CHUNK_LIMIT) {
                    currentChunk = lineBlock;
                } else {
                    // Line is massive (rare), split by sentences
                    const sentences = lineBlock.match(/[^.!?\n]+[.!?\n]+|[^.!?\n]+$/g) || [lineBlock];

                    for (const sentence of sentences) {
                        if ((currentChunk + sentence).length <= CHUNK_LIMIT) {
                            currentChunk += sentence;
                        } else {
                            if (currentChunk.length > 0) {
                                chunks.push(currentChunk);
                                offsets.push(chunkStartOffset);
                                chunkStartOffset += currentChunk.length;
                                currentChunk = "";
                            }

                            // Handle giant sentence (fallback)
                            if (sentence.length > CHUNK_LIMIT) {
                                let temp = sentence;
                                while (temp.length > 0) {
                                    const part = temp.substring(0, CHUNK_LIMIT);
                                    chunks.push(part);
                                    offsets.push(chunkStartOffset);
                                    chunkStartOffset += part.length;
                                    temp = temp.substring(CHUNK_LIMIT);
                                }
                            } else {
                                currentChunk = sentence;
                            }
                        }
                    }
                }
            }
        }

        // Push remaining
        if (currentChunk.length > 0) {
            chunks.push(currentChunk);
            offsets.push(chunkStartOffset);
        }

        return { chunks, offsets };
    }, []);

    const handleDownloadAudio = async () => {
        if (!readingSession) return;
        setIsTtsDownloading(true);
        setTtsDownloadProgress(0);

        let keepAliveSound: any = null;
        try {
            const player = createAudioPlayer({ uri: `data:audio/wav;base64,${SILENT_WAV}` });
            player.loop = true;
            player.volume = 0;
            player.play();
            keepAliveSound = player;
        } catch (e) {
            console.warn("Could not start keep-alive sound", e);
        }

        const text = readingSession.messages[0].content;

        async function proceedDownload() {
            try {
                // NEW: Check if Merged File already exists based on Full Text
                const voice = displaySettings.voice || "Kore";
                const cleanText = cleanTextForDisplay(text);
                const fullHash = simpleHash(cleanText + voice);
                const safeTitle = getSafeFileName(readingSession.title);
                const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                const mergedFileUri = `${docDir}tts_${fullHash}_${safeTitle}.wav`;

                const existingInfo = await fs.getInfoAsync(mergedFileUri);
                if (existingInfo.exists) {
                    Alert.alert("Exists", "Audio already downloaded.");
                    return;
                }

                const { chunks } = getChunks(text);
                let savedCount = 0;
                const key = customApiKey || apiKey;

                if (!key) {
                    Alert.alert("Error", "API Key required to download audio.");
                    return;
                }

                showToast("Online TTS file downloading, please wait...");

                // ACCUMULATOR for Merging
                const pcmParts = [];
                let totalPcmLength = 0;

                for (let i = 0; i < chunks.length; i++) {
                    const chunk = chunks[i];
                    if (!chunk.trim()) {
                        savedCount++;
                        continue;
                    }

                    try {
                        // Pass the global speaker config to every chunk generation
                        const pcmBase64 = await generateGeminiTTS(chunk, null);
                        // Decode to binary
                        const pcmBytes = decodeBase64(pcmBase64);

                        // NEW: Strip WAV Header (RIFF) if present to avoid static noise artifacts when merging
                        let rawBytes = pcmBytes;
                        if (pcmBytes.length > 44 &&
                            pcmBytes[0] === 82 && // R
                            pcmBytes[1] === 73 && // I
                            pcmBytes[2] === 70 && // F
                            pcmBytes[3] === 70    // F
                        ) {
                            console.log("Stripping WAV header from chunk");
                            rawBytes = pcmBytes.slice(44);
                        }

                        pcmParts.push(rawBytes);
                        totalPcmLength += rawBytes.length;

                        // Speed Optimization: Removed 4s delay. Small yield for UI responsiveness.
                        await new Promise(r => setTimeout(r, 50));
                    } catch (e: any) {
                        if (e.message === "API_LIMIT_REACHED") throw e;
                        console.warn("Chunk download failed", e);
                        throw new Error(`Failed to generate part ${i + 1}`);
                    }

                    savedCount++;
                    setTtsDownloadProgress(Math.floor((savedCount / chunks.length) * 100));
                }

                // MERGE PARTS
                if (pcmParts.length > 0) {
                    showToast("Merging Audio...");
                    await new Promise(r => setTimeout(r, 100)); // Yield UI

                    // Create buffer with WAV header (44 bytes) + Total PCM data
                    const mergedBuffer = new Uint8Array(44 + totalPcmLength);
                    const view = new DataView(mergedBuffer.buffer);

                    // WRITE WAV HEADER
                    const sampleRate = 24000;
                    writeString(view, 0, 'RIFF');
                    view.setUint32(4, 36 + totalPcmLength, true);
                    writeString(view, 8, 'WAVE');
                    writeString(view, 12, 'fmt ');
                    view.setUint32(16, 16, true);
                    view.setUint16(20, 1, true); // PCM
                    view.setUint16(22, 1, true); // Mono
                    view.setUint32(24, sampleRate, true);
                    view.setUint32(28, sampleRate * 2, true); // ByteRate
                    view.setUint16(32, 2, true); // BlockAlign
                    view.setUint16(34, 16, true); // BitsPerSample
                    writeString(view, 36, 'data');
                    view.setUint32(40, totalPcmLength, true);

                    // COPY PCM DATA
                    let offset = 44;
                    for (const part of pcmParts) {
                        mergedBuffer.set(part, offset);
                        offset += part.length;
                    }

                    // ENCODE TO BASE64 & SAVE
                    const finalBase64 = encodeBase64(mergedBuffer);
                    await fs.writeAsStringAsync(mergedFileUri, finalBase64, { encoding: fs.EncodingType.Base64 });
                }

                // Update session with hasAudio AND the specific voice used
                const currentVoice = displaySettings.voice || "Kore";
                const updatedSession = { ...readingSession, hasAudio: true, voice: currentVoice };

                await persistSession(updatedSession);
                setReadingSession(updatedSession);

                // Refresh Library List to show new file
                loadAudioFiles();

                Alert.alert("Downloaded", "Audio saved to library as a single file!");
            } catch (e: any) {
                console.error(e);
                if (e.message === "API_LIMIT_REACHED") {
                    Alert.alert(
                        "Limit Reached",
                        "Online TTS is not possible for today. Your API key limit is reached for today."
                    );
                } else {
                    Alert.alert("Error", "Could not download audio. Check internet/API limit.");
                }
            } finally {
                if (keepAliveSound) {
                    try {
                        await keepAliveSound.unloadAsync();
                    } catch (e: any) { }
                }
                setIsTtsDownloading(false);
                setTtsDownloadProgress(0);
            }
        }

        if (text.length > 60000) {
            Alert.alert(
                "Large File Warning",
                "This chapter is very long. Merging it into a single file might fail on some devices. Proceed?",
                [
                    { text: "Cancel", style: "cancel", onPress: () => setIsTtsDownloading(false) },
                    { text: "Proceed", onPress: () => proceedDownload() }
                ]
            );
        } else {
            await proceedDownload();
        }
    };

    // --- TTS LOGIC ---

    // FIXED: Restored functionality to handle Audio Export/Download
    const handleExportAudio = async () => {
        // Trigger the internal download logic for offline playback
        await handleDownloadAudio();
    };

    // NEW: Handle Export Text (Save to Device) from Reader Mode
    const handleReaderExport = async () => {
        if (!readingSession) return;

        // Determine content: use translation if current lang is not English/Original, else use message content
        const currentLang = readingSession.language || displaySettings.language || 'English';
        const content = readingSession.translations?.[currentLang] || readingSession.messages?.[0]?.content || "";

        if (!content.trim()) {
            Alert.alert("Empty", "No content to export.");
            return;
        }

        const title = readingSession.title || "Exported Content";
        const safeName = title.replace(/[<>:"/\\|?*]/g, '-').substring(0, 50);
        const filename = `${safeName}.txt`;

        // ANDROID: Use Storage Access Framework (Direct "Save To" Folder)
        if (Platform.OS === 'android') {
            try {
                let directoryUri = await AsyncStorage.getItem('savedExportDirectory');

                const attemptSave = async (uri: string) => {
                    try {
                        const newFileUri = await fs.StorageAccessFramework.createFileAsync(uri, filename, 'text/plain');
                        await fs.writeAsStringAsync(newFileUri, content, { encoding: fs.EncodingType.UTF8 });
                        return true;
                    } catch (e: any) {
                        console.log("Export failed with saved URI:", e);
                        return false;
                    }
                };

                let success = false;
                if (directoryUri) {
                    success = await attemptSave(directoryUri);
                }

                if (!success) {
                    const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                    if (permissions.granted) {
                        directoryUri = permissions.directoryUri;
                        await AsyncStorage.setItem('savedExportDirectory', directoryUri);
                        success = await attemptSave(directoryUri);
                    }
                }

                if (success) {
                    showToast("Saved to Device");
                } else {
                    Alert.alert("Save Failed", "Could not save the file.");
                }
            } catch (e) {
                console.error("Android Export Error", e);
                Alert.alert("Save Failed", "An error occurred while accessing storage.");
            }
        } else {
            // iOS: Use Share Sheet
            try {
                if (!(await Sharing.isAvailableAsync())) {
                    Alert.alert("Error", "Sharing is not available.");
                    return;
                }
                const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
                const fileUri = cacheDir + filename;
                await fs.writeAsStringAsync(fileUri, content, { encoding: fs.EncodingType.UTF8 });
                await Sharing.shareAsync(fileUri, {
                    dialogTitle: `Export: ${title}`
                });
            } catch (e) {
                Alert.alert("Export Failed", "Could not export content.");
            }
        }
    };

    const speakNextChunk = useCallback(async () => {
        const currentSessionId = speechSessionId.current;
        // --- SMART MULTI-SPEAKER CONTEXT HANDLING REMOVED ---
        // Originally injected speaker names for context. Now obsolete.

        // UPDATED: Destructure new state properties including speakerNames and lastSpeaker
        const { chunks, index, offsets, isActive, id, title } = speechState.current;

        // Check if this execution belongs to the active session
        if (!isActive || id !== currentSessionId) return;

        if (index >= chunks.length) {
            setTtsStatus('stopped');
            setSpeechRange(null);
            speechState.current.isActive = false;

            // FIX: Only trigger auto-advance if this was a Story/Article playback
            // Word pronunciations use title "Word Pronunciation" or similar
            if (speechState.current.title !== "Word Pronunciation") {
                setTtsFinishedNaturally(Date.now());
            }
            return;
        }

        const originalChunk = chunks[index];
        const globalChunkOffset = offsets[index]; // Start of this chunk in full text
        const resumeOffset = speechState.current.resumeOffsetInChunk || 0;

        if (!originalChunk || !originalChunk.trim()) {
            speechState.current.index += 1;
            speechState.current.resumeOffsetInChunk = 0;
            speakNextChunk();
            return;
        }

        const langCode = displaySettings.offlineTtsLanguage || LANGUAGE_CODES[displaySettings.language] || 'en-GB';
        const key = customApiKey || apiKey;
        const docDir = fs.documentDirectory || FileSystem.documentDirectory;

        let textForTts = originalChunk;



        // --- HELPER DEFINITIONS (Moved Up) ---

        // Helper to recursively prefetch subsequent chunks in background
        const triggerPrefetchChain = async (startIndex: number) => {
            // Stop if reached end or session changed
            const { chunks } = speechState.current;
            if (startIndex >= chunks.length) return;
            if (speechSessionId.current !== currentSessionId) return;

            const chunk = chunks[startIndex];
            if (!chunk || !chunk.trim()) {
                // Skip empty, go next
                await triggerPrefetchChain(startIndex + 1);
                return;
            }

            // FIXED: Match hash logic with playback (Text + Voice only)
            // Note: Ideally we predict context here too, but simple hash is safer for now.
            // If context injection changes the hash significantly, playback will just miss cache and regen.
            const hash = simpleHash(chunk + (displaySettings.voice || "Kore"));
            const safeTitle = getSafeFileName(title);

            // Try new format first
            let uri = `${docDir}tts_${hash}_${safeTitle}.wav`;

            // Prevent duplicate downloads for same file across chains
            if (speechState.current.pendingDownloads.has(uri)) {
                await triggerPrefetchChain(startIndex + 1);
                return;
            }

            try {
                // Check new format
                let info = await fs.getInfoAsync(uri);

                // Check old format if new doesn't exist
                if (!info.exists) {
                    const oldUri = `${docDir}tts_${hash}.wav`;
                    info = await fs.getInfoAsync(oldUri);
                }

                if (!info.exists) {
                    // Added check for onlineTtsEnabled to prevent background downloads when in offline mode
                    if (key && !isRateLimited && !onlineTTSBroken.current && displaySettings.onlineTtsEnabled) {
                        speechState.current.pendingDownloads.add(uri);

                        // Increased delay to 4000ms to stay within rate limits (15 RPM) while prefetching smaller chunks
                        await new Promise(r => setTimeout(r, 4000));

                        if (speechSessionId.current !== currentSessionId) {
                            speechState.current.pendingDownloads.delete(uri);
                            return;
                        }

                        try {
                            const pcm = await generateGeminiTTS(chunk, null);
                            const wav = pcmToWav(pcm);
                            await fs.writeAsStringAsync(uri, wav, { encoding: fs.EncodingType.Base64 });
                        } catch (err) {
                            console.warn("Prefetch gen failed", err);
                            // If one fails, cleanup and stop chain to prevent error loop
                            speechState.current.pendingDownloads.delete(uri);
                            return;
                        }

                        speechState.current.pendingDownloads.delete(uri);

                        // Successfully downloaded, trigger next
                        await triggerPrefetchChain(startIndex + 1);
                    }
                } else {
                    // Already exists, check next immediately
                    await triggerPrefetchChain(startIndex + 1);
                }
            } catch (e) {
                console.warn("Prefetch chain error", e);
                if (speechState.current.pendingDownloads) speechState.current.pendingDownloads.delete(uri);
            }
        };

        const fallbackToOffline = async () => {
            if (speechSessionId.current !== currentSessionId) return;

            // 1. CRITICAL FIX: Unload any existing online audio to release Audio Focus
            if (currentSound.current) {
                try {
                    currentSound.current.pause(); // Stop playback first
                    await currentSound.current.unloadAsync();
                } catch (e: any) {
                    // Fallback if unloadAsync fails (e.g. expo-audio vs expo-av differences)
                    try { currentSound.current.remove(); } catch (err) { }
                }
                currentSound.current = null;
            }

            // 2. Stop any pending speech to reset the engine
            await Speech.stop();

            setIsOnlinePlayback(false); // Enable highlights for offline

            // For offline, we MUST slice the text because we can't seek easily in the native speech queue
            let textToSpeak = originalChunk.substring(resumeOffset);

            // Apply comprehensive text cleaning (same as reader mode)
            textToSpeak = cleanTextForDisplay(textToSpeak);

            // SILENT CLEANUP: Replace unwanted symbols with spaces to preserve length/sync for highlighting
            textToSpeak = textToSpeak.replace(/(:?-{3,}:?)|[|$]/g, (match: string) => ' '.repeat(match.length));

            const hasDevanagari = /[\u0900-\u097F]/.test(textToSpeak);

            // Logic to determine language and voice
            let languageToUse = displaySettings.offlineTtsLanguage || 'en-GB';
            let voiceIdentifier = displaySettings.offlineVoice;

            // If a specific voice is selected, use its language code as base
            if (voiceIdentifier) {
                const selectedVoice = availableVoices.find(v => v.identifier === voiceIdentifier);
                if (selectedVoice) {
                    languageToUse = selectedVoice.code;
                }
            }

            // Devanagari Override: Force Hindi if text is Hindi
            // BUT: If the user explicitly selected a Hindi voice, keep it.
            // If they selected a non-Hindi voice, switch to a Hindi voice.
            if (hasDevanagari) {
                if (languageToUse !== 'hi-IN') {
                    // Switch to Hindi
                    languageToUse = 'hi-IN';
                    // Try to find a fallback Hindi voice (any) since the selected one is not Hindi
                    const anyHindiVoice = availableVoices.find(v => v.code === 'hi-IN');
                    voiceIdentifier = anyHindiVoice?.identifier;
                    console.log("TTS: Auto-switched to Hindi voice for Devanagari text");
                }
                // If languageToUse IS 'hi-IN', we keep voiceIdentifier (the user's selected Hindi voice)
            }

            // Debug logging removed

            // Check if text is empty after cleanup
            if (!textToSpeak.trim()) {
                if (speechState.current.isActive && speechSessionId.current === currentSessionId) {
                    speechState.current.index += 1;
                    speechState.current.resumeOffsetInChunk = 0;
                    speakNextChunk();
                }
                return;
            }

            let lastBoundaryUpdate = 0;

            Speech.speak(textToSpeak, {
                rate: displaySettings.ttsRate,
                language: languageToUse,
                voice: voiceIdentifier, // Force specific voice
                onStart: () => { },
                onDone: () => {
                    if (speechState.current.isActive && speechSessionId.current === currentSessionId) {
                        speechState.current.index += 1;
                        speechState.current.resumeOffsetInChunk = 0;
                        speakNextChunk();
                    }
                },
                onStopped: () => {
                    if (!speechState.current.isActive && !speechState.current.isPaused) {
                        setTtsStatus('stopped');
                        setSpeechRange(null);
                    }
                },
                onError: (e) => {
                    console.log("TTS Error", e);
                    setTtsStatus('stopped');
                    setSpeechRange(null);
                    speechState.current.isActive = false;
                },
                onBoundary: (event: any) => {
                    if (event.charIndex !== undefined && speechState.current.isActive && speechSessionId.current === currentSessionId) {
                        const now = Date.now();
                        if (now - lastBoundaryUpdate < 500) return;
                        lastBoundaryUpdate = now;

                        const currentBase = speechState.current.baseOffset || 0;
                        setSpeechRange({
                            start: currentBase + globalChunkOffset + resumeOffset + event.charIndex,
                            length: event.charLength
                        });
                    }
                }
            });
        };

        const playAudioFile = async (uri: string) => {
            try {
                if (currentSound.current) {
                    try {
                        currentSound.current.pause(); // Explicitly pause first
                        currentSound.current.remove();
                    } catch (e: any) { }
                }

                if (speechSessionId.current !== currentSessionId) return;

                setIsOnlinePlayback(true); // Disable highlights for online

                // Load sound using expo-audio
                const player = createAudioPlayer(uri);
                const actualRate = displaySettings.ttsRate || 1.0;

                // Try setting shouldCorrectPitch directly on the player object
                try {
                    (player as any).shouldCorrectPitch = true;
                } catch (e: any) {
                    // Debug logging removed
                }

                // Debug logging removed
                player.setPlaybackRate(actualRate);

                // Log actual player properties for debugging
                // Debug logging removed
                // Pitch correction is now handled via the second parameter of setPlaybackRate

                if (speechSessionId.current !== currentSessionId) {
                    player.remove();
                    return;
                }

                currentSound.current = player;

                let lastUpdate = 0;

                player.addListener('playbackStatusUpdate', (status: any) => {
                    if (!status.isLoaded) return;

                    if (status.didJustFinish) {
                        if (speechState.current.isActive && speechSessionId.current === currentSessionId) {
                            speechState.current.index += 1;
                            speechState.current.resumeOffsetInChunk = 0;
                            speakNextChunk();
                        }
                    }

                    if (status.playing && speechState.current.isActive && speechSessionId.current === currentSessionId) {
                        const now = Date.now();
                        if (now - lastUpdate < 60) return;
                        lastUpdate = now;

                        const duration = status.duration * 1000;
                        const currentTime = status.currentTime * 1000;

                        if (duration > 0 && originalChunk.length > 0) {
                            const progress = currentTime / duration;
                            const clampedProgress = Math.max(0, Math.min(1, progress));
                            const estimatedCharOffset = Math.floor(clampedProgress * originalChunk.length);

                            const currentBase = speechState.current.baseOffset || 0;
                            const absoluteIndex = currentBase + globalChunkOffset + estimatedCharOffset;

                            setSpeechRange((prev: any) => {
                                if (prev && Math.abs(prev.start - absoluteIndex) < 2) return prev;
                                return { start: absoluteIndex, length: 0 };
                            });
                        }
                    }
                });

                player.play();

                // Handle Resume/Seek
                if (speechState.current.isActive && speechSessionId.current === currentSessionId) {
                    const currentBase = speechState.current.baseOffset || 0;

                    setSpeechRange({
                        start: currentBase + globalChunkOffset + resumeOffset,
                        length: 0
                    });

                    // Seek logic if resuming
                    if (resumeOffset > 0 && player.duration) {
                        const ratio = resumeOffset / originalChunk.length;
                        const seekPos = player.duration * ratio;
                        try { player.seekTo(seekPos); } catch (e) { }
                    }

                    player.play();
                    triggerPrefetchChain(index + 1);
                }
            } catch (e) {
                console.warn("Playback failed", e);
                if (speechSessionId.current === currentSessionId) {
                    fallbackToOffline();
                }
            }
        };

        // --- END HELPER DEFINITIONS ---

        // Cache Logic - hash textForTts (with context) + voice
        const voiceForHash = (readingSession && readingSession.voice) ? readingSession.voice : (displaySettings.voice || "Kore");

        // Hashing the MODIFIED text ensures that "Alice: Hello" is cached differently from "Bob: Hello"
        // even if the raw chunk was just "Hello".
        const chunkHash = simpleHash(textForTts + voiceForHash);
        const safeTitle = getSafeFileName(title);

        // 1. Try New Format (Robust Scan)
        // Instead of constructing one specific URI and checking it, we scan for ANY file with the matching hash.
        // This fixes the issue where a file exists but has a different title suffix (e.g. from an old title edit).
        let fileUri = null;

        try {
            const files = await fs.readDirectoryAsync(docDir || "");
            const match = files.find(f => f.startsWith(`tts_${chunkHash}`));

            if (match) {
                fileUri = docDir + match;
                console.log("TTS Cache Hit (Hash Scan):", match);
                await playAudioFile(fileUri);
                return;
            }

            // If no hash match found, fallback to constructing the expected filename for NEW downloads
            fileUri = `${docDir}tts_${chunkHash}_${safeTitle}.wav`;

        } catch (e) {
            console.warn("Cache check failed", e);
            // Fallback default
            fileUri = `${docDir}tts_${chunkHash}_${safeTitle}.wav`;
        }

        // If no cache, and online is disabled, fallback to offline
        if (!displaySettings.onlineTtsEnabled) {
            fallbackToOffline();
            return;
        }

        // Cache Miss - Attempt Online
        if (key && !isRateLimited && !onlineTTSBroken.current) {
            try {
                setIsTtsDownloading(true);
                setTtsDownloadProgress(0);

                // Generate FULL chunk to ensure cache reusability
                // UPDATED: Single speaker generation
                const pcmData = await generateGeminiTTS(textForTts, null);

                const wavBase64 = pcmToWav(pcmData);

                // Save to file 
                fileUri = `${docDir}tts_${chunkHash}_${safeTitle}.wav`;
                await fs.writeAsStringAsync(fileUri, wavBase64, { encoding: fs.EncodingType.Base64 });

                setIsTtsDownloading(false);

                // Play from file
                await playAudioFile(fileUri);
                return;

            } catch (e) {
                setIsTtsDownloading(false);
                console.warn("Online TTS failed/save failed, falling back to offline:", e);

                showToast("âš ï¸ Online TTS limit reached for today. Switching to Offline.");

                fallbackToOffline();
            }
        } else {
            fallbackToOffline();
        }

    }, [displaySettings.ttsRate, displaySettings.language, displaySettings.voice, customApiKey, isRateLimited, displaySettings.onlineTtsEnabled, displaySettings.offlineTtsLanguage, displaySettings.offlineVoice, availableVoices]);

    const speak = async (text: string, startOffset = 0, isAlreadyClean = false, forcePlay = false, customTitle: string | null = null) => {
        if (!text) return;

        // Always use full text for chunking to maintain consistency
        const cleanText = (startOffset === 0 && !isAlreadyClean) ? cleanTextForDisplay(text) : (isAlreadyClean ? text : cleanTextForDisplay(text));

        if (ttsStatus === 'playing' && !forcePlay) {
            if (currentSound.current) {
                try {
                    if (currentSound.current.isLoaded) {
                        currentSound.current.pause();
                    }
                } catch (e: any) { console.log("Pause error:", e); }
                speechState.current.isPaused = true;
                speechState.current.isActive = false;
                setTtsStatus('paused');
            } else {
                if (Platform.OS === 'android') {
                    speechState.current.isActive = false;
                    speechState.current.isPaused = true;
                    Speech.stop();
                    setTtsStatus('paused');
                } else {
                    await Speech.pause();
                    setTtsStatus('paused');
                }
            }
        } else if (ttsStatus === 'paused' && startOffset === 0 && !forcePlay) {
            if (currentSound.current) {
                try {
                    if (currentSound.current.isLoaded) {
                        currentSound.current.play();
                    } else {
                        speak(text, startOffset, isAlreadyClean, true);
                        return;
                    }
                } catch (e: any) {
                    console.log("Resume error:", e);
                    speak(text, startOffset, isAlreadyClean, true);
                    return;
                }
                setIsOnlinePlayback(true);
                speechState.current.isActive = true;
                speechState.current.isPaused = false;
                setTtsStatus('playing');
            } else {
                if (Platform.OS === 'android') {
                    setIsOnlinePlayback(false);
                    speechState.current.isActive = true;
                    speechState.current.isPaused = false;
                    if (speechRange && speechState.current.offsets[speechState.current.index] !== undefined) {
                        const currentChunkStart = speechState.current.offsets[speechState.current.index];
                        const positionInChunk = speechRange.start - currentChunkStart;
                        if (positionInChunk > 0 && positionInChunk < speechState.current.chunks[speechState.current.index].length) {
                            speechState.current.resumeOffsetInChunk = positionInChunk;
                        } else {
                            speechState.current.resumeOffsetInChunk = 0;
                        }
                    }
                    speakNextChunk();
                    setTtsStatus('playing');
                } else {
                    setIsOnlinePlayback(false);
                    await Speech.resume();
                    setTtsStatus('playing');
                }
            }
        } else {
            // Start New Session
            speechSessionId.current += 1; // Increment session ID
            const newSessionId = speechSessionId.current;

            // Stop any existing
            if (currentSound.current) {
                try { currentSound.current.pause(); } catch (e) { }
                currentSound.current = null;
            }
            Speech.stop();

            // Use extracted chunk logic
            const { chunks, offsets } = getChunks(cleanText);

            // Determine Start Chunk and Offset
            let startIndex = 0;
            let startResumeOffset = 0;

            if (startOffset > 0) {
                for (let i = 0; i < chunks.length; i++) {
                    const cOffset = offsets[i];
                    const cLen = chunks[i].length;
                    if (startOffset >= cOffset && startOffset < cOffset + cLen) {
                        startIndex = i;
                        startResumeOffset = startOffset - cOffset;
                        break;
                    }
                }
            }

            // NEW: Determine Multi-Speaker Config for this session
            // Multi-speaker disabled.
            const speakerConfig = null;

            speechState.current = {
                id: newSessionId, // Assign ID to state
                chunks,
                index: startIndex,
                offsets,
                isActive: true,
                isPaused: false,
                resumeOffsetInChunk: startResumeOffset,
                baseOffset: 0,
                title: customTitle || (readingSession ? readingSession.title : "Audio"),
                pendingDownloads: new Set(),
                lastSpeaker: "Narrator" // Default
            };

            setTtsStatus('playing');
            speakNextChunk();
        }
    };


    const stopTTS = async () => {
        speechState.current.isActive = false;
        speechState.current.isPaused = false;
        setIsTtsDownloading(false);

        if (currentSound.current) {
            try { currentSound.current.pause(); } catch (e) { }
            currentSound.current = null;
        }

        Speech.stop();
        setSpeechRange(null);
        setTtsStatus('stopped');
        // Note: We don't clear playingMeta here to allow the UI to show "Last Played" info in Mini Player
    };

    const handleTTSSeek = async (val: number) => {
        const newPos = Math.floor(val);

        // NEW: Handle Custom Audio Seeking FIRST
        if (readingSession && customAudioUrisState[readingSession.id] && customAudioPlayerRef.current) {
            // customAudioProgress is in MS, slider emits MS. Player expects Seconds.
            await customAudioPlayerRef.current.seekTo(newPos / 1000);
            setCustomAudioProgress((prev: any) => ({ ...prev, position: newPos }));
            return;
        }

        // NEW: Handle Orphan Audio Seeking (Time based)
        if (readingSession?.toolId === 'orphan_audio' || readingSession?.hasAudio) {
            if (currentSound.current) {
                currentSound.current.seekTo(newPos / 1000);
                setAudioProgress(prev => ({ ...prev, position: newPos }));
            }
            return;
        }

        // Existing Text-Based Seeking
        if (newPos < 0 || newPos >= readerFullText.length) return;

        const bounds = getSentenceBounds(readerFullText, newPos);
        const start = bounds ? bounds.start : newPos;

        setSpeechRange({ start: start, length: 0 });

        // Pass Full text + offset to enable smart chunk seeking + FORCE PLAY
        speak(readerFullText, start, true, true);

        // NEW: Explicitly track this session as playing when seeking
        if (readingSession) {
            setPlayingMeta({ id: readingSession.id, title: readingSession.title });
        }
    };

    const jumpSentence = async (direction: 'next' | 'prev') => {
        // NEW: Handle Custom Audio Jumping
        if (readingSession && customAudioUrisState[readingSession.id] && customAudioPlayerRef.current) {
            const player = customAudioPlayerRef.current;
            // State is in MS. Player expects Seconds.
            const currentMs = customAudioProgress.position;
            const durationMs = customAudioProgress.duration;

            let newPos = currentMs + (direction === 'next' ? 10000 : -10000); // +/- 10s
            if (newPos < 0) newPos = 0;
            if (newPos > durationMs) newPos = durationMs;

            await player.seekTo(newPos / 1000);
            // Manually update state to prevent "stuck" seek
            setCustomAudioProgress((prev: any) => ({ ...prev, position: newPos }));
            return;
        }

        // NEW: Handle Orphan Audio Jumping (Time based +/- 10s)
        if (readingSession?.toolId === 'orphan_audio' || readingSession?.hasAudio) {
            if (currentSound.current) {
                const player = currentSound.current;
                const currentSeconds = player.currentTime;
                const durationSeconds = player.duration;

                let newPos = currentSeconds + (direction === 'next' ? 10 : -10); // 10 seconds
                // Clamp
                if (newPos < 0) newPos = 0;
                if (newPos > durationSeconds) newPos = durationSeconds;

                player.seekTo(newPos);
                setAudioProgress(prev => ({ ...prev, position: newPos * 1000 }));
            }
            return;
        }

        const currentPos = speechRange ? speechRange.start : 0;
        const bounds = getSentenceBounds(readerFullText, currentPos);

        let target = 0;
        if (direction === 'next') {
            target = (bounds?.end || 0) + 1;
        } else {
            const prevEnd = readerFullText.lastIndexOf('.', Math.max(0, (bounds?.start || 0) - 2));
            if (prevEnd === -1) target = 0;
            else {
                const prevBounds = getSentenceBounds(readerFullText, prevEnd);
                target = prevBounds ? prevBounds.start : 0;
            }
        }

        target = Math.max(0, Math.min(target, readerFullText.length - 1));

        setSpeechRange({ start: target, length: 0 });

        // Pass Full text + offset to enable smart chunk seeking + FORCE PLAY
        speak(readerFullText, target, true, true);

        // NEW: Explicitly track this session as playing when jumping
        if (readingSession) {
            setPlayingMeta({ id: readingSession.id, title: readingSession.title });
        }
    };

    // NEW: Handle Link Press for Custom Protocols (e.g. search:)
    const handleLinkPress = useCallback((url: string): any => {
        if (url && url.startsWith('search:')) {
            const query = url.replace('search:', '').trim();
            if (query) {
                handleQuickSearch(query); // Trigger search with extracted query
                return true; // Indicate handled
            }
        }
        return false; // Not handled, let default behavior occur
    }, [appMode]); // Dependencies for callback

    // NEW: Helper to render Mic Button for Notes/Story with consistent style
    const renderMicButton = (target: string, customStyle: ViewStyle, iconSize = 18) => (
        <TouchableOpacity
            onPress={() => handleVoiceToggle(target)}
            style={[{
                width: 38,
                height: 38,
                borderRadius: 19,
                backgroundColor: (isRecording && voiceTarget === target) ? '#ef4444' : theme.buttonBg,
                alignItems: 'center',
                justifyContent: 'center',
                borderWidth: 1,
                borderColor: (isRecording || isTranscribing) && voiceTarget === target ? '#ef4444' : theme.border,
                zIndex: 10,
                shadowColor: "#000",
                shadowOffset: { width: 0, height: 1 },
                shadowOpacity: 0.1,
                shadowRadius: 2,
                elevation: 2
            }, customStyle]}
        >
            {isTranscribing && voiceTarget === target ? (
                <ActivityIndicator size="small" color="#ef4444" />
            ) : (
                <Animated.View style={{ opacity: voiceTarget === target ? recordingOpacity : 1 }}>
                    <Mic size={iconSize} color={(isRecording && voiceTarget === target) ? '#ef4444' : theme.text} />
                </Animated.View>
            )}
        </TouchableOpacity>
    );

    // NEW: Voice Input Handler
    const handleVoiceToggle = async (target: string = 'search') => {
        Keyboard.dismiss(); // Automatically hide keyboard when mic is clicked
        const key = customApiKey || apiKey;
        if (!key) {
            Alert.alert("Offline", "Voice input requires an API Key. Please add one in Settings.");
            return;
        }

        if (isRecording) {
            // Stop Recording
            try {
                setIsRecording(false);
                if (isRecording) { // Use state/recorder check
                    const statusBeforeStop = await recorder.getStatus();
                    console.log("Status before stop:", statusBeforeStop);

                    await recorder.stop();
                    console.log("Recorder stopped. URI:", recorder.uri);
                    const uri = recorder.uri;
                    // recordingRef.current = null; // Removed ref usage

                    if (uri) {
                        setIsTranscribing(true); // Show loader visually, don't change text

                        const base64 = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.Base64 });
                        // Determine mime type based on OS defaults for HIGH_QUALITY preset
                        // iOS usually .m4a (audio/m4a), Android .m4a or .3gp. Gemini handles audio/m4a or audio/mp4 well.
                        const mimeType = Platform.OS === 'ios' ? 'audio/m4a' : 'audio/mp4';

                        // NEW: Helper to attempt transcription with a specific model
                        const transcribeWithModel = async (modelId: string) => {
                            // NEW: Enhanced prompt to force native script
                            const userLang = displaySettings.language || "the spoken language";
                            const promptText = `Refine the user's voice input into a clear, complete instruction.
                        CONTEXT: The user's preferred native language is ${userLang}.
                        RULES:
                        1. Transcribe and REFINE the speech. Complete any incomplete sentences or thoughts to make it a valid instruction.
                        2. LANGUAGE LOGIC:
                           - IF the count of words in the user's NATIVE language (${userLang}) is more than 4, REFINE and RESPOND in that native language (using its native script).
                           - IF the count of English words is more than 5, REFINE and RESPOND in English.
                           - UNTIL the user speaks more than 4 words in their native language, translate the input to English (unless rule 2b applies).
                        3. Fix grammar, remove fillers (ums, ahs), and ensure the result is a polished instruction.
                        4. STRICTLY PROHIBITED: Do NOT use English/Latin alphabet for non-English languages (No Transliteration/Hinglish). Use native script (e.g. Devanagari for Hindi).
                        5. Return ONLY the refined text.`;

                            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${key}`, {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({
                                    contents: [{
                                        role: "user",
                                        parts: [
                                            { text: promptText },
                                            { inlineData: { mimeType: mimeType, data: base64 } }
                                        ]
                                    }]
                                })
                            });
                            const data = await response.json();
                            if (data.error) {
                                throw new Error(data.error.message || "API Error");
                            }
                            return data.candidates?.[0]?.content?.parts?.[0]?.text;
                        };

                        let text = null;

                        try {
                            // 1. Try Primary Model (Flash Lite - Fast)
                            text = await transcribeWithModel("gemini-2.5-flash-lite");
                        } catch (error: any) {
                            console.warn("Primary voice model failed, attempting fallback:", error.message);
                            try {
                                // 2. Try Fallback Model (Robotics - Preview)
                                text = await transcribeWithModel("gemini-robotics-er-1.5-preview");
                            } catch (fallbackError) {
                                // If both fail, throw the original error to alert the user
                                throw new Error(error.message || "API Error");
                            }
                        }

                        if (text) {
                            const newText = text.trim();
                            // Append new text to previous text based on target
                            // UPDATED: Handle specific targets for unconditional buttons
                            if (voiceTarget === 'note_title') {
                                setCurrentNoteTitle((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'note_prompt') {
                                setCustomNotePrompt((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'note_body') {
                                setCurrentNoteInput((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'story_title') {
                                setBookParams((prev: any) => ({ ...prev, title: (prev.title ? prev.title + " " : "") + newText }));
                            } else if (voiceTarget === 'story_chapter') {
                                setBookParams((prev: any) => ({ ...prev, chapter: (prev.chapter ? prev.chapter + " " : "") + newText }));
                            } else if (voiceTarget === 'story_description') {
                                setBookParams((prev: any) => ({ ...prev, description: (prev.description ? prev.description + " " : "") + newText }));
                            } else if (voiceTarget === 'story_query') { // NEW: Handle unified story search
                                setStoryQuery((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'story_next') { // NEW: Handle next chapter voice input
                                setNextChapterInput((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'prompt_label') {
                                setNewPromptData((prev: any) => ({ ...prev, label: (prev.label ? prev.label + " " : "") + newText }));
                            } else if (voiceTarget === 'prompt_content') {
                                setNewPromptData((prev: any) => ({ ...prev, prompt: (prev.prompt ? prev.prompt + " " : "") + newText }));
                            } else if (voiceTarget === 'role_title') {
                                setNewRoleData((prev: any) => ({ ...prev, title: (prev.title ? prev.title + " " : "") + newText }));
                            } else if (voiceTarget === 'role_instructions') {
                                setNewRoleData((prev: any) => ({ ...prev, instructions: (prev.instructions ? prev.instructions + " " : "") + newText }));
                            } else if (voiceTarget === 'dictionary') {
                                setDictionaryInput((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'library_search') {
                                setLibrarySearchQuery((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'notes_search') {
                                setNoteSearchQuery((prev: any) => (prev ? prev + " " : "") + newText);
                            } else if (voiceTarget === 'setup_input') {
                                setSchoolConfig((prev: any) => ({ ...prev, input: (prev.input ? prev.input + " " : "") + newText }));
                            } else if (voiceTarget === 'vision_prompt') {
                                setVisionDraft((prev: any) => ({ ...prev, prompt: (prev.prompt ? prev.prompt + " " : "") + newText }));
                            } else {
                                // Default to search
                                setQuickSearchQuery((prev: any) => (prev ? prev + " " : "") + newText);
                            }
                        } else {
                            console.log("Audio transcribing failed, text is null");
                            Alert.alert("Error", "Could not transcribe audio.");
                        }
                    } else {
                        console.log("Recorder URI is null");
                        Alert.alert("Error", "Recording failed: No audio file generated.");
                    }
                }
            } catch (e: any) {
                console.error("Voice Stop Error", e);
                const errString = e.message ? e.message.toLowerCase() : "";
                // Check for common API limit error codes/messages
                if (errString.includes("429") || errString.includes("quota") || errString.includes("limit") || errString.includes("exhausted")) {
                    Alert.alert("Limit Reached", "Today's limit for voice-to-text generation for this API key is reached. Try after some time.");
                } else {
                    Alert.alert("Error", "Failed to process audio.");
                }
            } finally {
                setIsTranscribing(false);
                // Restore audio mode for playback
                await setAudioModeAsync({
                    allowsRecording: false,
                    shouldPlayInBackground: true,
                    playsInSilentMode: true,
                    interruptionMode: 'duckOthers',
                    shouldRouteThroughEarpiece: false,
                });
            }
        } else {
            // Start Recording
            try {
                const perm = await requestRecordingPermissionsAsync();
                if (perm.status !== 'granted') {
                    Alert.alert("Permission", "Microphone access is required for voice input.");
                    return;
                }

                setVoiceTarget(target); // Set active target

                // Configure for recording
                await setAudioModeAsync({
                    allowsRecording: true,
                    shouldPlayInBackground: true,
                    playsInSilentMode: true,
                    interruptionMode: 'duckOthers',
                    shouldRouteThroughEarpiece: false,
                });

                console.log("Preparing recorder...");
                await recorder.prepareToRecordAsync(SPEECH_RECORDING_OPTIONS);
                console.log("Recorder prepared. Starting recording...");

                await recorder.record();
                console.log("Recording started command sent.");

                const statusAfterStart = await recorder.getStatus();
                console.log("Status after record:", statusAfterStart);

                setIsRecording(true);
            } catch (e) {
                console.error("Voice Start Error", e);
                Alert.alert("Error", "Could not start recording.");
                // Try to restore defaults if start failed
                await setAudioModeAsync({
                    allowsRecording: false,
                    shouldPlayInBackground: true,
                    playsInSilentMode: true,
                    interruptionMode: 'duckOthers',
                    shouldRouteThroughEarpiece: false,
                });
            }
        }
    };

    const generateImage = async (prompt: string, forceOverride = false) => {
        // Check if image generation is enabled in settings or forced (e.g. by manual tap)
        if (!displaySettings.imageGenerationEnabled && !forceOverride) return null;

        const key = customApiKey || apiKey;
        if (!key) return null;

        // Retry configuration
        const MAX_RETRIES = 3;

        for (const modelId of IMAGE_MODELS) {
            let attempts = 0;

            while (attempts <= MAX_RETRIES) {
                try {
                    console.log(`Attempting Image Generation with: ${modelId} (Attempt ${attempts + 1})`);

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:predict?key=${key}`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            instances: [{ prompt: prompt }],
                            parameters: { sampleCount: 1 }
                        })
                    });

                    if (response.status === 429) {
                        console.warn(`Image Model ${modelId} limit reached (429).`);
                        break; // Rate limit usually applies to key, retrying immediately might not help
                    }

                    if (response.status === 503) {
                        console.warn(`Image Model ${modelId} service unavailable (503). Retrying...`);
                        attempts++;
                        if (attempts <= MAX_RETRIES) {
                            const delay = Math.pow(2, attempts) * 1000; // 2s, 4s, 8s
                            await new Promise(r => setTimeout(r, delay));
                            continue; // Retry loop
                        } else {
                            break; // Give up on this model
                        }
                    }

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.warn(`Image Model ${modelId} failed with ${response.status}: ${errorText}`);
                        break; // Non-retriable error
                    }

                    const data = await response.json();
                    const base64 = data.predictions?.[0]?.bytesBase64Encoded;
                    if (base64) {
                        if (isRateLimited) setIsRateLimited(false);
                        return `data:image/png;base64,${base64}`;
                    } else {
                        break; // Valid response but no image
                    }
                } catch (e: any) {
                    console.error(`Image Gen Connection Error with ${modelId}:`, e);
                    attempts++;
                    if (attempts <= MAX_RETRIES) {
                        await new Promise(r => setTimeout(r, 2000));
                    } else {
                        break;
                    }
                }
            }
        }
        return null;
    };

    // Helper for Match Scoring (Moved to scope for Unified Search)
    const calculateMatchScore = (text: string, query: string) => {
        if (!text || !query) return 0;
        const textLower = text.toLowerCase();
        const queryLower = query.toLowerCase();
        if (textLower === queryLower) return 1.0;
        if (textLower.includes(queryLower)) return 0.9;
        const tokens = queryLower.split(/\s+/).filter(t => t.length > 2);
        if (tokens.length === 0) return 0;
        let hits = 0;
        for (const token of tokens) {
            if (textLower.includes(token)) hits++;
        }
        return hits / tokens.length;
    };

    // Helper for Fuzzy Match (Threshold check for simple lookups)
    const checkFuzzyMatch = (text: string, query: string) => {
        return calculateMatchScore(text, query) >= 0.5;
    };

    // NEW: Helper to search Dictionary (Saved Words + Recent History)
    // Needs access to savedWords/recentSearches (assuming they are in scope)
    const findDictionaryMatch = (query: string) => {
        // 1. Check Saved Words (Starred)
        const saved = savedWords.find(w => checkFuzzyMatch(w.word, query));
        if (saved) return saved.word;

        // 2. Check Recent Searches (Personal Dictionary)
        const recent = recentSearches.find(item => {
            const w = typeof item === 'string' ? item : item.word;
            return checkFuzzyMatch(w, query);
        });
        if (recent) return typeof recent === 'string' ? recent : recent.word;

        return null;
    };

    const handleQuickSearch = async (overrideQuery: string | any = null) => {
        // Prevent rapid clicks / concurrent requests
        if (isReaderQuerying) return;

        // UPDATED: Check if overrideQuery is a pure string (programmatic) or an event object (manual press)
        const isProgrammatic = typeof overrideQuery === 'string';
        const queryToUse = (isProgrammatic ? overrideQuery : quickSearchQuery).trim();

        // Capture context before state changes
        const isReaderContext = appMode === 'reader';

        if (!queryToUse) {
            Alert.alert("Input Required", "Please enter a topic.");
            return;
        }

        if (!isProgrammatic) {
            setQuickSearchQuery("");
        }

        // --- NEW: READER CONTEXTUAL INPUT LOGIC ---
        if (isReaderContext && readingSession) {
            // If Orphan Audio, skip context logic (no text to append to)
            if (readingSession.toolId === 'orphan_audio') {
                Alert.alert("Not Supported", "Cannot chat with audio-only files.");
                return;
            }

            setIsReaderQuerying(true);
            Keyboard.dismiss();

            try {
                // 1. Identify the Persona
                const allTools = getAllTools();
                const currentTool = allTools.find(t => t.id === readingSession.toolId);

                let systemRole = "Assistant";
                let contextInstruction = "You are a helpful AI assistant.";
                let detailedInstruction = "Provide a comprehensive, detailed response.";

                if (currentTool) {
                    if (currentTool.isCustom) {
                        systemRole = currentTool.title;
                        contextInstruction = `You are ${currentTool.title}. Act strictly according to your instructions: "${currentTool.systemPrompt}".`;
                        detailedInstruction = "Maintain your specific persona constraints and style. Be detailed and helpful.";
                    } else {
                        systemRole = currentTool.role || "Assistant";
                        contextInstruction = `You are acting as: ${systemRole}.`;

                        // NEW: Specific behavior instructions based on tool type to ensure depth
                        switch (currentTool.id) {
                            case 'teacher':
                            case 'ml_tutor':
                            case 'tech_guide':
                                detailedInstruction = "Explain this concept thoroughly like a lecture or tutorial. Use analogies, clear structure (headers/bullets), and ensure the user understands the 'why' and 'how'. Do not be brief.";
                                break;
                            case 'writer':
                                detailedInstruction = "Write creatively and professionally. Focus on flow, tone, and vivid description. If asked to write, produce a substantial piece, not a summary.";
                                break;
                            case 'health_guide':
                                detailedInstruction = "Analyze clinically. Provide detailed medical context, potential causes, and actionable advice. ALWAYS include the medical disclaimer toggle at the very end.";
                                break;
                            case 'grammar_guide':
                                detailedInstruction = "Explain the grammar rule in depth. Provide clear 'Correct vs Incorrect' examples to illustrate the point.";
                                break;
                            case 'idiom_guide':
                                detailedInstruction = "Explain the idiom or phrase with its origin, meaning, and provide natural dialogue examples showing how to use it.";
                                break;
                            case 'math_solver':
                                detailedInstruction = "Solve step-by-step. Show all work, formulas, and logic clearly. Do not skip steps.";
                                break;
                            case 'email_pro':
                                detailedInstruction = "Draft or revise the email professionally. Maintain business etiquette and appropriate tone.";
                                break;
                            case 'editorial_writer':
                                detailedInstruction = "Write with the authority and vocabulary of a Chief Editor. Use strong arguments, advanced vocabulary, and rhetorical flair.";
                                break;
                            case 'debate_coach':
                                detailedInstruction = "Analyze the argument deeply or continue the debate with strong points and counter-points.";
                                break;
                            case 'work_organizer':
                                detailedInstruction = "Structure the information perfectly using lists, headers, and checkboxes. Organize chaos into order.";
                                break;
                            case 'word_help':
                                detailedInstruction = "Provide deep etymology, synonyms, antonyms, and usage examples. Act as a vocabulary coach.";
                                break;
                            default:
                                detailedInstruction = "Provide a detailed, helpful, and persona-aligned response. Avoid being terse.";
                        }
                    }
                } else if (readingSession.toolId === 'quick_search') {
                    systemRole = "Expert Researcher";
                    contextInstruction = "You are a Research Assistant providing follow-up information.";
                    detailedInstruction = "Provide a detailed, fact-based answer. Use markdown for structure. For any key concepts across all subjects (History, Art, Science, etc.), you MUST use the **Concept Card** format: `[[CONCEPT_CARD: Title]] ...Content (Max 300 chars)... [[END_CARD]]`.";
                } else if (readingSession.toolId === 'story_generator') {
                    systemRole = readingSession.storyMode === 'character' ? "Method Actor" : "Master Narrator";
                    contextInstruction = "You are the author/storyteller of this text. Maintain the narrative voice.";
                    detailedInstruction = "Continue the narrative or explain the lore with creative depth. Immerse the reader.";
                }

                // 2. Prepare Context (Limit to last ~5000 chars to save tokens/latency)
                const currentContent = readingSession.messages[0].content;
                const contextSlice = currentContent.length > 5000 ? "..." + currentContent.slice(-5000) : currentContent;

                const prompt = `
            ${contextInstruction}
            
            CONTEXT (The content you generated so far):
            """
            ${contextSlice}
            """
            
            USER FOLLOW-UP: "${queryToUse}"
            
            INSTRUCTION:
            Respond to the user's follow-up request directly in character.
            **${detailedInstruction}**
            
            - If asking for examples, provide them based on the topic.
            - If asking to expand, write the next section fully.
            - Keep formatting consistent (Markdown).
            - Do NOT repeat the user's question.
            - **Do NOT be brief unless explicitly asked.** Be comprehensive and substantial.
            `;

                // 3. Call LLM
                const response = await callLLM(prompt, systemRole);

                if (!response.startsWith("Error")) {
                    // 4. Create NEW Session (Branch) instead of appending to current file
                    // Clean any image prompts from chat response
                    const cleanResponse = response.replace(/IMAGE_PROMPT:.*$/i, '').trim();

                    // Create a clear title for the new Q&A tab
                    const newTitle = `Ask: ${queryToUse}`;
                    const safeTitle = newTitle.length > 50 ? newTitle.substring(0, 50) + "..." : newTitle;

                    // Format the content to include context context
                    const newContent = `**Context:** *${readingSession.title}*\n\n**Question:** ${queryToUse}\n\n---\n\n${cleanResponse}`;

                    // UPDATE: Inherit toolId unless it's a special type that has its own tab (Stories, Notes, Quizzes)
                    const nextToolId = ['story_generator', 'quiz_save', 'quick_notes'].includes(readingSession.toolId)
                        ? 'quick_search'
                        : readingSession.toolId;

                    const newSession = {
                        id: generateId(),
                        timestamp: new Date().toISOString(),
                        messages: [{ role: 'ai', content: newContent }],
                        title: safeTitle,
                        toolId: nextToolId, // Use inherited tool ID for grouping
                        translations: { [displaySettings.language]: newContent },
                        language: displaySettings.language
                    };

                    // Save new session
                    await persistSession(newSession);

                    // Minimize the current book so the user can easily return to it
                    setMinimizedSession(readingSession);

                    // Open the new Q&A session
                    loadHistorySession(newSession, 'reader');

                } else {
                    Alert.alert("AI Error", response);
                }

            } catch (e) {
                console.error("Reader Chat Error", e);
                Alert.alert("Error", "Failed to get response.");
            } finally {
                setIsReaderQuerying(false);
            }
            return; // STOP HERE - Do not proceed to standard search
        }
        // --- END READER LOGIC ---

        // Local Search Logic removed. Unified Search Bar uses UI Dropdown for library items.

        // STANDARD MODE: Full screen generation (Used for Reader as well now to skip popup)
        setAppMode("generating");
        setGenerationData(isReaderContext ? "Searching..." : "Searching deeply...");

        const prompt = `
    You are a friendly Personal Assistant. Explain concepts in simple, beginner-friendly language, like easy-to-read study notes. Avoid complex jargon. Use tables, charts, diagrams, and bullet points to make information visual and clear. bold important key points.

    User Query: "${queryToUse}"
    
    IMPORTANT: For any key concepts across all subjects (History, Art, Science, etc.), you MUST use the **Concept Card** format:
    [[CONCEPT_CARD: Title]]
    ...Content (Max 300 chars)...
    [[END_CARD]]

    VISUAL REQUIREMENT:
    - Only provide an image prompt if the topic is complex, spatial, or hard to visualize without a diagram.
    - If generating, strictly on a new line at the end: IMAGE_PROMPT: <prompt>
    `;

        try {
            const rawContent = await callLLM(prompt, "Personal Tutor");

            // NEW: Check for error before proceeding (This catches Network/API errors, NOT missing key)
            // If key is missing, callLLM returns the Markdown Help Guide (starting with #), which bypasses this block.
            if (rawContent.startsWith("Error")) {
                // --- LOCAL LIBRARY FALLBACK (Only on API Error) ---

                // 1. Search Saved Journals/Stories/Notes
                const localSessionMatch = Object.values(chatSessions).find((session: any) =>
                    checkFuzzyMatch(session.title, queryToUse) ||
                    (session.messages && session.messages[0] && checkFuzzyMatch(session.messages[0].content, queryToUse))
                );

                if (localSessionMatch) {
                    showToast("âš ï¸ Connection Issue: Opened from Library");
                    if (isReaderContext) {
                        // DIRECT OPEN (Fallback)
                        if (readingSession) setMinimizedSession(readingSession);
                        loadHistorySession(localSessionMatch, 'reader');
                    } else {
                        setAppMode("idle");
                        loadHistorySession(localSessionMatch);
                    }
                    return;
                }

                // 2. Search Dictionary (Fallback)
                const dictMatchWord = findDictionaryMatch(queryToUse);
                if (dictMatchWord) {
                    showToast("âš ï¸ Connection Issue: Found in Dictionary");
                    if (!isReaderContext) {
                        setAppMode("idle");
                    }
                    handleWordLookup(dictMatchWord);
                    return;
                }

                // 3. Search Saved Questions
                const questionMatch = savedQuestions.find(q => checkFuzzyMatch(q.question, queryToUse));
                if (questionMatch) {
                    showToast("âš ï¸ Connection Issue: Found Saved Question");
                    const tempQuizState = {
                        questions: [{ ...questionMatch, selected: null, markedForReview: false, visited: false }],
                        currentIndex: 0,
                        score: 0,
                        completed: false,
                        title: "Local Search Result",
                        timeSpent: [0],
                        activeQuestionStartTime: Date.now(),
                        originId: null,
                        translations: { [displaySettings.language]: [questionMatch] },
                        language: displaySettings.language,
                        isExamMode: false // NEW: Default to Practice
                    };

                    setQuizState(tempQuizState);
                    setQuizSecondsElapsed(0);
                    setAppMode('live');
                    return;
                }

                // If no local match found, throw the original error to alert the user
                throw new Error(rawContent + "\n\n(No matching local content found)");
            }

            let content = rawContent;
            let image = null;
            const imgMatch = content.match(/IMAGE_PROMPT:\s*(.*)/);
            if (imgMatch) {
                const imgPrompt = imgMatch[1].trim();
                content = content.replace(/IMAGE_PROMPT:.*$/, '').trim();

                // Just update text
                setGenerationData("Painting...");

                image = await generateImage(imgPrompt);
            }

            const newSession = {
                id: generateId(),
                timestamp: new Date().toISOString(),
                messages: [{ role: "ai", content }],
                title: `Ask: ${queryToUse}`,
                toolId: 'ai_tutor',
                image: image,
                translations: { [displaySettings.language]: content },
                language: displaySettings.language
            };
            await persistSession(newSession);

            if (isReaderContext) {
                // DIRECT OPEN: Minimize current and open new
                if (readingSession) {
                    setMinimizedSession(readingSession);
                }
                loadHistorySession(newSession, 'reader');
            } else {
                loadHistorySession(newSession);
            }
            setGenerationData(null);
        } catch (e: any) {
            console.error("Search Error", e);
            const errorMsg = e.message || "Unknown error occurred.";
            // Fallback to previous state on error
            if (isReaderContext) {
                setAppMode('reader'); // Restore reader view
            } else {
                setAppMode("idle");
            }
            setGenerationData(null);
            Alert.alert("Search Failed", errorMsg);
        }
    };

    const handleStartQuiz = async (topic: string, isCustomList = false, subject = "General", isContextBasedInput = false, images: string[] = [], overrideCount: number | null = null, isFlashcardMode = false) => {
        // Check if API key is configured (using state instead of direct storage check for consistency)
        if (!customApiKey || customApiKey.trim() === '') {
            Alert.alert(
                "API Key Required",
                "Please configure your Google API key in Settings to generate quizzes and flashcards.",
                [
                    { text: "Cancel", style: "cancel" },
                    {
                        text: "Go to Settings",
                        onPress: () => {
                            setAppMode('idle');
                            setActiveTab('settings');
                        }
                    }
                ]
            );
            return;
        }

        const originMode = appMode === 'generating' ? 'idle' : appMode;
        setNavOrigin(originMode);
        setAppMode("generating");
        if (isFlashcardMode) {
            setGenerationData("Creating Flashcards...");
        } else {
            setGenerationData(isCustomList ? "Creating Vocabulary Quiz..." : "Drafting Quiz...");
        }

        // Combine manual flag with auto-detection (Now strictly manual flag unless LLM returns context)
        const isContextBased = isContextBasedInput;


        // NEW: Detect if this is a language-specific quiz to prevent auto-translation
        // Logic: If subject is a known language, or tool is language-specific (Grammar/Idiom/Word), or it's a Vocab quiz
        const languageNames = Object.keys(LANGUAGE_CODES);
        // Check if subject matches a language key
        const isSubjectLanguage = languageNames.includes(subject);

        // UPDATED: Use schoolConfig.isLanguageLearning toggle
        const isLanguageLearningEnabled = schoolConfig.isLanguageLearning;

        const isLanguageTool = selectedScenario && ["grammar_guide", "idiom_guide", "word_help"].includes(selectedScenario.id);

        // Prevent translation if explicit toggle is on, or if it's a dedicated language tool/list
        const preventTranslation = isLanguageLearningEnabled || isLanguageTool || isCustomList;

        // NEW: Explicit language instruction for the prompt - MOVED UP
        // If Language Learning is ON and Subject is a Language, force generation in that language.
        // Otherwise, use the User's preferred App Language.
        let generationLang = displaySettings.language;
        if (isLanguageLearningEnabled && isSubjectLanguage) {
            generationLang = subject; // Use the subject (e.g. "French") as the language
        }

        let count = overrideCount;
        if (!count) {
            // Check if schoolConfig.length is numeric (custom input)
            const configLength = parseInt(schoolConfig.length);
            if (!isNaN(configLength) && configLength > 0) {
                count = configLength;
            } else {
                // Fallback/Default logic
                count = 10; // Default if empty
                if (schoolConfig.length === 'Short') count = 5;
                if (schoolConfig.length === 'Medium') count = 10;
                if (schoolConfig.length === 'Large') count = 25;
            }
        }

        // Safety Cap to prevent timeout/token overflow
        if (count > 100) count = 100;

        let complexityDesc = "Use simple, everyday language (CEFR A2 level). Keep explanations short and fun.";
        if (schoolConfig.complexity === 'Intermediate') complexityDesc = "Use standard student language (High School level). Explain clearly but don't oversimplify.";
        if (schoolConfig.complexity === 'Advanced') complexityDesc = "Use academic language (College level) but ensure clarity. Explanations should be comprehensive.";

        // NEW: Profile Preference Instruction
        complexityDesc += " IMPORTANT: Always prioritize the user's specific Bio/Context instructions for technical depth and tone above these defaults.";

        let subjectContext = "";
        let systemRole = isCustomList ? "Vocabulary Coach" : "Quiz Generator";
        if (isFlashcardMode) systemRole = "Flashcard Generator";

        if (!isCustomList) {
            systemRole = `Expert ${subject} Tutor`;
            const s = subject.toLowerCase();

            if (s.includes('math')) {
                subjectContext = "For explanations, act as a friendly tutor. Break down the solution into clear, numbered steps (Step 1, Step 2). Use simple English for logic. Focus on *how* to solve it incrementally.";
            }
            else if (s.includes('history')) {
                subjectContext = "For explanations, act as a storyteller. Connect the event to a clear 'cause and effect' narrative. Use interesting facts to make it memorable.";
            }
            else if (s.includes('science') || s.includes('physics') || s.includes('chem') || s.includes('bio')) {
                subjectContext = "For explanations, use real-world analogies to explain abstract concepts. Break down complex mechanisms into simple parts. Focus on the 'why'.";
            }
            else if (s.includes('literature') || s.includes('english')) {
                subjectContext = "For explanations, use simple language to define complex terms. Provide a concrete example to illustrate the point.";
            }
            else if (s.includes('computer') || s.includes('coding')) {
                subjectContext = "For explanations, explain the logic flow step-by-step like a recipe. Avoid undefined jargon.";
            }
            else {
                subjectContext = "For explanations, provide clear, concise, and educational reasoning. Aim for an 'Explain Like I'm 5' (ELI5) approach where appropriate.";
            }
        }

        // Check for visual analysis keywords (Data Quiz)
        const lowerTopic = (topic || "").toLowerCase();
        const isVisualAnalysis = isContextBased && (
            lowerTopic.includes('chart') ||
            lowerTopic.includes('graph') ||
            lowerTopic.includes('diagram') ||
            lowerTopic.includes('arrangement') ||
            lowerTopic.includes('seating') ||
            lowerTopic.includes('layout') ||
            lowerTopic.includes('map') ||
            lowerTopic.includes('table') ||
            lowerTopic.includes('data')
        );

        // UPDATED: Strict logic for visual prompts.
        // We explicitly instruct the LLM to only request images if absolutely necessary for understanding.
        // This prevents unnecessary image generation for text-based questions.
        // IMPROVEMENT: Added strict instruction to NOT include the answer in the visual.
        const visualPromptDesc = "STRICTLY OPTIONAL: Set to null for most questions. Only provide a prompt if the concept is IMPOSSIBLE to explain clearly with text alone. IMPORTANT: The prompt must describe an illustration of the QUESTION CONTEXT only. It must EXPLICITLY FORBID showing the answer, solution, or correct option in the image. Default to null.";

        // NEW: Instruction for Question formatting to explicitly allow tables
        const questionFormatInstruction = `
      QUESTION FORMATTING:
      The "question" field supports Markdown. 
      CRITICAL: If the question requires data/tables (e.g. "Analyze the table"), YOU MUST INSERT THE MARKDOWN TABLE DIRECTLY INTO THE "question" STRING.
      The user cannot see the explanation until they answer, so the data MUST be in the question.
      Use \\n for newlines in the table structure (rows start/end with |).
      `;

        // UPDATED: Added visualPrompt to JSON structure instructions
        // FIX: Replaced undefined targetLang with generationLang
        const jsonFormatInstruction = `
      Output a valid JSON Object with this structure:
      {
        "context": "CRITICAL: If this quiz is based on a specific passage (Reading Comprehension) provided by the user OR generated by you, copy that full text here. If this is a general knowledge or math quiz based on a topic (e.g. 'Algebra'), MUST return null. NEVER include instructions (e.g. 'Create a quiz...') or meta-commentary as context.",
        "questions": [
          {"question":"Question text (Markdown allowed)","options":["A","B","C","D"],"correctOptionIndex":0,"explanation":"Detailed explanation (Markdown allowed)","visualPrompt":"${visualPromptDesc}"}
        ]
      }
      
      STRICT RULES:
      1. OUTPUT PURE JSON ONLY. No Markdown fencing.
      2. THE "questions" ARRAY MUST CONTAIN EXACTLY ${count} QUESTIONS.
      3. KEEP ALL JSON KEYS IN ENGLISH ("question", "options", "correctOptionIndex", "explanation", "visualPrompt", "context"). DO NOT TRANSLATE KEYS INTO ${generationLang}.
      4. NO unescaped newlines inside strings.
      5. Escape all quotes (\\") inside strings.
      6. DO NOT include any text before the opening { or after the closing }.
      7. DO NOT escape % symbols. Write "50%" not "50\\%".
      8. ENSURE COMMAS BETWEEN ALL PROPERTIES AND ARRAY ITEMS.
      `;

        const explanationInstruction = `
      EXPLANATION FORMATTING:
      The "explanation" field must be comprehensive and multi-line.
      Structure the string with \\n characters.
      MANDATORY: If comparing data, showing categories, or listing structured properties, YOU MUST USE A MARKDOWN TABLE inside the string (rows start/end with |).
      Do NOT ask for an image if a table can represent the data.
      "âœ… Correct: [Deep explanation]\\n\\n| Header | Header |\\n|---|---|\\n| Data | Data |\\n\\nâŒ Other Options:..."
      `;

        const mathSafetyInstruction = `
      MATH RULES:
      1. Use Unicode symbols where possible (e.g., Î¸, Ï€).
      2. If using LaTeX, double-escape backslashes (e.g., "\\\\frac").
      3. Do NOT use dollar signs ($) for math delimiters.
      `;

        const langInstruction = `GENERATE ALL CONTENT (Questions, Options, Explanations) IN ${generationLang}.`;

        // NEW: Diversity Instruction to prevent repetitive patterns
        const diversityInstruction = `
      DIVERSITY REQUIREMENT:
      - Ensure questions are highly varied in structure and cognitive type.
      - MIX these types:
        1. Factual/Recall (What is...)
        2. Conceptual (Why does...)
        3. Application/Scenario (If X happens, what is Y...)
        4. Negative/Exception (Which is NOT...)
        5. Analysis/Comparison (Difference between A and B...)
      - Do NOT repeat the same sentence structure or question format.
      - Vary the difficulty within the selected level.
      - Avoid generating multiple questions about the exact same fact or definition.
      `;

        let prompt;
        let contents;

        // NEW: Logic to capture Text Context (Paragraph) for display
        let contextText = null;
        // UPDATED: Only treat topic as context text if explicitly in Context Mode (e.g. from Note/Vision). 
        // For standard Examiner mode, we rely on the LLM's 'context' field in the response.
        if (isContextBased && (!images || images.length === 0) && topic && topic.length > 150) {
            contextText = topic;
        }

        // NEW: Ensure input images are saved to storage first so we can use them in the quiz questions
        let savedImageUris: string[] = [];
        if (images && images.length > 0) {
            try {
                savedImageUris = await Promise.all(images.map(uri => ensureImageIsSavedToFile(uri)));
            } catch (e) {
                console.warn("Error saving quiz images", e);
                savedImageUris = images; // Fallback
            }
        }

        // REFACTORED: Flashcard Mode takes priority (Moved before isContextBased)
        if (isFlashcardMode) {
            // Flashcard specific language instruction (No "Options")
            const flashcardLangInstruction = `GENERATE ALL CONTENT (Questions, Explanations) IN ${generationLang}.`;

            // Check if we have Long Content (Reader) or Short Topic (Library)
            const isLongContext = topic && topic.length > 200;
            const contextIntro = isLongContext
                ? `Analyze the following content deeply to generate the flashcards.\n\nCONTENT:\n"""\n${topic}\n"""`
                : `Topic: "${topic}"`;

            prompt = `Create ${count} Flashcards based on the subject "${subject}".
             
             ${contextIntro}

             OUTPUT FORMAT:
             Return a JSON Object with a "flashcards" array.
             {
                "flashcards": [
                    { "front": "Descriptive Question (Why/How/Explain...)", "back": "Detailed Answer (300-400 characters)", "example": "Real-world example" }
                ]
             }
             
             ${flashcardLangInstruction}
             
             Guidelines:
             - Front: Ask descriptive questions ("What is the significance of...", "How does X work...", "Explain the concept of..."). Avoid simple "What is X?"
             - Back: Provide a DETAILED, educational explanation (approx 300-400 characters). Explain the "Why" and "How".
             - STRUCTURE: Use bullet points (â€¢) for lists or steps. **IMPORTANT: Start each bullet point on a NEW LINE.**
             - NEGATIVE CONSTRAINTS: 
                1. Do NOT use Markdown Tables (App cannot render them). Use lists instead.
                2. Do NOT use "âœ… Correct:", "âŒ Other Options:", or "Option A/B/C". This is NOT a multiple-choice quiz.
                3. Do NOT provide false options or distractors.
             - Complexity: ${schoolConfig.complexity}. ${complexityDesc}
             - Ensure the content is deep and informative, matching the user's requested level.
             
             Strictly output VALID JSON only.`;

            systemRole = "Flashcard Generator";

        } else if (isContextBased) {
            if (isVisualAnalysis) {
                const contentIntro = topic && topic.trim().length > 0
                    ? `User Instruction: "${topic}"`
                    : `Analyze the visual data.`;

                prompt = `Act as a Data Interpretation & Logical Reasoning Expert.
              Analyze the provided image(s) as a single coherent data source (e.g., a specific Chart, Diagram, or Arrangement).
              
              Task: Create ${count} MCQs that require analyzing this specific visual data.
              
              ${langInstruction}
              ${diversityInstruction}

              Guidelines:
              - Questions must be derived STRICTLY from the image data.
              - Include calculations or logical deductions where applicable (e.g., "What is the ratio...", "Who sits next to...").
              - Ensure the questions form a logical set based on the single image context.
              
              ${contentIntro}
              
              Difficulty: ${schoolConfig.complexity}. ${complexityDesc}
              ${questionFormatInstruction} ${explanationInstruction} ${jsonFormatInstruction}`;

                systemRole = "Data Interpretation Expert";
            } else {
                // Standard Vision Quiz
                const contentIntro = topic && topic.trim().length > 0
                    ? `TEXT CONTENT:\n"""\n${topic}\n"""`
                    : `Analyze the provided images deeply to generate the quiz.`;

                prompt = `Create ${count} MCQs based STRICTLY on the following content.
              
              ${contentIntro}
              
              ${langInstruction}
              ${diversityInstruction}

              Difficulty: ${schoolConfig.complexity}. ${complexityDesc}
              ${questionFormatInstruction} ${explanationInstruction} ${jsonFormatInstruction}`;

                systemRole = "Quiz Generator";
            }
        } else {
            // Standard Quiz Generation (Topic-based)
            systemRole = "Quiz Generator";

            prompt = `Create a ${count}-question ${schoolConfig.complexity} level quiz about "${topic}".
            
            Complexity Hint: ${complexityDesc}
            Subject: ${subject}
            Context: ${subjectContext}

            ${langInstruction}
            ${diversityInstruction}

            ${questionFormatInstruction} ${explanationInstruction} ${jsonFormatInstruction}`;
        }


        if (savedImageUris && savedImageUris.length > 0) {
            const contentParts: any[] = [{ text: prompt }];

            const imageParts = await Promise.all(savedImageUris.map(async (uri) => {
                try {
                    const isPdf = uri.toLowerCase().endsWith('.pdf');
                    const mimeType = isPdf ? "application/pdf" : "image/jpeg";
                    let base64 = "";

                    if (uri.startsWith('data:')) {
                        base64 = uri.split(',')[1];
                    } else {
                        base64 = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.Base64 });
                    }

                    if (base64) base64 = base64.replace(/\r?\n|\r/g, '');
                    return { inlineData: { mimeType, data: base64 } };
                } catch (e: any) {
                    console.warn("Failed to read asset for quiz", uri);
                    return null;
                }
            }));

            imageParts.forEach(part => {
                if (part && part.inlineData.data) contentParts.push(part);
            });

            contents = [{ role: "user", parts: contentParts }];
        } else {
            contents = prompt;
        }

        // Pass true for jsonMode
        const raw = await callLLM(contents, systemRole, true);

        if (typeof raw !== 'string' || raw.startsWith("Error:") || raw === "No response.") {
            setAppMode("idle");
            setGenerationData(null);
            console.log("Quiz Generation Failed Raw:", raw);

            let errorMessage = "The AI could not generate a quiz at this time. It may be busy or the topic was flagged. Please try again.";

            if (typeof raw === 'string') {
                if (raw.includes("API limits")) {
                    errorMessage = "Your API key limit for today is reached. Please try after some time or tomorrow.";
                } else if (raw.includes("Network request failed")) {
                    errorMessage = "No Internet Connection. Please check your network settings.";
                }
            }

            Alert.alert("Generation Failed", errorMessage);
            return;
        }

        try {
            // 1. Extract JSON from potential Markdown wrapper
            let cleanJson = extractJSON(raw);

            // 2. Validate basic structure
            if (!cleanJson.trim().startsWith('[') && !cleanJson.trim().startsWith('{')) {
                // If extractJSON failed (maybe text is "Here is your quiz: ..."), try finding braces manually again
                const start = raw.indexOf('{');
                const startArr = raw.indexOf('[');

                if (start !== -1 && (startArr === -1 || start < startArr)) {
                    const end = raw.lastIndexOf('}');
                    cleanJson = raw.substring(start, end + 1);
                } else if (startArr !== -1) {
                    const end = raw.lastIndexOf(']');
                    cleanJson = raw.substring(startArr, end + 1);
                } else {
                    console.log("Failed Raw Response:", raw);
                    throw new Error("Response is not valid JSON format.");
                }
            }

            let questions;
            let generatedContext = null;

            try {
                // 3. Attempt Parse
                const parsed = JSON.parse(cleanJson);
                if (Array.isArray(parsed)) {
                    questions = parsed;
                } else if (parsed && Array.isArray(parsed.questions)) {
                    questions = parsed.questions;
                    generatedContext = parsed.context || null;
                } else if (parsed && Array.isArray(parsed.flashcards)) {
                    // Flashcard Mode Support
                    questions = parsed.flashcards;
                } else {
                    throw new Error("Invalid structure: Expected array or object with questions/flashcards array");
                }
            } catch (firstError: any) {
                console.log("Initial JSON Parse failed, attempting aggressive repair...", firstError.message);
                // 4. Attempt Repair
                let repairedJson = repairMalformedJson(cleanJson);
                let trimmed = repairedJson.trim();

                // Fix truncation: Ensure it ends correctly
                if (!trimmed.endsWith('}') && !trimmed.endsWith(']')) {
                    const lastBrace = trimmed.lastIndexOf('}');
                    const lastBracket = trimmed.lastIndexOf(']');

                    if (lastBrace > lastBracket) {
                        repairedJson = trimmed.substring(0, lastBrace + 1);
                    } else if (lastBracket > -1) {
                        repairedJson = trimmed.substring(0, lastBracket + 1);
                    } else {
                        repairedJson += '] }';
                    }
                }

                // Double brackets check
                if (trimmed.endsWith(']]') && !trimmed.startsWith('[[')) {
                    repairedJson = repairedJson.slice(0, -1);
                }

                try {
                    const parsed = JSON.parse(repairedJson);
                    if (Array.isArray(parsed)) {
                        questions = parsed;
                    } else if (parsed && Array.isArray(parsed.questions)) {
                        questions = parsed.questions;
                        generatedContext = parsed.context;
                    } else if (parsed && Array.isArray(parsed.flashcards)) {
                        questions = parsed.flashcards;
                    }
                } catch (secondError: any) {
                    console.log("Second Parse failed, attempting final fallback");
                    try {
                        // Try treating it as just the questions array if formatting failed
                        const match = cleanJson.match(/\[.*\]/s);
                        if (match) {
                            questions = JSON.parse(repairMalformedJson(match[0]));
                        } else {
                            const fallbackStr = repairMalformedJson(cleanJson + '] }');
                            const parsed = JSON.parse(fallbackStr);
                            questions = parsed.questions;
                        }
                    } catch (finalErr: any) {
                        // Final fail: Re-throw to main catch to show alert
                        throw new Error("JSON Parse error: " + firstError.message);
                    }
                }
            }

            if (!Array.isArray(questions)) throw new Error("Invalid format");

            // FLASHCARD MODE EXIT
            if (isFlashcardMode) {
                // Normalize keys first
                // questions = normalizeQuizKeys(questions); // SKIP: This corrupts Flashcard keys

                const normalizeFlashcards = questions.map((fc, idx) => ({
                    id: Date.now() + idx,
                    front: fc.front || fc.term || fc.question || "Term",
                    back: fc.back || fc.definition || fc.explanation || fc.answer || "Definition",
                    example: fc.example || "",
                    type: 'generated'
                }));

                // AUTO-SAVE to Library
                const savedSession = {
                    id: Date.now().toString(),
                    title: topic || "Flashcards",
                    timestamp: new Date().toISOString(),
                    toolId: 'flashcards',
                    items: normalizeFlashcards,
                    isFlashcardMode: true
                };
                await persistSession(savedSession);

                setFlashcardSession({
                    items: normalizeFlashcards,
                    currentIndex: 0,
                    flipped: false,
                    type: 'generated', // New type
                    topic: topic,
                    originId: savedSession.id // Link to saved session
                });
                setAppMode("flashcards");
                setGenerationData(null);
                return;
            }

            // NEW: Normalize keys in case LLM translated them
            questions = normalizeQuizKeys(questions);

            // NEW: Randomize Options to fix "Option A bias"
            questions = randomizeQuizData(questions);

            // Use generated context if available, otherwise keep existing contextText logic
            if (generatedContext) {
                const cleanGen = generatedContext.trim().toLowerCase();
                // Filter out if context is just instructions or echoes the prompt
                const isInstruction = cleanGen.startsWith('create') ||
                    cleanGen.startsWith('generate') ||
                    cleanGen.startsWith('analyze') ||
                    cleanGen.includes('follow the same logic') ||
                    cleanGen.includes('follow the save logic') ||
                    cleanGen.length < 5; // Too short to be useful context

                if (!isInstruction) {
                    contextText = generatedContext;
                }
            }

            // NEW: Use the input image for all questions if available
            const primaryImage = (savedImageUris && savedImageUris.length > 0) ? savedImageUris[0] : null;

            const initializedQuestions = questions.map(q => ({
                ...q,
                // If input image exists AND it's a visual analysis (Data Quiz), assign it.
                // Otherwise (Text-based quiz from image), do NOT assign visualUri, rely on visualPrompt generation.
                visualUri: (isVisualAnalysis && primaryImage) ? primaryImage : null,

                // If we are using the input image, we don't need to generate a new one.
                // If we are NOT using the input image, we keep the generated prompt.
                visualPrompt: (isVisualAnalysis && primaryImage) ? null : q.visualPrompt,

                selected: null,
                markedForReview: false,
                visited: false
            }));
            const quizTitle = isContextBased ? (isVisualAnalysis ? "Data Analysis Quiz" : "Quiz from Images") : (isCustomList ? "Vocabulary Quiz" : topic);

            const timeSpent = new Array(initializedQuestions.length).fill(0);

            const quizId = generateId();

            const newSession = {
                id: quizId,
                timestamp: new Date().toISOString(),
                messages: [{ role: "ai", content: "Interactive Quiz Started" }],
                title: quizTitle,
                toolId: 'quiz_save',
                quizData: initializedQuestions,
                score: 0,
                totalQuestions: initializedQuestions.length,
                completed: false,
                translations: { [displaySettings.language]: initializedQuestions }, // Initial translation key
                language: displaySettings.language, // Initial language metadata (even if content is foreign, we tag it to allow 'reset')
                images: savedImageUris, // Save context images
                contextText: contextText, // NEW: Save text context
                attempts: 1, // Init attempts
                isExamMode: isExamMode, // NEW: Freeze mode from Setup Screen
                preventTranslation: preventTranslation, // NEW: Save translation lock flag
                subject: subject // NEW: Save subject for reference
            };

            await persistSession(newSession);

            setQuizState({
                questions: initializedQuestions,
                currentIndex: 0,
                score: 0,
                completed: false,
                title: quizTitle,
                timeSpent: timeSpent,
                activeQuestionStartTime: Date.now(),
                originId: quizId,
                translations: { [displaySettings.language]: initializedQuestions },
                language: displaySettings.language,
                contextText: contextText, // NEW: Pass to state
                attempts: 1, // Init attempts
                isExamMode: isExamMode, // NEW: Freeze mode
                preventTranslation: preventTranslation, // NEW: Pass to state
                subject: subject // NEW: Pass subject
            });
            setQuizSecondsElapsed(0);
            setAppMode("live");
            setShowHistory(false);
            setShowReferenceText(false); // Reset reference toggle
        } catch (e: any) {
            console.error("Quiz Generation Error:", e);
            setAppMode("idle");
            // Provide a user-friendly error message based on the type of failure
            if (e.message.includes("JSON") || e.message.includes("SyntaxError")) {
                Alert.alert("Format Error", "The AI response was not formatted correctly. Please try again or simplify your request.");
            } else {
                Alert.alert("Error", "Failed to generate quiz. Please try again.");
            }
        }
        setGenerationData(null);
    };

    // NEW: Function to handle individual question visual generation
    const handleGenerateQuizVisual = async (index: number, force = false) => {
        // Safety checks
        if (!quizState || !quizState.questions[index]) return;
        const q = quizState.questions[index];

        // MODIFIED: Removed the check for !q.visualPrompt here to allow fallback generation
        if (q.visualUri || q.isGeneratingVisual) return;

        // Determine if generation is allowed
        const isGloballyEnabled = displaySettings.imageGenerationEnabled;
        const isTempEnabled = quizState.tempImageGenEnabled; // Check session flag

        if (!isGloballyEnabled && !isTempEnabled && !force) {
            return; // Silent exit if disabled and not forced
        }

        // If forced (user tapped), enable temp flag for the rest of the session
        if (force && !isTempEnabled) {
            setQuizState((prev: any) => ({ ...prev, tempImageGenEnabled: true }));
        }

        // MODIFIED: Resolve prompt to use
        let promptToUse = q.visualPrompt ? q.visualPrompt.trim() : "";
        if (!promptToUse) {
            if (force) {
                // Create a fallback prompt using the question text
                const cleanQ = q.question.replace(/[*_#`]/g, '');
                // IMPROVEMENT: Explicitly ask for context/understanding, not solution
                promptToUse = `Create an educational diagram or illustration to help understand the concept of this question: "${cleanQ}". Do NOT show the answer.`;
            } else {
                return; // No prompt and not forced, do nothing
            }
        }

        // OPTIMIZATION: Check for existing generated images for identical prompts in the same quiz
        // If found, reuse the existing URI instead of generating a new image
        const existingMatch = quizState.questions.find(
            (otherQ: any, otherIdx: number) => otherIdx !== index && otherQ.visualUri && (
                (otherQ.visualPrompt && otherQ.visualPrompt.trim() === promptToUse) ||
                (!otherQ.visualPrompt && force && otherQ.question === q.question)
            )
        );

        if (existingMatch) {
            console.log("Smart Reuse: Found existing image for similar prompt, skipping generation.");
            setQuizState((prev: any) => {
                const newQuestions = [...prev.questions];
                newQuestions[index] = {
                    ...newQuestions[index],
                    visualUri: existingMatch.visualUri,
                    isGeneratingVisual: false
                };
                // Persist tempImageGenEnabled if we just set it
                const newState = { ...prev, questions: newQuestions };
                if (force) newState.tempImageGenEnabled = true;
                return newState;
            });

            // Persist the reused image link
            if (quizState.originId && chatSessions[quizState.originId]) {
                const session = chatSessions[quizState.originId];
                // Clone current state questions to ensure we save the updated version with reused URI
                const updatedQuestions = [...quizState.questions];
                updatedQuestions[index] = { ...updatedQuestions[index], visualUri: existingMatch.visualUri };
                session.quizData = updatedQuestions;
                persistSession(session);
            }
            return;
        }

        // Update state to showing loading
        setQuizState((prev: any) => {
            const newQuestions = [...prev.questions];
            newQuestions[index] = { ...newQuestions[index], isGeneratingVisual: true };
            // Persist tempImageGenEnabled if we just set it
            const newState = { ...prev, questions: newQuestions };
            if (force) newState.tempImageGenEnabled = true;
            return newState;
        });

        try {
            // Pass 'true' as the second argument to force generation since we've already handled permission logic above
            // UPDATED: Changed style prompt to request standard/realistic images instead of simple line diagrams
            // IMPROVEMENT: Added negative constraint "Constraint: Do NOT include text answers..."
            const uri = await generateImage(promptToUse + " Constraint: Do NOT include text answers, solutions, or checkmarks. Just illustrate the subject matter. style: detailed, standard educational illustration, realistic colors, high resolution, white background.", true);

            if (uri) {
                const savedUri = await ensureImageIsSavedToFile(uri);
                setQuizState((prev: any) => {
                    const newQuestions = [...prev.questions];
                    newQuestions[index] = { ...newQuestions[index], visualUri: savedUri, isGeneratingVisual: false };
                    return { ...prev, questions: newQuestions };
                });

                // Persist logic
                if (quizState.originId && chatSessions[quizState.originId]) {
                    const session = chatSessions[quizState.originId];
                    // We need to update the session in chatSessions to reflect the new image
                    // Creating a deep copy of questions to avoid mutating state directly in persist
                    const updatedQuestions = [...quizState.questions];
                    updatedQuestions[index] = { ...updatedQuestions[index], visualUri: savedUri };
                    session.quizData = updatedQuestions;
                    persistSession(session);
                }
            } else {
                throw new Error("No URI returned");
            }

        } catch (e) {
            console.warn("Quiz visual gen failed", e);
            setQuizState((prev: any) => {
                const newQuestions = [...prev.questions];
                newQuestions[index] = { ...newQuestions[index], isGeneratingVisual: false };
                return { ...prev, questions: newQuestions };
            });

            // NEW: Alert user on failure so they know why spinner stopped
            if (force) {
                Alert.alert("Generation Failed", "The AI image service is currently busy or overloaded, or maybe you are using free api key that not support image generation Please try again in a moment.");
            }
        }
    };

    // NEW: Effect to trigger generation when navigating to a question
    useEffect(() => {
        if (appMode === 'live' && quizState && !quizState.completed) {
            const index = quizState.currentIndex;
            const q = quizState.questions[index];
            // Auto-generate if visual prompt exists, no image yet, not generating, and enabled in settings OR temp enabled
            const shouldGenerate = displaySettings.imageGenerationEnabled || quizState.tempImageGenEnabled;

            if (q?.visualPrompt && !q.visualUri && !q.isGeneratingVisual && shouldGenerate) {
                handleGenerateQuizVisual(index);
            }
        }
    }, [quizState?.currentIndex, appMode]); // Note: We rely on currentIndex change or quizState update

    // --- NEW: Flashcards Handlers ---
    const handleStartFlashcardsFromResult = () => {
        if (!quizState) return;
        // Use existing topic and subject, enable flashcard mode
        handleStartQuiz(quizState.topic, false, quizState.subject, false, [], null, true);
    };

    const handleSavedQuestionsFlashcards = () => {
        // FILTER: Only use flashcard questions (no options)
        const flashcardQuestions = savedQuestions.filter(q => !q.options || q.options.length === 0);

        if (flashcardQuestions.length === 0) {
            Alert.alert("No Saved Flashcards", "Save some flashcards (without options) first!");
            return;
        }

        // Parse dynamic count from schoolConfig.length
        let count = 10;
        const configLength = parseInt(schoolConfig.length);
        if (!isNaN(configLength) && configLength > 0) {
            count = configLength;
        } else {
            if (schoolConfig.length === 'Short') count = 5;
            if (schoolConfig.length === 'Medium') count = 10;
            if (schoolConfig.length === 'Large') count = 25;
        }

        setFlashcardSession({
            items: [...flashcardQuestions].sort(() => Math.random() - 0.5).slice(0, count), // Shuffle and use dynamic limit
            currentIndex: 0,
            flipped: false,
            type: 'question'
        });
        setAppMode('flashcards');
    };

    const handleSavedWordsFlashcards = () => {
        if (savedWords.length === 0) {
            Alert.alert("No Saved Words", "Save some words from dictionary first!");
            return;
        }

        // Parse dynamic count from schoolConfig.length
        let count = 10;
        const configLength = parseInt(schoolConfig.length);
        if (!isNaN(configLength) && configLength > 0) {
            count = configLength;
        } else {
            if (schoolConfig.length === 'Short') count = 5;
            if (schoolConfig.length === 'Medium') count = 10;
            if (schoolConfig.length === 'Large') count = 25;
        }

        setFlashcardSession({
            items: [...savedWords].sort(() => Math.random() - 0.5).slice(0, count), // Shuffle and use dynamic limit
            currentIndex: 0,
            flipped: false,
            type: 'word'
        });
        setAppMode('flashcards');
    };

    const handleSavedWordsQuiz = () => {
        if (savedWords.length === 0) {
            Alert.alert("No Words", "Save words to your library first.");
            return;
        }

        // Parse dynamic count from schoolConfig.length
        let count = 20;
        const configLength = parseInt(schoolConfig.length);
        if (!isNaN(configLength) && configLength > 0) {
            count = configLength;
        } else {
            if (schoolConfig.length === 'Short') count = 10;
            if (schoolConfig.length === 'Medium') count = 20;
            if (schoolConfig.length === 'Large') count = 50;
        }

        setShowHistory(false);
        const shuffled = [...savedWords].sort(() => 0.5 - Math.random()).slice(0, count);
        const wordList = shuffled.map(w => w.word).join(", ");
        handleStartQuiz(wordList, true);
    };

    const handleSavedQuizAsFlashcards = () => {
        // FILTER: Only use quiz questions (with options)
        const quizQuestionsSubset = savedQuestions.filter(q => q.options && q.options.length > 0);

        if (quizQuestionsSubset.length === 0) {
            Alert.alert("No Questions", "Save quiz questions to your library first.");
            return;
        }

        // Parse dynamic count from schoolConfig.length
        let count = 10;
        const configLength = parseInt(schoolConfig.length);
        if (!isNaN(configLength) && configLength > 0) {
            count = configLength;
        } else {
            if (schoolConfig.length === 'Short') count = 5;
            if (schoolConfig.length === 'Medium') count = 10;
            if (schoolConfig.length === 'Large') count = 25;
        }

        setFlashcardSession({
            items: [...quizQuestionsSubset].sort(() => Math.random() - 0.5).slice(0, count), // Shuffle and use dynamic limit
            currentIndex: 0,
            flipped: false,
            type: 'question'
        });
        setAppMode('flashcards');
    };

    const handleSavedQuestionsQuiz = async () => {
        // FILTER: Only use quiz questions (with options)
        const quizQuestionsSubset = savedQuestions.filter(q => q.options && q.options.length > 0);

        if (quizQuestionsSubset.length === 0) {
            Alert.alert("No Questions", "Save quiz questions to your library first.");
            return;
        }

        // Parse dynamic count from schoolConfig.length
        let count = 10;
        const configLength = parseInt(schoolConfig.length);
        if (!isNaN(configLength) && configLength > 0) {
            count = configLength;
        } else {
            if (schoolConfig.length === 'Short') count = 5;
            if (schoolConfig.length === 'Medium') count = 10;
            if (schoolConfig.length === 'Large') count = 25;
        }

        setShowHistory(false);

        const shuffled = [...quizQuestionsSubset].sort(() => 0.5 - Math.random()).slice(0, count);

        // NEW: Randomize options for saved questions too
        const randomizedQuestions = randomizeQuizData(shuffled);

        const quizQuestions = randomizedQuestions.map(q => ({
            question: q.question,
            options: q.options,
            correctOptionIndex: q.correctOptionIndex,
            explanation: q.explanation,
            selected: null,
            markForReview: false,
            visited: false
        }));

        const timeSpent = new Array(quizQuestions.length).fill(0);

        const quizId = generateId();

        const newSession = {
            id: quizId,
            timestamp: new Date().toISOString(),
            messages: [{ role: "ai", content: "Interactive Quiz Started" }],
            title: "Review: Saved Questions",
            toolId: 'quiz_save',
            quizData: quizQuestions,
            score: 0,
            totalQuestions: quizQuestions.length,
            completed: false,
            translations: { [displaySettings.language]: quizQuestions },
            language: displaySettings.language,
            attempts: 1, // Init attempts
            isExamMode: false // NEW: Saved questions review defaults to Practice Mode
        };

        await persistSession(newSession);

        setQuizState({
            questions: quizQuestions,
            currentIndex: 0,
            score: 0,
            completed: false,
            title: "Review: Saved Questions",
            timeSpent: timeSpent,
            activeQuestionStartTime: Date.now(),
            originId: quizId,
            translations: { [displaySettings.language]: quizQuestions },
            language: displaySettings.language,
            attempts: 1, // Init attempts
            isExamMode: false // NEW: Freeze to Practice
        });
        setQuizSecondsElapsed(0);
        setNavOrigin(appMode);
        setAppMode("live");
        setShowReferenceText(false); // Reset reference toggle
    };

    const renderFlashcards = () => {
        if (!flashcardSession) return null;

        const currentItem = flashcardSession.items[flashcardSession.currentIndex];
        const isFlipped = flashcardSession.flipped;
        const total = flashcardSession.items.length;

        // Auto-play logic
        const startAutoPlay = () => {
            flashcardAutoPlay = true;
            setFlashcardSession((prev: any) => ({ ...prev }));
            playCurrentCard();
        };

        const stopAutoPlay = () => {
            flashcardAutoPlay = false;
            if (autoPlayTimer) {
                clearTimeout(autoPlayTimer);
                autoPlayTimer = null;
            }
            Speech.stop();
            flashcardTTSPlaying = false;
            setFlashcardSession((prev: any) => ({ ...prev }));
        };

        const playCurrentCard = () => {
            if (!flashcardAutoPlay) return;

            // Use callback to get current state instead of closure
            setFlashcardSession((currentSession: any) => {
                const currentIdx = currentSession.currentIndex;
                const currentFlipped = currentSession.flipped;
                const item = currentSession.items[currentIdx];

                let textToSpeak = "";

                if (!currentFlipped) {
                    // Front side: Read question/word
                    textToSpeak = (item.front || item.question || item.word || "").trim();
                } else {
                    // Back side: Read answer/explanation + examples
                    const answer = (item.back || item.answer || item.definition || item.explanation || "").trim();
                    textToSpeak = answer;

                    // Handle generated cards with single example
                    if (item.example && item.example.trim()) {
                        textToSpeak += ". Example: " + item.example.trim();
                    }

                    // Handle word cards with examples array
                    if (item.examples && item.examples.length > 0) {
                        const exampleTexts = item.examples.slice(0, 3).join(". ");
                        textToSpeak += ". Examples: " + exampleTexts;
                    }
                }

                if (textToSpeak) {
                    flashcardTTSPlaying = true;
                    Speech.speak(textToSpeak, {
                        language: displaySettings.primaryLanguage || 'en',
                        pitch: 1.0,
                        rate: 0.9,
                        onDone: () => {
                            flashcardTTSPlaying = false;
                            if (!flashcardAutoPlay) {
                                setFlashcardSession((prev: any) => ({ ...prev }));
                                return;
                            }

                            // Wait 1 second, then flip or move to next
                            autoPlayTimer = setTimeout(() => {
                                if (!flashcardAutoPlay) return;

                                setFlashcardSession((prev: any) => {
                                    if (!prev.flipped) {
                                        // Flip to back
                                        const newState = { ...prev, flipped: true };
                                        // Continue playing after flip
                                        setTimeout(() => playCurrentCard(), 100);
                                        return newState;
                                    } else {
                                        // Move to next card
                                        if (prev.currentIndex < prev.items.length - 1) {
                                            const newState = {
                                                ...prev,
                                                currentIndex: prev.currentIndex + 1,
                                                flipped: false
                                            };
                                            // Continue playing next card
                                            setTimeout(() => playCurrentCard(), 100);
                                            return newState;
                                        } else {
                                            // Reached the end
                                            stopAutoPlay();
                                            Alert.alert("Auto-Play Complete", "You've reached the end of the deck.");
                                            return prev;
                                        }
                                    }
                                });
                            }, 1000);
                        },
                        onStopped: () => {
                            flashcardTTSPlaying = false;
                            setFlashcardSession((prev: any) => ({ ...prev }));
                        },
                        onError: () => {
                            flashcardTTSPlaying = false;
                            setFlashcardSession((prev: any) => ({ ...prev }));
                        }
                    });
                }

                // Return unchanged state (we only read from it)
                return currentSession;
            });
        };

        const handleNext = () => {
            // Stop auto-play on manual navigation
            if (flashcardAutoPlay) {
                stopAutoPlay();
            }
            if (flashcardSession.currentIndex < total - 1) {
                setFlashcardSession((prev: any) => ({ ...prev, currentIndex: prev.currentIndex + 1, flipped: false }));
            } else {
                Alert.alert("Nice!", "You've reviewed all cards.", [
                    { text: "Restart", onPress: () => setFlashcardSession((prev: any) => ({ ...prev, currentIndex: 0, flipped: false })) },
                    { text: "Finish", onPress: () => setAppMode('idle') }
                ]);
            }
        };

        const handlePrev = () => {
            // Stop auto-play on manual navigation
            if (flashcardAutoPlay) {
                stopAutoPlay();
            }
            if (flashcardSession.currentIndex > 0) {
                setFlashcardSession((prev: any) => ({ ...prev, currentIndex: prev.currentIndex - 1, flipped: false }));
            }
        };

        const handleFlip = () => {
            // Stop auto-play on manual flip
            if (flashcardAutoPlay) {
                stopAutoPlay();
            }
            setFlashcardSession((prev: any) => ({ ...prev, flipped: !prev.flipped }));
        };

        const handleDeleteCard = async () => {
            Alert.alert(
                "Delete Card",
                "Are you sure you want to permanently delete this item?",
                [
                    { text: "Cancel", style: "cancel" },
                    {
                        text: "Delete",
                        style: 'destructive',
                        onPress: async () => {
                            const currentItem = flashcardSession.items[flashcardSession.currentIndex];

                            // NEW: Unified Deletion Logic - Delete from Source
                            if (currentItem) {
                                try {
                                    // 1. Check if it's a Dictionary Word (has 'word')
                                    if (currentItem.word && !currentItem.question) {
                                        // A. If it has an ID, it's a Saved Word -> Delete from Dictionary
                                        if (currentItem.id) {
                                            await deleteSavedWord(currentItem.id);
                                        }

                                        // B. ALWAYS remove from "Personal Dictionary" (recentSearches) history
                                        /* 
                                           FIX: Handle both object ({word: '...'}) and string formats in recentSearches.
                                           This ensures deletions from Home Page (which might not have IDs yet) 
                                           correctly remove the item from history so it doesn't reappear.
                                        */
                                        const wordText = currentItem.word.toLowerCase();
                                        const updatedRecents = recentSearches.filter((w: any) => {
                                            const wText = (typeof w === 'string' ? w : w.word) || "";
                                            return wText.toLowerCase() !== wordText;
                                        });

                                        if (updatedRecents.length !== recentSearches.length) {
                                            setRecentSearches(updatedRecents);
                                            AsyncStorage.setItem('recentSearches', JSON.stringify(updatedRecents));
                                        }
                                    }
                                    // 2. Check if it's a Saved Question (has 'question')
                                    else if (currentItem.question) {
                                        // It's a saved question
                                        // toggleSaveQuestion handles removal if it exists
                                        await toggleSaveQuestion(currentItem);
                                    }
                                } catch (e: any) {
                                    console.error("Error deleting item source:", e);
                                    // Continue to remove from session even if source delete fails (UI Consistency)
                                }
                            }

                            const newItems = flashcardSession.items.filter((_: any, idx: number) => idx !== flashcardSession.currentIndex);

                            if (newItems.length === 0) {
                                Alert.alert("Empty", "All cards deleted.", [{ text: "Exit", onPress: () => setAppMode('idle') }]);
                                // Also delete the session from library if empty
                                if (flashcardSession.originId) {
                                    const updatedSessions = { ...chatSessions };
                                    delete updatedSessions[flashcardSession.originId];
                                    setChatSessions(updatedSessions);

                                    // Granular Deletion
                                    AsyncStorage.removeItem(`session_${flashcardSession.originId}`).catch(e => console.error("Delete error", e));
                                    AsyncStorage.getItem('session_index').then(indexJson => {
                                        if (indexJson) {
                                            const indices = JSON.parse(indexJson);
                                            const newIndices = indices.filter((id: string) => id !== flashcardSession.originId);
                                            AsyncStorage.setItem('session_index', JSON.stringify(newIndices));
                                        }
                                    });

                                    // Custom Audio Cleanup
                                    if (customAudioUris[flashcardSession.originId]) {
                                        try {
                                            const audioUri = customAudioUris[flashcardSession.originId];
                                            await FileSystem.deleteAsync(audioUri, { idempotent: true });
                                            const newAudioUris = { ...customAudioUris };
                                            delete newAudioUris[flashcardSession.originId];
                                            if (setCustomAudioUris) setCustomAudioUris(newAudioUris);
                                            await AsyncStorage.setItem('customAudioUris', JSON.stringify(newAudioUris));
                                        } catch (e) { console.error("Audio cleanup error in handleDeleteCard", e); }
                                    }
                                }
                                return;
                            }

                            // Calculate new index
                            const newIndex = flashcardSession.currentIndex >= newItems.length ? newItems.length - 1 : flashcardSession.currentIndex;

                            const updatedSession = {
                                ...flashcardSession,
                                items: newItems,
                                currentIndex: newIndex,
                                flipped: false
                            };

                            setFlashcardSession(updatedSession);

                            // Persist changes to Library
                            if (flashcardSession.originId && chatSessions[flashcardSession.originId]) {
                                const librarySession = {
                                    ...chatSessions[flashcardSession.originId],
                                    items: newItems,
                                    timestamp: new Date().toISOString() // Update timestamp on modify
                                };
                                setChatSessions((prev: any) => ({ ...prev, [flashcardSession.originId]: librarySession }));
                                await persistSession(librarySession);
                            }
                        }
                    }
                ]
            );
        };


        const handleToggleSaveCard = async () => {
            if (flashcardSession.type === 'word') {
                // Unified Vocabulary Saving (FileSystem Based)
                const wordToSave = (currentItem.front || currentItem.word || currentItem.question || "").trim();
                const defToSave = (currentItem.back || currentItem.definition || currentItem.answer || currentItem.explanation || "").trim();

                if (!wordToSave) return;

                // toggleSaveWord handles storage limit and FileSystem persistence
                await toggleSaveWord(wordToSave, defToSave, currentItem.examples);
            } else {
                // Unified Question Saving (AsyncStorage Based)
                const questionToSave = (currentItem.front || currentItem.question || "").trim();
                const answerToSave = (currentItem.back || currentItem.explanation || currentItem.answer || "").trim();

                if (!questionToSave) return;

                const newQuestion = {
                    id: generateId(),
                    question: questionToSave,
                    explanation: answerToSave,
                    options: currentItem.options || [],
                    correctOptionIndex: currentItem.correctOptionIndex !== undefined ? currentItem.correctOptionIndex : -1,
                    timestamp: Date.now(),
                    tags: ['flashcard']
                };

                // toggleSaveQuestion handles current savedQuestions list and persistence
                await toggleSaveQuestion(newQuestion);
            }
        };

        const isSaved = flashcardSession.type === 'word'
            ? savedWords.some(w => w.word.toLowerCase() === (currentItem.front || currentItem.word || currentItem.question || "").trim().toLowerCase())
            : savedQuestions.some(q => q.question.toLowerCase() === (currentItem.front || currentItem.question || currentItem.word || "").trim().toLowerCase());


        return (
            <SafeAreaView style={{ flex: 1, backgroundColor: theme.uiBg }}>
                <View style={{ flex: 1 }}>
                    {/* PERSISTENT HEADER (Quiz Style) */}
                    <View style={{
                        padding: 15,
                        borderBottomWidth: 1,
                        borderBottomColor: theme.border,
                        backgroundColor: theme.bg,
                        flexDirection: 'row',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        zIndex: 30,
                        position: 'relative' // Needed for absolute centering
                    }}>
                        {/* Left: Title + Save/Delete */}
                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 15, zIndex: 2 }}>
                            <Text style={{ fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase', fontSize: 12 }}>
                                FLASHCARDS
                            </Text>

                            {/* Star / Save */}
                            <TouchableOpacity onPress={handleToggleSaveCard} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
                                <Star size={20} color={isSaved ? "#eab308" : theme.text} fill={isSaved ? "#eab308" : "transparent"} opacity={isSaved ? 1 : 0.7} />
                            </TouchableOpacity>

                            {/* Delete */}
                            <TouchableOpacity onPress={handleDeleteCard} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
                                <Trash2 size={20} color={theme.text} opacity={0.7} />
                            </TouchableOpacity>
                        </View>

                        {/* Center: Progress & Label */}
                        <View style={{
                            flex: 1, // Take up remaining space
                            justifyContent: 'center',
                            alignItems: 'center',
                            zIndex: 1
                        }}>
                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5 }}>
                                <Text style={{ fontWeight: 'bold', color: theme.text }}>
                                    {flashcardSession.currentIndex + 1}/{total}
                                </Text>
                            </View>
                        </View>

                        {/* Right: Auto-Play, TTS, Appearance & Close */}
                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 15, zIndex: 2 }}>

                            {/* Auto-Play Toggle */}
                            <TouchableOpacity
                                onPress={() => {
                                    if (flashcardAutoPlay) {
                                        stopAutoPlay();
                                    } else {
                                        startAutoPlay();
                                    }
                                }}
                                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                            >
                                {flashcardAutoPlay ? (
                                    <Pause size={20} color={"#10b981"} opacity={1} />
                                ) : (
                                    <Play size={20} color={theme.text} opacity={0.7} />
                                )}
                            </TouchableOpacity>

                            {/* TTS Button */}
                            <TouchableOpacity
                                onPress={() => {
                                    if (flashcardTTSPlaying) {
                                        // Stop TTS
                                        Speech.stop();
                                        flashcardTTSPlaying = false;
                                        // Force re-render by updating flashcard session
                                        setFlashcardSession((prev: any) => ({ ...prev }));
                                    } else {
                                        // Start TTS
                                        let textToSpeak = "";

                                        if (isFlipped) {
                                            // Back side: Read answer/explanation + examples
                                            const answer = (currentItem.back || currentItem.answer || currentItem.definition || currentItem.explanation || "").trim();
                                            textToSpeak = answer;

                                            // Handle generated cards with single example
                                            if (currentItem.example && currentItem.example.trim()) {
                                                textToSpeak += ". Example: " + currentItem.example.trim();
                                            }

                                            // Handle word cards with examples array
                                            if (currentItem.examples && currentItem.examples.length > 0) {
                                                const exampleTexts = currentItem.examples.slice(0, 3).join(". ");
                                                textToSpeak += ". Examples: " + exampleTexts;
                                            }
                                        } else {
                                            // Front side: Read question/word
                                            textToSpeak = (currentItem.front || currentItem.question || currentItem.word || "").trim();
                                        }

                                        if (textToSpeak) {
                                            flashcardTTSPlaying = true;
                                            setFlashcardSession((prev: any) => ({ ...prev }));
                                            Speech.speak(textToSpeak, {
                                                language: displaySettings.primaryLanguage || 'en',
                                                pitch: 1.0,
                                                rate: 0.9,
                                                onDone: () => {
                                                    flashcardTTSPlaying = false;
                                                    setFlashcardSession((prev: any) => ({ ...prev }));
                                                },
                                                onStopped: () => {
                                                    flashcardTTSPlaying = false;
                                                    setFlashcardSession((prev: any) => ({ ...prev }));
                                                },
                                                onError: () => {
                                                    flashcardTTSPlaying = false;
                                                    setFlashcardSession((prev: any) => ({ ...prev }));
                                                }
                                            });
                                        }
                                    }
                                }}
                                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                            >
                                {flashcardTTSPlaying ? (
                                    <Square size={20} color={theme.text} opacity={0.7} />
                                ) : (
                                    <Volume2 size={20} color={theme.text} opacity={0.7} />
                                )}
                            </TouchableOpacity>

                            {/* Translation Button */}
                            <TouchableOpacity
                                onPress={switchFlashcardLanguage}
                                disabled={isTranslating}
                                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                                style={{
                                    width: 30, height: 30, borderRadius: 15, // Match other icons roughly or just be text
                                    alignItems: 'center', justifyContent: 'center',
                                    borderWidth: 1, borderColor: theme.border
                                }}
                            >
                                {isTranslating ? (
                                    <ActivityIndicator size="small" color={theme.text} />
                                ) : (
                                    <Text style={{ color: theme.text, fontWeight: '900', fontSize: 11 }}>
                                        {(flashcardSession?.language || displaySettings.language).substring(0, 2).toUpperCase()}
                                    </Text>
                                )}
                            </TouchableOpacity>

                            {/* Appearance */}
                            <TouchableOpacity
                                onPress={() => setShowAppearance(true)}
                                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                            >
                                <Palette size={20} color={theme.text} opacity={0.7} />
                            </TouchableOpacity>

                            {/* Close */}
                            <TouchableOpacity onPress={() => {
                                Alert.alert("Exit Flashcards?", "Progress is not saved.", [
                                    { text: "Cancel", style: "cancel" },
                                    { text: "Exit", style: 'destructive', onPress: () => setAppMode('idle') }
                                ]);
                            }} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
                                <X size={20} color={theme.text} opacity={0.7} />
                            </TouchableOpacity>
                        </View>
                    </View>

                    {/* Front (Question/Word) */}
                    {!isFlipped && (
                        <View
                            style={{
                                flex: 1,
                                backgroundColor: theme.uiBg,
                            }}
                        >
                            {/* Touch Zones Overlay - SIDES ONLY so Center is Scrollable */}
                            <View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, flexDirection: 'row', zIndex: 10 }} pointerEvents="box-none">
                                <TouchableOpacity
                                    activeOpacity={1}
                                    onPress={handlePrev}
                                    style={{ width: '20%', height: '100%' }}
                                />
                                {/* Center Spacer - Transparent to touches so ScrollView gets them */}
                                <View style={{ width: '60%', height: '100%' }} pointerEvents="none" />
                                <TouchableOpacity
                                    activeOpacity={1}
                                    onPress={handleNext}
                                    style={{ width: '20%', height: '100%' }}
                                />
                            </View>

                            {/* Content (Scrollable) */}
                            <ScrollView
                                contentContainerStyle={{ flexGrow: 1, justifyContent: 'flex-start' }}
                                showsVerticalScrollIndicator={true}
                            >
                                <Pressable
                                    onPress={handleFlip}
                                    style={{ flex: 1, alignItems: 'center', justifyContent: 'flex-start', padding: 20, paddingTop: 40, paddingBottom: 60 }}
                                >
                                    <Text style={{ fontSize: 13 * (displaySettings.fontSize || 1), fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase', marginBottom: 20 }}>
                                        {flashcardSession.type === 'word' ? 'Word' : (flashcardSession.type === 'generated' ? 'Question' : 'Question')}
                                    </Text>
                                    <View style={{ width: '100%' }}>
                                        <ParsedText
                                            text={currentItem.front || currentItem.word || currentItem.question}
                                            theme={theme}
                                            style={{ fontSize: 24 * (displaySettings.fontSize || 1), color: theme.text, textAlign: 'center', lineHeight: 34 * (displaySettings.fontSize || 1), ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                        />
                                    </View>
                                    <View style={{ flex: 1, justifyContent: 'center' }}>
                                        <Text style={{ marginTop: 20, color: theme.secondary, fontSize: 12 }}>
                                            Tap Center to Flip
                                        </Text>
                                    </View>
                                </Pressable>
                            </ScrollView>
                        </View>
                    )}

                    {/* Back (Definition/Answer) */}
                    {isFlipped && (
                        <View
                            style={{
                                flex: 1,
                                backgroundColor: theme.uiBg,
                            }}
                        >
                            {/* Touch Zones Overlay */}
                            <View style={{ ...StyleSheet.absoluteFillObject, flexDirection: 'row', zIndex: 10 }} pointerEvents="box-none">
                                <TouchableOpacity
                                    activeOpacity={1}
                                    onPress={handlePrev}
                                    style={{ width: '20%', height: '100%' }}
                                />
                                <View style={{ flex: 1 }} pointerEvents="none" />
                                <TouchableOpacity
                                    activeOpacity={1}
                                    onPress={handleNext}
                                    style={{ width: '20%', height: '100%' }}
                                />
                            </View>

                            {/* Content (Center handles flip via Tap) */}
                            <ScrollView
                                contentContainerStyle={{ flexGrow: 1, justifyContent: 'flex-start' }}
                                showsVerticalScrollIndicator={true}
                            >
                                <Pressable
                                    onPress={handleFlip}
                                    style={{ flex: 1, alignItems: 'center', padding: 20, paddingTop: 20, minHeight: '100%', paddingBottom: 60 }}
                                >
                                    <Text style={{ fontSize: 14, fontWeight: 'bold', color: '#22c55e', textTransform: 'uppercase', marginBottom: 5, marginTop: 10 }}>
                                        {flashcardSession.type === 'word' ? 'Definition' : (flashcardSession.type === 'generated' ? 'Explanation' : 'Answer')}
                                    </Text>

                                    {/* GENERATED CARDS LAYOUT */}
                                    {flashcardSession.type === 'generated' && (
                                        <>
                                            {/* Reduced font size for detailed 300-400 char explanations */}
                                            {/* Reduced font size for detailed 300-400 char explanations */}
                                            <View style={{ marginBottom: 20, width: '100%' }}>
                                                <ParsedText
                                                    text={currentItem.back}
                                                    theme={theme}
                                                    style={{ fontSize: 18 * (displaySettings.fontSize || 1), color: theme.text, textAlign: 'justify', lineHeight: 28 * (displaySettings.fontSize || 1), ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                />
                                            </View>
                                            {currentItem.example && (
                                                <View style={{ marginTop: 10, width: '100%' }}>
                                                    <Text style={{ fontSize: 12, fontWeight: 'bold', color: theme.secondary, marginBottom: 8, alignSelf: 'center' }}>EXAMPLE</Text>
                                                    <Text style={{ fontSize: 15, color: theme.text, fontStyle: 'italic', textAlign: 'center', marginBottom: 8, opacity: 0.9 }}>
                                                        "{currentItem.example}"
                                                    </Text>
                                                </View>
                                            )}
                                        </>
                                    )}

                                    {/* QUESTION LAYOUT */}
                                    {flashcardSession.type === 'question' && (
                                        <>
                                            <View style={{ marginBottom: 20, alignItems: 'center', width: '100%' }}>
                                                <Text style={{ color: '#22c55e', fontSize: 22 * (displaySettings.fontSize || 1), textAlign: 'center', lineHeight: 32 * (displaySettings.fontSize || 1), ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>
                                                    {currentItem.options[currentItem.correctOptionIndex]}
                                                </Text>
                                            </View>

                                            {/* Parsed Explanation */}
                                            <View style={{ width: '100%' }}>
                                                <ParsedText
                                                    text={currentItem.explanation}
                                                    theme={theme}
                                                    onExpand={handleExpandTable}
                                                    style={{ color: theme.text, fontSize: 20 * (displaySettings.fontSize || 1), lineHeight: 30 * (displaySettings.fontSize || 1), textAlign: 'justify', ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                />
                                            </View>

                                            {/* Visual Image if available */}
                                            {currentItem.visualUri && (
                                                <TouchableOpacity onPress={() => setFullScreenImage(currentItem.visualUri)} style={{ width: '100%', marginTop: 20 }}>
                                                    <Image
                                                        source={{ uri: currentItem.visualUri }}
                                                        style={{ width: '100%', height: 200, borderRadius: 8, backgroundColor: theme.inputBg }}
                                                        resizeMode="contain"
                                                    />
                                                </TouchableOpacity>
                                            )}
                                        </>
                                    )}

                                    {/* WORD LAYOUT */}
                                    {flashcardSession.type === 'word' && (
                                        <>
                                            <Text style={{ fontSize: 22 * (displaySettings.fontSize || 1), color: theme.text, textAlign: 'center', lineHeight: 32 * (displaySettings.fontSize || 1), marginBottom: 20, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>
                                                {currentItem.definition}
                                            </Text>
                                            {currentItem.examples && currentItem.examples.length > 0 && (
                                                <View style={{ marginTop: 10, width: '100%' }}>
                                                    <Text style={{ fontSize: 12, fontWeight: 'bold', color: theme.secondary, marginBottom: 8, alignSelf: 'center' }}>EXAMPLES</Text>
                                                    {currentItem.examples.slice(0, 3).map((ex: any, idx: number) => (
                                                        <Text key={idx} style={{ fontSize: 15, color: theme.text, fontStyle: 'italic', textAlign: 'center', marginBottom: 8, opacity: 0.9 }}>
                                                            "{ex}"
                                                        </Text>
                                                    ))}
                                                </View>
                                            )}
                                        </>
                                    )}
                                    <Text style={{ marginTop: 30, color: theme.secondary, fontSize: 12, textAlign: 'center', opacity: 0.6 }}>
                                        Tap Center to Flip Back
                                    </Text>
                                </Pressable>
                            </ScrollView>


                        </View>
                    )
                    }
                </View >
            </SafeAreaView >
        );
    };

    // NEW: Helper to update quiz mode on the fly (Results Screen)
    const updateQuizMode = async (newMode: boolean) => {
        setQuizState((prev: any) => ({ ...prev, isExamMode: newMode }));

        // Also update the session in storage/state so it persists if we exit and reload
        if (quizState?.originId && chatSessions[quizState.originId]) {
            const updatedSession = {
                ...chatSessions[quizState.originId],
                isExamMode: newMode
            };
            // Persist silently
            await persistSession(updatedSession);
        }
    };

    // NEW: Helper to open help tips in reader (No Modal closing needed as it's embedded)
    const openTipInReader = (title: string, content: string, origin = 'idle') => {
        const tipSession = {
            id: `tip_${Date.now()}`,
            timestamp: new Date().toISOString(),
            title: title,
            messages: [{ role: 'ai', content: content }],
            toolId: 'help_guide',
            translations: { [displaySettings.language]: content },
            language: displaySettings.language
        };
        loadHistorySession(tipSession, origin);
    };

    const saveCurrentNote = async () => {
        if (!currentNoteInput.trim() && currentNoteImages.length === 0) return null;

        // IMPROVED: Title generation with strict length limit
        let titleCandidate = currentNoteTitle.trim();

        if (!titleCandidate) {
            // Auto-generate from first line of body if title is empty
            titleCandidate = currentNoteInput.split('\n')[0].trim();
        }

        // Enforce max length of 100 characters for clean UI
        let title = titleCandidate.substring(0, 100).trim();
        if (titleCandidate.length > 100) title += "...";

        title = title || "New Note";

        const sessionId = currentNoteId || generateId();

        let savedImages: any[] = [];
        if (currentNoteImages.length > 0) {
            savedImages = await Promise.all(currentNoteImages.map(uri => ensureImageIsSavedToFile(uri)));
        }

        // NEW: Preserve existing properties like 'pinned' if editing an existing note
        const existingSession = chatSessions[sessionId];

        const newSession = {
            id: sessionId,
            timestamp: new Date().toISOString(),
            messages: [{ role: "user", content: currentNoteInput }],
            title: title,
            toolId: "quick_notes",
            images: savedImages,
            pinned: existingSession ? existingSession.pinned : false, // Preserve pinned status
            highlights: existingSession ? existingSession.highlights : [] // Preserve highlights
        };

        await persistSession(newSession);
        return newSession;
    };

    const handleSaveNote = async () => {
        if (!currentNoteInput.trim() && currentNoteImages.length === 0) {
            Alert.alert("Empty Note", "Please write something or add an image.");
            return;
        }

        // FIX: Dismiss keyboard so the bottom toast is visible
        Keyboard.dismiss();

        // NEW: Show Saving status in Header AND Toast
        setIsSaving(true);
        showToast("Saving note...");

        // Small delay to ensure UI updates and keyboard animates down before heavy async work
        await new Promise(resolve => setTimeout(resolve, 100));

        const savedSession = await saveCurrentNote();

        setIsSaving(false);

        setIsEditingNote(false);
        setCurrentNoteInput("");
        setCurrentNoteTitle("");
        setCurrentNoteSummary("");
        setCurrentNoteId(null);
        setCurrentNoteImages([]);
        setCustomNotePrompt(""); // Clear prompt
        resetHistory(""); // Reset history

        // CHANGED: Open in Reader Mode immediately after saving
        if (savedSession) {
            loadHistorySession(savedSession);
            showToast("Note Saved");
        }
    };

    // NEW: Handle Preview Note (View in Reader without saving/clearing state)
    const handlePreviewNote = async () => {
        if (!currentNoteInput.trim() && currentNoteImages.length === 0) {
            Alert.alert("Empty Note", "Please write something to preview.");
            return;
        }

        // Auto-generate title for preview context
        let titleCandidate = currentNoteTitle.trim();
        if (!titleCandidate) {
            titleCandidate = currentNoteInput.split('\n')[0].trim();
        }
        let title = titleCandidate.substring(0, 100).trim();
        if (titleCandidate.length > 100) title += "...";
        title = title || "New Note (Preview)";

        const sessionId = currentNoteId || "temp_preview";
        const existingSession = chatSessions[sessionId];

        const tempSession = {
            id: sessionId,
            timestamp: new Date().toISOString(),
            messages: [{ role: "user", content: currentNoteInput }],
            title: title,
            toolId: "quick_notes",
            images: currentNoteImages, // Use current images directly
            pinned: false,
            highlights: existingSession ? existingSession.highlights : [] // Preserve highlights in preview
        };

        // Load into reader. 
        // When user goes back, appMode becomes 'idle', activeTab is 'notes', isEditingNote is true.
        // So editor state is preserved.
        loadHistorySession(tempSession, 'idle');
    };

    // FIXED: Restored handleReadNote function
    const handleReadNote = async () => {
        if (!currentNoteInput.trim() && currentNoteImages.length === 0) {
            Alert.alert("Empty Note", "Please write something to read.");
            return;
        }

        const savedSession = await saveCurrentNote();
        if (savedSession) {
            loadHistorySession(savedSession);
        }
    };

    // FIXED: Restored handleExportNote function
    const handleExportNote = async () => {
        if (!currentNoteInput.trim() && currentNoteImages.length === 0) {
            Alert.alert("Empty", "Cannot export an empty note.");
            return;
        }

        // NEW: Show starting toast
        showToast("Exporting note...");

        // Allow UI to render toast before native dialogs take over
        await new Promise(resolve => setTimeout(resolve, 100));

        const title = currentNoteTitle.trim() || "Untitled Note";
        const safeName = title.replace(/[<>:"/\\|?*]/g, '-');
        const filename = `${safeName}.json`;

        // Construct temporary session object for export
        const tempSession = {
            id: currentNoteId || generateId(),
            timestamp: new Date().toISOString(),
            messages: [{ role: "user", content: currentNoteInput }],
            title: title,
            toolId: "quick_notes",
            images: currentNoteImages,
            pinned: false,
            highlights: [] // Or current highlights if editing existing
        };

        // Use Unified Bundle
        const bundle = await createShareBundle([tempSession], 'notes');
        const bundleString = JSON.stringify(bundle, null, 2);

        // ANDROID: Use Storage Access Framework (Direct "Save To" Folder)
        if (Platform.OS === 'android') {
            try {
                // 1. Try to retrieve saved directory URI
                let directoryUri = await AsyncStorage.getItem('savedExportDirectory');

                const attemptSave = async (uri: string) => {
                    try {
                        const newFileUri = await fs.StorageAccessFramework.createFileAsync(uri, filename, 'application/json');
                        await fs.writeAsStringAsync(newFileUri, bundleString, { encoding: fs.EncodingType.UTF8 });
                        return true;
                    } catch (e: any) {
                        console.log("Export failed with saved URI:", e);
                        return false;
                    }
                };

                let success = false;
                if (directoryUri) {
                    success = await attemptSave(directoryUri);
                }

                if (!success) {
                    const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                    if (permissions.granted) {
                        directoryUri = permissions.directoryUri;
                        await AsyncStorage.setItem('savedExportDirectory', directoryUri);
                        success = await attemptSave(directoryUri);
                    }
                }

                if (success) {
                    showToast("Saved to Device");
                } else {
                    Alert.alert("Save Failed", "Could not save the file. Please ensure you selected a valid folder.");
                }
            } catch (e) {
                console.error("Android Save Error", e);
                Alert.alert("Save Failed", "An error occurred while accessing storage.");
            }
            return;
        }

        // iOS / Fallback: Use Share Sheet
        if (!(await Sharing.isAvailableAsync())) {
            Alert.alert("Error", "Sharing is not available on this device.");
            return;
        }

        try {
            const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
            const fileUri = cacheDir + filename;
            await fs.writeAsStringAsync(fileUri, bundleString, { encoding: fs.EncodingType.UTF8 });
            await Sharing.shareAsync(fileUri, {
                mimeType: 'application/json',
                dialogTitle: `Export: ${title}`,
                UTI: 'public.json'
            });
        } catch (e) {
            console.error("Export Note Error", e);
            Alert.alert("Export Failed", "Could not save the note.");
        }
    };

    // NEW: Handle sharing the application
    const handleShareApp = async () => {
        try {
            const playStoreLink = 'https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp';
            const features = [
                "ðŸ“š Offline Dictionary",
                "ðŸ¤– AI Personal Assistant",
                "ðŸ“° Editorial Generation",
                "ðŸ“ Smart Notes",
                "ðŸ§  Flashcards & Quizzes",
                "ðŸŽ¥ Vision AI",
                "âœï¸ Story Generator"
            ];

            const message = `Check out Reader App - Your AI Reading Assistant! ðŸš€\n\nKey Features:\n${features.map(f => `â€¢ ${f}`).join('\n')}\n\nDownload now: ${playStoreLink}`;

            await Share.share({
                message: message,
                url: playStoreLink,
                title: 'Reader App'
            });
        } catch (error: any) {
            Alert.alert('Error', error.message);
        }
    };

    // NEW: Handle sharing quiz result (Certificate)
    const handleShareCertificate = async () => {
        if (!quizState) return;

        // Note: Removed check for locked state to allow certificate sharing regardless of lock status
        // The user wants certificate sharing to work always.

        if (!(await Sharing.isAvailableAsync())) {
            Alert.alert("Not Available", "File sharing is not available on this device.");
            return;
        }

        showToast("Generating Certificate...");

        try {
            // UPDATED: Default name to "Mukesh" if not set
            const senderName = displaySettings.userName || "Mukesh";
            let quizTitle = quizState.title || "General Quiz";

            // Logic to determine Instructor Name
            let instructorName = "Reader AI";
            const sharedMatch = quizTitle.match(/\(Shared by (.*?)\)/);
            if (sharedMatch) {
                instructorName = sharedMatch[1];
                // Optional: Remove the tag from title on certificate for cleaner look
                quizTitle = quizTitle.replace(/\(Shared by .*?\)/, '').trim();
            }

            const score = quizState.score;
            const total = quizState.questions.length;
            const date = new Date().toISOString();

            // NEW: Capture attempts and ID for certificate details
            const attempts = quizState.attempts || 1;
            const quizId = quizState.originId || generateId();

            // FIX: Format Time as HH:MM:SS
            const totalSeconds = quizSecondsElapsed;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const timeTaken = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            // Generate HTML with new structure and time stamp
            const htmlContent = generateCertificateHtml(senderName, quizTitle, score, total, date, attempts, quizId, timeTaken, instructorName);

            const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
            const safeTitle = quizTitle.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
            const filename = `Certificate_${safeTitle}.html`;
            const fileUri = cacheDir + filename;

            await fs.writeAsStringAsync(fileUri, htmlContent, { encoding: fs.EncodingType.UTF8 });

            await Sharing.shareAsync(fileUri, {
                mimeType: 'text/html',
                dialogTitle: `Share Certificate: ${quizTitle}`,
                UTI: 'public.html'
            });

        } catch (e) {
            console.error("Share Certificate Error", e);
            Alert.alert("Error", "Could not generate certificate.");
        }
    };

    // NEW: Handle sharing quiz file (JSON for import)
    const handleShareQuizFile = async () => {
        if (!quizState) return;

        const originSession = quizState.originId ? chatSessions[quizState.originId] : null;
        const hasPassword = !!originSession?.password;
        const isLocked = hasPassword && !isReviewUnlocked;

        if (isLocked) {
            Alert.alert("Locked", "Unlock the quiz to share the file.");
            return;
        }

        if (!(await Sharing.isAvailableAsync())) {
            Alert.alert("Not Available", "Sharing is not available on this device.");
            return;
        }

        showToast("Preparing quiz file...");

        try {
            // Reset selections so the recipient gets a fresh quiz
            const cleanQuestions = quizState.questions.map((q: any) => ({
                ...q,
                selected: null,
                markedForReview: false,
                visited: false
            }));

            const senderName = displaySettings.userName || "A user";
            const scoreMsg = `Check out my score: ${quizState.score}/${quizState.questions.length} in ReaderApp!`;

            // Preserve password if set
            const password = originSession?.password;
            const forceExamMode = !!password;

            const exportSession = {
                id: generateId(),
                title: `${quizState.title} (Shared by ${senderName})`,
                timestamp: new Date().toISOString(),
                toolId: 'quiz_save', // Ensures it opens as a quiz
                quizData: cleanQuestions,
                messages: [{ role: 'ai', content: `Shared Quiz: ${quizState.title}\n\n${scoreMsg}` }],
                language: displaySettings.language,
                description: scoreMsg,
                password: password,
                isExamMode: forceExamMode,
                modeLocked: forceExamMode,
                // NEW: Persist Language Learning Settings to Receiver
                preventTranslation: quizState.preventTranslation,
                subject: quizState.subject
            };

            // Use Unified Share Bundle
            const bundle = await createShareBundle([exportSession], 'quiz');

            const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
            const safeTitle = (quizState.title || "Quiz").replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
            const filename = `Quiz_${safeTitle}.json`;
            const fileUri = cacheDir + filename;

            await fs.writeAsStringAsync(fileUri, JSON.stringify(bundle, null, 2), { encoding: fs.EncodingType.UTF8 });

            await Sharing.shareAsync(fileUri, {
                mimeType: 'application/json',
                dialogTitle: `Share Quiz: ${quizState.title}`,
                UTI: 'public.json'
            });

        } catch (e) {
            console.error("Share Quiz File Error", e);
            Alert.alert("Error", "Could not share quiz file.");
        }
    };

    // NEW: Handle Batch Export (Android Only)
    const handleBatchExport = async () => {
        if (selectedNoteIds.length === 0) return;

        if (Platform.OS === 'android') {
            try {
                // Prepare the Bundle
                showToast(`Preparing ${selectedNoteIds.length} notes...`);
                await new Promise(r => setTimeout(r, 100));

                const selectedSessions = selectedNoteIds.map(id => chatSessions[id]).filter(Boolean);
                if (selectedSessions.length === 0) return;

                // Use Unified Bundle
                const bundle = await createShareBundle(selectedSessions, 'notes');
                const content = JSON.stringify(bundle, null, 2);

                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `Notes_Export_${timestamp}.json`;

                // Check for saved directory
                const savedDir = await AsyncStorage.getItem('savedExportDirectory');
                let usedDir = savedDir;

                const saveFile = async (uri: string) => {
                    try {
                        const newFileUri = await fs.StorageAccessFramework.createFileAsync(uri, filename, 'application/json');
                        await fs.writeAsStringAsync(newFileUri, content, { encoding: fs.EncodingType.UTF8 });
                        return true;
                    } catch (e: any) {
                        return false;
                    }
                };

                let success = false;
                if (savedDir) {
                    success = await saveFile(savedDir);
                }

                if (!success) {
                    try {
                        const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                        if (permissions.granted) {
                            await AsyncStorage.setItem('savedExportDirectory', permissions.directoryUri);
                            usedDir = permissions.directoryUri;
                            success = await saveFile(permissions.directoryUri);
                        }
                    } catch (e: any) { }
                }

                if (success) {
                    setIsSelectionMode(false);
                    setSelectedNoteIds([]);
                    let folderName = "Device Storage";
                    try {
                        if (usedDir) {
                            const decoded = decodeURIComponent(usedDir);
                            const parts = decoded.split(':');
                            if (parts.length > 1) {
                                folderName = parts[parts.length - 1];
                            }
                        }
                    } catch (e: any) { }
                    Alert.alert("Export Complete", `Saved notes as '${filename}' in folder '${folderName}'.`);
                } else {
                    Alert.alert("Export Failed", "Could not save the file.");
                }
            } catch (e) {
                Alert.alert("Error", "Batch export failed.");
            }
        } else {
            // iOS - Reuse Share logic
            handleNoteBatchShare();
        }
    };

    // NEW: Handle Batch Share for Notes
    const handleNoteBatchShare = async () => {
        if (selectedNoteIds.length === 0) return;

        try {
            const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
            showToast("Preparing bundle...");
            await new Promise(r => setTimeout(r, 100));

            const selectedSessions = selectedNoteIds.map(id => chatSessions[id]).filter(Boolean);

            if (selectedSessions.length === 0) {
                Alert.alert("Empty", "No content found.");
                return;
            }

            // Use Unified Bundle
            const bundle = await createShareBundle(selectedSessions, 'notes');
            const content = JSON.stringify(bundle, null, 2);

            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `Notes_Bundle_${timestamp}.json`;
            const fileUri = cacheDir + filename;

            await fs.writeAsStringAsync(fileUri, content, { encoding: fs.EncodingType.UTF8 });

            await Sharing.shareAsync(fileUri, {
                mimeType: 'application/json',
                dialogTitle: `Share ${selectedNoteIds.length} Notes`,
                UTI: 'public.json'
            });

            setIsSelectionMode(false);
            setSelectedNoteIds([]);

        } catch (e) {
            console.error("Batch Share Error", e);
            Alert.alert("Error", "Could not share items.");
        }
    };

    // NEW: Handle Export Dictionary (JSON)
    const handleExportDictionary = async () => {
        if (recentSearches.length === 0) {
            Alert.alert("Empty", "Your personal dictionary is empty.");
            return;
        }

        showToast("Exporting Dictionary...");
        await new Promise(r => setTimeout(r, 100));

        // Use Unified Bundle for Dictionary
        const bundle = await createShareBundle(recentSearches, 'dictionary');
        const content = JSON.stringify(bundle, null, 2);

        const filename = `personal_dictionary_${new Date().toISOString().slice(0, 10)}.json`;

        if (Platform.OS === 'android') {
            try {
                let directoryUri = await AsyncStorage.getItem('savedExportDirectory');
                const attemptSave = async (uri: string) => {
                    try {
                        const newFileUri = await fs.StorageAccessFramework.createFileAsync(uri, filename, 'application/json');
                        await fs.writeAsStringAsync(newFileUri, content, { encoding: fs.EncodingType.UTF8 });
                        return true;
                    } catch (e: any) {
                        return false;
                    }
                };

                let success = false;
                if (directoryUri) success = await attemptSave(directoryUri);

                if (!success) {
                    const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                    if (permissions.granted) {
                        directoryUri = permissions.directoryUri;
                        await AsyncStorage.setItem('savedExportDirectory', directoryUri);
                        success = await attemptSave(directoryUri);
                    }
                }

                if (success) {
                    showToast("Dictionary Saved");
                } else {
                    Alert.alert("Save Failed", "Could not save the dictionary file.");
                }
            } catch (e) {
                console.error("Dict Export Error", e);
                Alert.alert("Error", "Storage access failed.");
            }
        } else {
            // iOS Share
            try {
                const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
                const fileUri = cacheDir + filename;
                await fs.writeAsStringAsync(fileUri, content, { encoding: fs.EncodingType.UTF8 });
                await Sharing.shareAsync(fileUri);
            } catch (e) {
                Alert.alert("Error", "Share failed.");
            }
        }
    };

    // NEW: Handle Download Dictionary from Google Drive
    const handleDownloadDictionary = async () => {
        const driveUrl = 'https://drive.google.com/drive/folders/1mmm7KKdm5Ma0WRUK5zLRy5QyTDFv-1D6?usp=drive_link';

        try {
            const supported = await Linking.canOpenURL(driveUrl);
            if (supported) {
                await Linking.openURL(driveUrl);
            } else {
                Alert.alert("Error", "Cannot open Google Drive link.");
            }
        } catch (e) {
            console.error("Download Dictionary Error", e);
            Alert.alert("Error", "Failed to open link.");
        }
    };


    // UPDATED: Handle Share Dictionary as JSON File (for easy import) with Safe Locking
    const handleShareDictionary = async () => {
        // Prevent double taps or overlapping shares
        if (isSharing) return;

        if (recentSearches.length === 0) {
            Alert.alert("Empty", "Your personal dictionary is empty.");
            return;
        }

        if (!(await Sharing.isAvailableAsync())) {
            Alert.alert("Not Available", "Sharing is not available on this device.");
            return;
        }

        setIsSharing(true);
        showToast("Preparing file...");
        await new Promise(r => setTimeout(r, 100));

        try {
            // Use Unified Bundle
            const bundle = await createShareBundle(recentSearches, 'dictionary');
            const content = JSON.stringify(bundle, null, 2);

            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `Dictionary_Share_${timestamp}.json`;

            const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
            const fileUri = cacheDir + filename;

            await fs.writeAsStringAsync(fileUri, content, { encoding: fs.EncodingType.UTF8 });

            await Sharing.shareAsync(fileUri, {
                mimeType: 'application/json',
                dialogTitle: `Share Dictionary (${recentSearches.length} words)`,
                UTI: 'public.json'
            });

        } catch (e) {
            if ((e as any).message && (e as any).message.includes('Another share request')) {
                console.log("Share debounce: ignored overlapping request");
            } else {
                console.error("Share Dictionary Error", e);
                Alert.alert("Error", "Could not generate share file.");
            }
        } finally {
            setTimeout(() => setIsSharing(false), 1000);
        }
    };

    // NEW: Handle Import Dictionary (JSON)
    const handleImportDictionary = async () => {
        try {
            const result = await DocumentPicker.getDocumentAsync({
                type: ['application/json', 'public.json'],
                copyToCacheDirectory: true
            });

            if (!result.canceled && result.assets && result.assets.length > 0) {
                const uri = result.assets[0].uri;
                const content = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.UTF8 });

                let importedData = [];
                try {
                    const json = JSON.parse(content);
                    // Check for Unified Format
                    if (json.type === 'reader_unified_export' && Array.isArray(json.items)) {
                        importedData = json.items;
                    } else if (Array.isArray(json)) {
                        importedData = json;
                    } else if (json.dictionary && Array.isArray(json.dictionary)) {
                        importedData = json.dictionary;
                    }
                } catch (e: any) {
                    Alert.alert("Invalid File", "The file is not valid JSON.");
                    return;
                }

                if (!Array.isArray(importedData)) {
                    Alert.alert("Invalid Data", "The file must contain a list of words.");
                    return;
                }

                let addedCount = 0;
                // CHANGED: Map based on recentSearches for duplicates
                const currentWordMap = new Map(recentSearches.map(item => {
                    const w = typeof item === 'string' ? item : item.word;
                    return [w.toLowerCase(), true];
                }));

                const newItems = [];

                for (const item of importedData) {
                    let wordString = "";
                    let wordData = null;

                    // Handle various potential formats (Legacy Saved vs New Personal)
                    if (typeof item === 'string') {
                        wordString = item;
                    } else if (item.word && item.data) {
                        // Personal Dictionary Format: { word: "...", data: {...} }
                        wordString = item.word;
                        wordData = item.data;
                    } else if (item.word) {
                        // Saved Words Format: { word: "...", definition: "..." }
                        wordString = item.word;
                        wordData = item; // Use the whole item as data
                    }

                    if (wordString && typeof wordString === 'string' && !currentWordMap.has(wordString.toLowerCase())) {
                        // Normalize to Personal Dictionary format
                        const newItem = {
                            word: wordString,
                            data: wordData || { word: wordString, definition: "Imported word", timestamp: new Date().toISOString() }
                        };

                        newItems.push(newItem);
                        addedCount++;
                    }
                }

                if (addedCount > 0) {
                    // CHANGED: Merge into recentSearches
                    const updatedList = [...newItems, ...recentSearches];

                    // Enforce Limit
                    const limit = displaySettings.dictionaryLimit || 1000;
                    const finalIndex = updatedList.slice(0, limit);

                    setRecentSearches(finalIndex);
                    await saveRecentSearchesToFile(finalIndex);

                    Alert.alert("Import Successful", `Added ${addedCount} words to Personal Dictionary.`);
                } else {
                    Alert.alert("No New Words", "All words in the file already exist in your history.");
                }
            }
        } catch (e) {
            console.error("Dict Import Error", e);
            Alert.alert("Error", "Could not import dictionary.");
        }
    };

    // NEW: Handle Export Audio File directly from Library List
    const handleExportAudioFile = async (item: any, parentGroup: any = null) => {
        // Block if already processing
        if (isExportingAudioId) return;

        // Check availability
        if (!(await Sharing.isAvailableAsync())) {
            Alert.alert("Not Available", "Sharing is not available on this device.");
            return;
        }

        setIsExportingAudioId(item.id);

        try {
            const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
            let niceName = item.matchedTitle || "Audio";
            // Sanitize filename
            niceName = niceName.replace(/:/g, ' - ').replace(/[^a-zA-Z0-9 \-_]/g, '').trim().substring(0, 60);
            if (!niceName) niceName = "Audio";

            let finalUri = null;
            let isGenerated = false;

            // Determine Source Files for potential merge
            let sourceFiles: any[] = [];

            if (parentGroup && parentGroup.chapters) {
                // Check for split parts (siblings with same title)
                const siblings = parentGroup.chapters.filter((c: any) => c.matchedTitle === item.matchedTitle);
                if (siblings.length > 0) {
                    sourceFiles = siblings;
                } else {
                    sourceFiles = [item];
                }
            } else if (item.isGroup && item.files && item.files.length > 1) {
                sourceFiles = item.files;
            } else {
                sourceFiles = [item];
            }

            // Determine if we need to merge (More than 1 file)
            if (sourceFiles.length > 1) {
                showToast("Merging audio parts... Please wait.");
                // Yield to let toast appear
                await new Promise(r => setTimeout(r, 100));

                const parts = [];
                let totalDataLength = 0;
                let masterHeader: Uint8Array | null = null;

                // Helper to find 'data' chunk
                const findDataChunk = (bytes: Uint8Array) => {
                    // Min header is 44 bytes
                    if (bytes.length < 44) return { offset: 44, size: 0 };

                    // RIFF check
                    if (String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]) !== 'RIFF') {
                        return { offset: 44, size: 0 };
                    }

                    let pos = 12; // Skip RIFF + Size + WAVE
                    while (pos < bytes.length - 8) {
                        const chunkId = String.fromCharCode(bytes[pos], bytes[pos + 1], bytes[pos + 2], bytes[pos + 3]);
                        const chunkSize = bytes[pos + 4] | (bytes[pos + 5] << 8) | (bytes[pos + 6] << 16) | (bytes[pos + 7] << 24);

                        if (chunkId === 'data') {
                            return { offset: pos + 8, size: chunkSize };
                        }

                        pos += 8 + chunkSize;
                    }
                    return { offset: 44, size: 0 };
                };

                for (let i = 0; i < sourceFiles.length; i++) {
                    const f = sourceFiles[i];
                    try {
                        const b64 = await fs.readAsStringAsync(f.uri, { encoding: fs.EncodingType.Base64 });
                        const bytes = decodeBase64(b64);

                        const chunkInfo = findDataChunk(bytes);

                        // WAV Header is 44 bytes minimum
                        if (bytes.length < 44) continue;

                        if (i === 0) {
                            // Keep header from first file to use as template
                            // We use the offset discovered to keep ALL metadata chunks
                            masterHeader = bytes.slice(0, chunkInfo.offset);
                            const data = bytes.slice(chunkInfo.offset, chunkInfo.offset + chunkInfo.size);
                            parts.push(data);
                            totalDataLength += data.length;
                        } else {
                            // Strip header from subsequent files
                            const data = bytes.slice(chunkInfo.offset, chunkInfo.offset + chunkInfo.size);
                            parts.push(data);
                            totalDataLength += data.length;
                        }
                    } catch (e: any) {
                        console.warn("Failed to read part " + i, e);
                    }
                }

                if (parts.length > 0 && masterHeader) {
                    // Construct new WAV buffer
                    const mergedBuffer = new Uint8Array(masterHeader.length + totalDataLength);
                    mergedBuffer.set(masterHeader, 0);

                    let offset = masterHeader.length;
                    for (const part of parts) {
                        mergedBuffer.set(part, offset);
                        offset += part.length;
                    }

                    // Patch Header Size Fields
                    const view = new DataView(mergedBuffer.buffer);
                    // Offset 4: ChunkSize = Total Size - 8
                    view.setUint32(4, mergedBuffer.length - 8, true);

                    // Offset for SubChunk2Size (Data Size) is 4 bytes before the data starts
                    // masterHeader includes everything up to data, so size field is at end of masterHeader - 4
                    const dataSizeOffset = masterHeader.length - 4;
                    view.setUint32(dataSizeOffset, totalDataLength, true);

                    const mergedB64 = encodeBase64(mergedBuffer);
                    const tempUri = cacheDir + `${niceName}_Merged.wav`;
                    await fs.writeAsStringAsync(tempUri, mergedB64, { encoding: fs.EncodingType.Base64 });

                    finalUri = tempUri;
                    isGenerated = true;
                } else {
                    Alert.alert("Error", "Failed to merge audio files.");
                    return;
                }
            } else {
                // Single file (Orphan or Group with 1 file)
                if (sourceFiles.length > 0) {
                    finalUri = sourceFiles[0].uri;
                } else {
                    finalUri = item.uri;
                }
            }

            if (!finalUri) return;

            // If we didn't generate a new file (i.e. existing single file), copy it to cache with nice name
            let shareUri = finalUri;
            if (!isGenerated) {
                const niceUri = cacheDir + `${niceName}.wav`;
                // Copy to ensure nice filename in share dialog (and avoid modifying original)
                await fs.copyAsync({ from: finalUri, to: niceUri });
                shareUri = niceUri;
            }

            await Sharing.shareAsync(shareUri, {
                dialogTitle: `Save Audio: ${niceName}`,
                UTI: 'com.microsoft.waveform-audio',
                mimeType: 'audio/wav'
            });

        } catch (e) {
            console.log("Export error", e);
            Alert.alert("Error", "Could not export audio file.");
        } finally {
            setIsExportingAudioId(null);
        }
    };

    // NEW: Handle Export All Data (Backup Library & Notes & Dictionary)
    const handleExportAllData = async () => {
        const allSessions = Object.values(chatSessions);
        // UPDATED: Check if both sessions and dictionary are empty
        if (allSessions.length === 0 && recentSearches.length === 0) {
            Alert.alert("Empty", "No data to export.");
            return;
        }

        // NEW: Ask user preference regarding heavy audio files
        Alert.alert(
            "Backup Options",
            "Do you want to include offline audio files? This will significantly increase the backup file size.",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Text Only (Fast)",
                    onPress: () => performFullBackup(false)
                },
                {
                    text: "Include Audio (Slow)",
                    onPress: () => performFullBackup(true)
                }
            ]
        );

        const performFullBackup = async (includeAudio: boolean) => {
            showToast(includeAudio ? "Preparing Backup..." : "Creating Backup...");
            // Yield to UI
            await new Promise(r => setTimeout(r, 100));

            try {
                const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;

                // 1. Prepare Session Data (Resolving external content files)
                const exportSessions = await Promise.all(allSessions.map(async (session: any) => {
                    // If session has external content path, try to read it
                    if (session.contentPath) {
                        try {
                            const info = await fs.getInfoAsync(session.contentPath);
                            if (info.exists) {
                                const fullContent = await fs.readAsStringAsync(session.contentPath, { encoding: fs.EncodingType.UTF8 });
                                // Deep clone to avoid mutating state
                                const fullSession = JSON.parse(JSON.stringify(session));
                                if (fullSession.messages && fullSession.messages.length > 0) {
                                    fullSession.messages[0].content = fullContent;
                                }
                                delete fullSession.contentPath;
                                return fullSession;
                            }
                        } catch (e: any) {
                            console.warn(`Failed to resolve content for ${session.id}`, e);
                        }
                    }
                    return session;
                }));

                // 2. Prepare Audio Data (If requested)
                let audioBackup: any[] = [];
                if (includeAudio) {
                    try {
                        const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                        if (!docDir) throw new Error("Document directory not available");
                        const files = await fs.readDirectoryAsync(docDir);
                        const ttsFiles = files.filter(f => f.startsWith('tts_') && f.endsWith('.wav'));

                        if (ttsFiles.length > 0) {
                            // SIZE CHECK: Calculate total size before reading into memory
                            let totalAudioSize = 0;
                            for (const f of ttsFiles) {
                                const info = await fs.getInfoAsync(docDir + f);
                                totalAudioSize += ((info as any).size || 0);
                            }

                            // Safety Limit: 100MB for Audio (To prevent OOM Crash during JSON.stringify)
                            const SAFE_LIMIT = 100 * 1024 * 1024;

                            if (totalAudioSize > SAFE_LIMIT) {
                                Alert.alert(
                                    "Backup Too Large",
                                    `Audio files total ${(totalAudioSize / 1024 / 1024).toFixed(1)}MB, which exceeds the single-file backup limit.\n\nPlease export Audio separately from the Library tab, or choose "Text Only" backup.`,
                                    [
                                        { text: "Cancel Backup", style: "cancel" },
                                        { text: "Continue (Text Only)", onPress: () => performFullBackup(false) }
                                    ]
                                );
                                return;
                            }

                            showToast(`Archiving ${ttsFiles.length} audio files...`);

                            // Read files
                            audioBackup = await Promise.all(ttsFiles.map(async (filename) => {
                                try {
                                    const b64 = await fs.readAsStringAsync(docDir + filename, { encoding: fs.EncodingType.Base64 });
                                    return { name: filename, data: b64 };
                                } catch (e: any) {
                                    console.warn("Failed to backup audio file", filename);
                                    return null;
                                }
                            }));
                            audioBackup = audioBackup.filter(Boolean);
                        }
                    } catch (e: any) {
                        console.warn("Audio backup error", e);
                    }
                }

                // 3. Construct Final Object
                const backupData = {
                    type: "reader_backup_v2",
                    timestamp: new Date().toISOString(),
                    sessions: exportSessions,
                    dictionary: recentSearches,
                    audio: audioBackup
                };

                // 4. Create File
                const filename = `full_backup_${includeAudio ? 'with_audio_' : ''}${new Date().toISOString().slice(0, 10)}.json`;
                const fileUri = cacheDir + filename;

                try {
                    // Attempt to stringify and write
                    const content = JSON.stringify(backupData, null, 2);
                    await fs.writeAsStringAsync(fileUri, content, { encoding: fs.EncodingType.UTF8 });
                } catch (jsonError: any) {
                    // Catch string length errors specifically
                    if (jsonError.message && jsonError.message.includes('string')) { // Matches "Invalid string length" or "RangeError"
                        Alert.alert("Backup Failed", "The data is too large to process in a single file. Please delete some items or export Audio separately.");
                        return;
                    }
                    throw jsonError;
                }

                // 5. Export
                if (Platform.OS === 'android') {
                    try {
                        let directoryUri = await AsyncStorage.getItem('savedExportDirectory');

                        const attemptSave = async (dirUri: string) => {
                            try {
                                const newFileUri = await fs.StorageAccessFramework.createFileAsync(dirUri, filename, 'application/json');
                                // We need to read the temp file back string to pass to SAF (limitation of Expo SAF)
                                // This double-read might be heavy, but it's the only way with SAF currently
                                const contentStr = await fs.readAsStringAsync(fileUri, { encoding: fs.EncodingType.UTF8 });
                                await fs.writeAsStringAsync(newFileUri, contentStr, { encoding: fs.EncodingType.UTF8 });
                                return true;
                            } catch (e: any) { return false; }
                        };

                        let success = false;
                        if (directoryUri) success = await attemptSave(directoryUri);

                        if (!success) {
                            const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                            if (permissions.granted) {
                                directoryUri = permissions.directoryUri;
                                await AsyncStorage.setItem('savedExportDirectory', directoryUri);
                                success = await attemptSave(directoryUri);
                            }
                        }

                        if (success) {
                            showToast("Backup Saved");
                            // Clean up temp
                            await fs.deleteAsync(fileUri, { idempotent: true });
                            return;
                        }
                    } catch (e: any) {
                        console.log("SAF failed, falling back to Share", e);
                    }
                }

                // iOS / Fallback
                await Sharing.shareAsync(fileUri, {
                    mimeType: 'application/json',
                    dialogTitle: `Save Backup: ${filename}`,
                    UTI: 'public.json'
                });

            } catch (e) {
                console.error("Full Backup Error", e);
                Alert.alert("Backup Failed", "An error occurred while creating the backup. " + (e as any).message);
            }
        };
    };

    // NEW: Handle Import All Data (Restore Backup)
    const handleImportAllData = async () => {
        try {
            const result = await DocumentPicker.getDocumentAsync({
                type: ['application/json', 'public.json'],
                copyToCacheDirectory: true
            });

            if (!result.canceled && result.assets && result.assets.length > 0) {
                showToast("Reading Backup File...");
                // Yield UI
                await new Promise(r => setTimeout(r, 100));

                const uri = result.assets[0].uri;
                const content = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.UTF8 });

                let importedData = null;
                try {
                    importedData = JSON.parse(content);
                } catch (e: any) {
                    Alert.alert("Invalid File", "The file is not valid JSON.");
                    return;
                }

                // UPDATED: Handle both Legacy (Array) and New (Object) formats
                let sessionsToImport = [];
                let dictionaryToImport = [];
                let audioToImport = [];

                if (Array.isArray(importedData)) {
                    // Legacy Format: Just an array of sessions
                    sessionsToImport = importedData;
                } else if (importedData && typeof importedData === 'object') {
                    // New Format: { sessions: [], dictionary: [], audio: [] }
                    if (importedData.sessions && Array.isArray(importedData.sessions)) {
                        sessionsToImport = importedData.sessions;
                    }
                    if (importedData.dictionary && Array.isArray(importedData.dictionary)) {
                        dictionaryToImport = importedData.dictionary;
                    }
                    // NEW: Check for Audio
                    if (importedData.audio && Array.isArray(importedData.audio)) {
                        audioToImport = importedData.audio;
                    }
                } else {
                    Alert.alert("Invalid Data", "The file structure is not recognized.");
                    return;
                }

                let addedSessionCount = 0;
                let skippedSessionCount = 0;
                let addedWordCount = 0;
                let addedAudioCount = 0;
                const docDir = fs.documentDirectory || FileSystem.documentDirectory;

                // --- 1. Import Audio FIRST (Moved up to allow linking) ---
                // Maintain a set of available files to check against when importing sessions
                const availableAudioFiles = new Set();

                // Populate with existing files first
                try {
                    if (!docDir) throw new Error("No docDir");
                    const existing = await fs.readDirectoryAsync(docDir);
                    existing.forEach(f => {
                        if (f.startsWith('tts_') && f.endsWith('.wav')) availableAudioFiles.add(f);
                    });
                } catch (e: any) { }

                if (audioToImport.length > 0) {
                    showToast(`Restoring ${audioToImport.length} Audio Files...`);
                    await new Promise(r => setTimeout(r, 100)); // Yield UI

                    for (const audioFile of audioToImport) {
                        if (audioFile.name && audioFile.data) {
                            try {
                                const uri = docDir + audioFile.name;
                                await fs.writeAsStringAsync(uri, audioFile.data, { encoding: fs.EncodingType.Base64 });
                                addedAudioCount++;
                                availableAudioFiles.add(audioFile.name);
                            } catch (e: any) {
                                console.warn("Failed to restore audio file", audioFile.name);
                            }
                        }
                    }

                    // Refresh the Audio Library list if we are on that tab
                    if (activeTab === 'library' && libraryTab === 'audio') {
                        loadAudioFiles();
                    }
                }

                // --- 2. Import Sessions ---
                const newSessionsMap: any = {};
                const storagePairs: [string, string][] = [];
                const CONTENT_SIZE_THRESHOLD = 5 * 1024; // 5KB
                const currentVoice = displaySettings.voice || "Kore";

                // Get current index
                const indexJson = await AsyncStorage.getItem('session_index');
                let currentIndex = indexJson ? JSON.parse(indexJson) : [];

                if (sessionsToImport.length > 0) showToast("Restoring Text Data...");

                for (const session of sessionsToImport) {
                    // Basic validation: must have id and toolId
                    if (session.id && session.toolId) {
                        // Check for duplicate ID
                        // FIX: Check against currentIndex (Source of Truth) instead of loaded chatSessions (which might be partial/empty)
                        if (currentIndex.includes(session.id)) {
                            skippedSessionCount++;
                            continue;
                        }

                        // Handle Large Content (Restore file structure if needed)
                        let sessionToSave = JSON.parse(JSON.stringify(session)); // Deep clone
                        let msgContent = session.messages?.[0]?.content || "";

                        if (msgContent.length > CONTENT_SIZE_THRESHOLD) {
                            const filename = `content_${session.id}.txt`;
                            const filePath = `${docDir}${filename}`;
                            try {
                                await fs.writeAsStringAsync(filePath, msgContent, { encoding: fs.EncodingType.UTF8 });
                                sessionToSave.contentPath = filename; // Store relative for consistency

                                // BUG FIX: Generate and store preview before clearing content
                                sessionToSave.preview = msgContent.substring(0, 100).replace(/\n/g, ' ');

                                sessionToSave.messages[0].content = msgContent.substring(0, 200) + "... (Content saved to file)";
                                // Clear translations for storage to save space
                                if (sessionToSave.translations) sessionToSave.translations = {};
                            } catch (err) {
                                console.warn("Failed to write content file for restored item", err);
                            }
                        }

                        // NEW: Auto-Link Audio
                        // Check if valid audio exists for this session's content
                        if (msgContent) {
                            const cleanText = cleanTextForDisplay(msgContent);
                            const hash = simpleHash(cleanText + currentVoice);
                            const safeTitle = getSafeFileName(session.title);
                            const expectedName = `tts_${hash}_${safeTitle}.wav`;
                            const oldName = `tts_${hash}.wav`;

                            if (availableAudioFiles.has(expectedName) || availableAudioFiles.has(oldName)) {
                                sessionToSave.hasAudio = true;
                                session.hasAudio = true; // Update in-memory object too
                            }
                        }

                        // Prepare State Object (Full content for immediate UI update)
                        newSessionsMap[session.id] = session;

                        // Prepare Storage Object (Optimized)
                        storagePairs.push([`session_${session.id}`, JSON.stringify(sessionToSave)]);

                        if (!currentIndex.includes(session.id)) {
                            currentIndex.push(session.id);
                        }

                        addedSessionCount++;
                    }
                }

                // --- 3. Import Dictionary ---
                let newDictionaryList = [...recentSearches];
                if (dictionaryToImport.length > 0) {
                    const currentWordMap = new Map(recentSearches.map(item => {
                        const w = typeof item === 'string' ? item : item.word;
                        return [w.toLowerCase(), true];
                    }));

                    for (const item of dictionaryToImport) {
                        // Normalize format
                        let wordString = "";
                        let wordData = null;

                        if (typeof item === 'string') {
                            wordString = item;
                        } else if (item.word && item.data) {
                            wordString = item.word;
                            wordData = item.data;
                        } else if (item.word) {
                            wordString = item.word;
                            wordData = item;
                        }

                        if (wordString && typeof wordString === 'string' && !currentWordMap.has(wordString.toLowerCase())) {
                            const newItem = {
                                word: wordString,
                                data: wordData || { word: wordString, definition: "Imported word", timestamp: new Date().toISOString() }
                            };
                            newDictionaryList.push(newItem);
                            addedWordCount++;
                            // Add to map to prevent duplicates within the import list itself
                            currentWordMap.set(wordString.toLowerCase(), true);
                        }
                    }

                    // Enforce limit
                    const limit = displaySettings.dictionaryLimit || 1000;
                    newDictionaryList = newDictionaryList.slice(0, limit);
                }

                // --- 4. Commit Changes ---
                if (addedSessionCount > 0) {
                    const finalSessions = { ...chatSessions, ...newSessionsMap };
                    setChatSessions(finalSessions);
                    await AsyncStorage.multiSet(storagePairs);
                    await AsyncStorage.setItem('session_index', JSON.stringify(currentIndex));

                    // REBUILD METADATA INDEX (INSTANT LOAD)
                    try {
                        const metaMap: any = {};
                        Object.keys(finalSessions).forEach(k => {
                            const s = finalSessions[k];
                            metaMap[k] = {
                                id: s.id, title: s.title, timestamp: s.timestamp,
                                toolId: s.toolId, lastOpened: s.lastOpened,
                                pinned: s.pinned, hasAudio: s.hasAudio,
                                language: s.language
                            };
                        });

                        // FIX: Don't set item here. It might be too large and fail silently or partial.
                        // Instead, we REMOVE it. This forces the app to "Crawl" and rebuild a perfect index on next load.
                        await AsyncStorage.removeItem('library_metadata_index');
                        console.log("Import Complete: Invalidated metadata index to force rebuild.");

                        // Update in-memory for current session only
                        // setChatSessions... (already done above)
                    } catch (e) { console.warn("Failed to update index", e); }
                }

                if (addedWordCount > 0) {
                    setRecentSearches(newDictionaryList);
                    await saveRecentSearchesToFile(newDictionaryList);
                }

                if (addedSessionCount > 0 || addedWordCount > 0 || addedAudioCount > 0) {
                    let msg = "Restore Complete.\n";
                    if (addedSessionCount > 0) msg += `â€¢ ${addedSessionCount} items restored`;
                    if (skippedSessionCount > 0) msg += ` (${skippedSessionCount} skipped)`;
                    if (addedWordCount > 0) msg += `\nâ€¢ ${addedWordCount} words restored`;
                    if (addedAudioCount > 0) msg += `\nâ€¢ ${addedAudioCount} audio files restored`;
                    Alert.alert("Restore Complete", msg);
                } else {
                    Alert.alert("Nothing Restored", "All items in backup already exist.");
                }
            }
        } catch (e) {
            console.error("Backup Import Error", e);
            Alert.alert("Error", "Could not restore backup.");
        }
    };

    // NEW: Handle Import Note from File System
    const handleImportNote = async () => {
        try {
            const result = await DocumentPicker.getDocumentAsync({
                type: ['text/plain', 'text/markdown', 'public.plain-text', 'public.text', 'application/json', 'public.json'], // Added JSON support
                copyToCacheDirectory: true,
                multiple: true // Enable multiple selection
            });

            if (!result.canceled && result.assets && result.assets.length > 0) {
                let importedCount = 0;
                let duplicateCount = 0;

                // Helper to check duplicates or find existing in trash
                const findExistingNote = (content: string): any => {
                    return Object.values(chatSessions).find((s: any) =>
                        s.toolId === 'quick_notes' && s.messages && s.messages[0] && s.messages[0].content === content
                    );
                };

                const newSessionsMap: any = {};
                const storagePairs: [string, string][] = [];
                const indexJson = await AsyncStorage.getItem('session_index');
                let currentIndex = indexJson ? JSON.parse(indexJson) : [];
                const CONTENT_SIZE_THRESHOLD = 5 * 1024; // 5KB

                for (const asset of result.assets) {
                    try {
                        let content = await fs.readAsStringAsync(asset.uri, { encoding: fs.EncodingType.UTF8 });

                        // LOGIC FOR JSON (BACKUP/BUNDLE OR SINGLE EXPORT OR UNIFIED)
                        if (content.trim().startsWith('[') || content.trim().startsWith('{')) {
                            try {
                                const jsonContent = JSON.parse(content);
                                let notesToProcess = [];

                                if (Array.isArray(jsonContent)) {
                                    notesToProcess = jsonContent;
                                } else if (jsonContent.type === 'reader_unified_export' && Array.isArray(jsonContent.items)) {
                                    // NEW: Handle Unified Export
                                    notesToProcess = jsonContent.items;
                                } else if (jsonContent.type === 'reader_single_export' || (jsonContent.content && jsonContent.images)) {
                                    // Single Smart Export
                                    notesToProcess = [jsonContent];
                                } else {
                                    // Treat as plain text if structure doesn't match known note types (unless it's a V2 backup handled elsewhere)
                                    if (!jsonContent.sessions) throw new Error("Not a note bundle");
                                }

                                if (notesToProcess.length > 0) {
                                    for (const note of notesToProcess) {
                                        // Adapt content field: Unified/Single uses 'content', sessions use 'messages'
                                        const noteContent = note.content || (note.messages && note.messages[0]?.content) || "";

                                        if (!noteContent && (!note.images || note.images.length === 0)) continue;

                                        // Check duplicate or existing in trash
                                        const existing: any = findExistingNote(noteContent);
                                        const alreadyInBatch = Object.values(newSessionsMap).some((s: any) => s.messages && s.messages[0] && s.messages[0].content === noteContent);

                                        if (existing || alreadyInBatch) {
                                            duplicateCount++;
                                            continue;
                                        }

                                        const id = generateId();
                                        let savedImages = [];

                                        // HYDRATE IMAGES (Convert Base64 to File)
                                        if (note.images && Array.isArray(note.images)) {
                                            const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                                            savedImages = await Promise.all(note.images.map(async (imgData: string) => {
                                                if (imgData && imgData.startsWith('data:')) {
                                                    const filename = `${generateId()}.jpg`;
                                                    const filepath = `${docDir}${filename}`;
                                                    const base64Data = imgData.split(',')[1];
                                                    await fs.writeAsStringAsync(filepath, base64Data, { encoding: 'base64' });
                                                    return filepath;
                                                }
                                                return null; // Skip if not base64 (invalid external path)
                                            }));
                                            savedImages = savedImages.filter(Boolean);
                                        }

                                        const sessionToSave = {
                                            id: id,
                                            timestamp: note.timestamp || new Date().toISOString(),
                                            messages: [{ role: "user", content: noteContent }],
                                            title: note.title || "Imported Note",
                                            toolId: 'quick_notes',
                                            images: savedImages,
                                            pinned: note.pinned || false,
                                            highlights: note.highlights || []
                                        };

                                        // Handle Large Content
                                        if (noteContent.length > CONTENT_SIZE_THRESHOLD) {
                                            const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                                            const filename = `content_${id}.txt`;
                                            const filePath = `${docDir}${filename}`;
                                            try {
                                                await fs.writeAsStringAsync(filePath, noteContent, { encoding: fs.EncodingType.UTF8 });
                                                (sessionToSave as any).contentPath = filePath;
                                                sessionToSave.messages[0].content = noteContent.substring(0, 200) + "... (Content saved to file)";
                                            } catch (e: any) { }
                                        }

                                        newSessionsMap[id] = sessionToSave;
                                        storagePairs.push([`session_${id}`, JSON.stringify(sessionToSave)]);
                                        if (!currentIndex.includes(id)) currentIndex.push(id);
                                        importedCount++;
                                    }
                                    continue; // Successfully processed as JSON
                                }
                            } catch (e: any) {
                                // If JSON parse fails, fall through to plain text
                            }
                        }

                        // LOGIC FOR PLAIN TEXT / SINGLE FILE
                        if (content) {
                            // EXTRACT METADATA
                            let restoredHighlights = [];
                            if (content.includes(METADATA_SEPARATOR)) {
                                const parts = content.split(METADATA_SEPARATOR);
                                content = parts.slice(0, -1).join(METADATA_SEPARATOR);
                                const metaString = parts[parts.length - 1];
                                try {
                                    const meta = JSON.parse(metaString);
                                    if (meta.highlights) restoredHighlights = meta.highlights;
                                } catch (e: any) { }
                            }

                            // DUPLICATE/RESTORE CHECK
                            const existing = findExistingNote(content);
                            const alreadyInBatch = Object.values(newSessionsMap).some((s: any) => s.messages[0].content === content);

                            if (existing) {
                                duplicateCount++;
                                continue;
                            }

                            if (alreadyInBatch) {
                                duplicateCount++;
                                continue;
                            }

                            const fileName = asset.name;
                            const title = fileName.lastIndexOf('.') !== -1
                                ? fileName.substring(0, fileName.lastIndexOf('.'))
                                : fileName;

                            const id = generateId();

                            let sessionToSave = {
                                id: id,
                                timestamp: new Date().toISOString(),
                                messages: [{ role: "user", content: content }],
                                title: title,
                                toolId: "quick_notes",
                                images: [],
                                pinned: false,
                                highlights: restoredHighlights
                            };

                            // Large Content Handling
                            if (content.length > CONTENT_SIZE_THRESHOLD) {
                                const docDir = fs.documentDirectory || FileSystem.documentDirectory;
                                const filename = `content_${id}.txt`;
                                const filePath = `${docDir}${filename}`;

                                try {
                                    await fs.writeAsStringAsync(filePath, content, { encoding: fs.EncodingType.UTF8 });
                                    (sessionToSave as any).contentPath = filePath;
                                    sessionToSave.messages[0].content = content.substring(0, 200) + "... (Content saved to file)";
                                } catch (err) {
                                    console.warn("Failed to save content file for batch import", err);
                                }
                            }

                            // Keep full content in memory state
                            newSessionsMap[id] = {
                                ...sessionToSave,
                                messages: [{ role: "user", content: content }]
                            };

                            storagePairs.push([`session_${id}`, JSON.stringify(sessionToSave)]);
                            if (!currentIndex.includes(id)) currentIndex.push(id);
                            importedCount++;
                        }
                    } catch (err) {
                        console.warn("Failed to import file: " + asset.name, err);
                    }
                }

                if (importedCount > 0) {
                    // 1. Batch State Update
                    const finalSessions = { ...chatSessions, ...newSessionsMap };
                    setChatSessions((prev: any) => ({ ...prev, ...newSessionsMap }));

                    // 2. Batch Storage Update
                    await AsyncStorage.multiSet(storagePairs);
                    if (importedCount > 0) {
                        await AsyncStorage.setItem('session_index', JSON.stringify(currentIndex));

                        // REBUILD METADATA INDEX (INSTANT LOAD)
                        try {
                            const metaMap: any = {};
                            Object.keys(finalSessions).forEach(k => {
                                const s = finalSessions[k];
                                metaMap[k] = {
                                    id: s.id, title: s.title, timestamp: s.timestamp,
                                    toolId: s.toolId, lastOpened: s.lastOpened,
                                    pinned: s.pinned, hasAudio: s.hasAudio,
                                    language: s.language
                                };
                            });
                            await AsyncStorage.setItem('library_metadata_index', JSON.stringify(metaMap));
                        } catch (e) { console.warn("Failed to rebuild index", e); }

                        // REBUILD METADATA INDEX (INSTANT LOAD)
                        try {
                            const metaMap: any = {};
                            Object.keys(finalSessions).forEach(k => {
                                const s = finalSessions[k];
                                metaMap[k] = {
                                    id: s.id, title: s.title, timestamp: s.timestamp,
                                    toolId: s.toolId, lastOpened: s.lastOpened,
                                    pinned: s.pinned, hasAudio: s.hasAudio,
                                    language: s.language
                                };
                            });
                            await AsyncStorage.setItem('library_metadata_index', JSON.stringify(metaMap));
                        } catch (e) { console.warn("Failed to rebuild index", e); }
                    }

                    // Wait slightly for state to settle
                    await new Promise(r => setTimeout(r, 200));

                    let msg = "";
                    if (importedCount > 0) msg += `Imported ${importedCount} notes.`;
                    if (duplicateCount > 0) msg += `\n(${duplicateCount} duplicates skipped)`;

                    Alert.alert("Import Complete", msg);
                } else if (duplicateCount > 0) {
                    Alert.alert("Import Skipped", "All selected content already exists in your notes (active or restored).");
                } else {
                    Alert.alert("Import Failed", "No valid notes could be imported.");
                }
            }
        } catch (e) {
            console.error("Import Note Error", e);
            Alert.alert("Error", "Could not import files.");
        } finally {
            setIsSaving(false);
        }
    };

    // NEW: Handle Import to Library (Journals)
    const handleImportLibraryItem = async () => {
        try {
            const result = await DocumentPicker.getDocumentAsync({
                type: ['text/plain', 'text/markdown', 'public.plain-text', 'public.text', 'application/json', 'public.json'],
                copyToCacheDirectory: true,
                multiple: true
            });

            if (!result.canceled && result.assets && result.assets.length > 0) {
                let importedCount = 0;
                let duplicateCount = 0;

                // NEW: Get current sessions map to check duplicates efficiently
                const existingSessionIds = new Set(Object.keys(chatSessions));
                const newSessionsMap: any = {};
                const storagePairs: [string, string][] = [];
                const indexJson = await AsyncStorage.getItem('session_index');
                let currentIndex = indexJson ? JSON.parse(indexJson) : [];
                const docDir = fs.documentDirectory || FileSystem.documentDirectory;

                for (const asset of result.assets) {
                    try {
                        let content = await fs.readAsStringAsync(asset.uri, { encoding: fs.EncodingType.UTF8 });
                        if (content) {
                            // 1. DETECT CONTENT TYPE (Backup/Bundle vs Quiz vs Text)
                            let isQuiz = false;
                            let isBundle = false;
                            let parsedData = null;

                            try {
                                const parsed = JSON.parse(content);

                                // Check for V2 Backup Object
                                if (parsed && parsed.type === "reader_backup_v2" && Array.isArray(parsed.sessions)) {
                                    isBundle = true;
                                    parsedData = parsed.sessions;
                                }
                                // Check for Unified Export
                                else if (parsed && parsed.type === "reader_unified_export" && Array.isArray(parsed.items)) {
                                    isBundle = true;
                                    parsedData = parsed.items;
                                }
                                // Check for Array Bundle (Legacy or Note Export) - Must check if items look like sessions
                                else if (Array.isArray(parsed) && parsed.length > 0) {
                                    // Heuristic: Does first item have 'id' and 'toolId'?
                                    if (parsed[0].id && parsed[0].toolId) {
                                        isBundle = true;
                                        parsedData = parsed;
                                    }
                                    // Heuristic: Does first item look like a Quiz Question?
                                    else if (parsed[0].question && parsed[0].options) {
                                        isQuiz = true;
                                        parsedData = parsed;
                                    }
                                }
                            } catch (e: any) {
                                // Not JSON, proceed as text
                            }

                            // 2. HANDLE BUNDLE RESTORE (Fixes "Notes in Library" issue)
                            if (isBundle && parsedData) {
                                for (const session of parsedData) {
                                    // Skip if ID exists (prevent overwrite in this mode)
                                    if (existingSessionIds.has(session.id) || newSessionsMap[session.id]) {
                                        duplicateCount++;
                                        continue;
                                    }

                                    // Validate it's a valid session object
                                    if (session.id && session.toolId) {
                                        // NEW: Auto-Increment Quiz Attempts for Bundles
                                        if (session.toolId === 'quiz_save' && quizHistoryRef.current[session.id]) {
                                            const h = quizHistoryRef.current[session.id];
                                            if (h.attempts >= (session.attempts || 0)) {
                                                session.attempts = h.attempts + 1;
                                                // Reset state
                                                session.completed = false;
                                                session.score = 0;
                                                session.currentIndex = 0;
                                                if (Array.isArray(session.quizData)) {
                                                    session.quizData = session.quizData.map((q: any) => ({
                                                        ...q,
                                                        selected: null,
                                                        markedForReview: false,
                                                        visited: false
                                                    }));
                                                }
                                            }
                                        }


                                        // Update timestamp for import visibility
                                        session.timestamp = new Date().toISOString();

                                        // Handle Large Content in bundles - save to file to avoid database filling up
                                        const CONTENT_SIZE_THRESHOLD = 2 * 1024 * 1024; // 2MB (for chapters with images)
                                        if (session.messages && session.messages[0] && session.messages[0].content) {
                                            const content = session.messages[0].content;
                                            if (content.length > CONTENT_SIZE_THRESHOLD && !session.contentPath) {
                                                const filename = `content_${session.id}.txt`;
                                                const filePath = `${docDir}${filename}`;
                                                try {
                                                    await fs.writeAsStringAsync(filePath, content, { encoding: fs.EncodingType.UTF8 });
                                                    session.contentPath = filePath;
                                                    session.messages[0].content = content.substring(0, 200) + "... (Content saved to file)";
                                                } catch (e: any) {
                                                    console.error('Failed to save large bundle content to file:', e);
                                                }
                                            }
                                        }

                                        // Handle images - save base64 images to files
                                        if (session.image && session.image.startsWith('data:image')) {
                                            try {
                                                const base64Data = session.image.split(',')[1];
                                                const imageFilePath = `${docDir}image_${session.id}.jpg`;
                                                await fs.writeAsStringAsync(imageFilePath, base64Data, { encoding: 'base64' });
                                                session.image = imageFilePath; // Replace base64 with file path
                                            } catch (e: any) {
                                                console.error('Failed to save session.image to file:', e);
                                            }
                                        }

                                        // Handle images array - save each base64 image to file
                                        if (session.images && Array.isArray(session.images)) {
                                            const savedImagePaths: string[] = [];
                                            for (let imgIdx = 0; imgIdx < session.images.length; imgIdx++) {
                                                const imgUri = session.images[imgIdx];
                                                if (imgUri && imgUri.startsWith('data:image')) {
                                                    try {
                                                        const base64Data = imgUri.split(',')[1];
                                                        const imageFilePath = `${docDir}image_${session.id}_${imgIdx}.jpg`;
                                                        await fs.writeAsStringAsync(imageFilePath, base64Data, { encoding: 'base64' });
                                                        savedImagePaths.push(imageFilePath);
                                                    } catch (e: any) {
                                                        console.error(`Failed to save session.images[${imgIdx}] to file:`, e);
                                                        savedImagePaths.push(imgUri); // Keep original if save fails
                                                    }
                                                } else {
                                                    savedImagePaths.push(imgUri); // Keep non-base64 URIs as-is
                                                }
                                            }
                                            session.images = savedImagePaths;
                                        }

                                        // Remove translations field to save space
                                        if (session.translations) {
                                            delete session.translations;
                                        }

                                        // Debug: Log session size before adding to batch
                                        const sessionJson = JSON.stringify(session);
                                        const sessionSize = sessionJson.length;
                                        if (sessionSize > 1024 * 1024) { // Log if >1MB
                                            console.warn(`Large session detected: ${session.id}, size: ${(sessionSize / 1024 / 1024).toFixed(2)}MB`);
                                        }

                                        // Add to batch - this preserves the original toolId (e.g. 'quick_notes')
                                        newSessionsMap[session.id] = session;
                                        storagePairs.push([`session_${session.id}`, sessionJson]);
                                        if (!currentIndex.includes(session.id)) currentIndex.push(session.id);
                                        importedCount++;
                                    }
                                }
                                continue; // Skip the rest of loop for this file
                            }

                            // 3. HANDLE QUIZ RESTORE

                            const fileName = asset.name;
                            const title = fileName.lastIndexOf('.') !== -1
                                ? fileName.substring(0, fileName.lastIndexOf('.'))
                                : fileName;

                            let newSession;

                            if (isQuiz && parsedData) {
                                // Check for duplicate quiz data structure
                                const importedJson = JSON.stringify(parsedData);
                                const isDuplicate = (Object.values(chatSessions) as any[]).some((s: any) =>
                                    s.toolId === 'quiz_save' &&
                                    s.quizData &&
                                    JSON.stringify(s.quizData) === importedJson
                                );

                                if (isDuplicate) {
                                    duplicateCount++;
                                    continue;
                                }

                                // RECONSTRUCT QUIZ SESSION
                                const quizId = generateId();
                                // Note: Reconstructed quizzes get a NEW ID, so history tracking via ID won't apply here.
                                // History tracking works best for "Single Object Session" or "Unified Export" imports where ID is preserved.
                                // If re-importing raw array data, it's treated as a new quiz.

                                newSession = {
                                    id: quizId,
                                    timestamp: new Date().toISOString(),
                                    messages: [{ role: "ai", content: "Interactive Quiz Started" }],
                                    title: title,
                                    toolId: 'quiz_save',
                                    quizData: parsedData,
                                    score: 0,
                                    totalQuestions: parsedData.length,
                                    completed: false,
                                    translations: { [displaySettings.language]: parsedData },
                                    language: displaySettings.language
                                };
                            } else {
                                // STANDARD DOCUMENT IMPORT (Fallback for Text Files or unknown JSON)

                                // Check duplicates by content matching
                                // Check duplicates by content matching
                                const duplicateSession = (Object.values(chatSessions) as any[]).find((s: any) =>
                                    s.toolId !== 'quick_notes' &&
                                    s.toolId !== 'quiz_save' &&
                                    s.messages && s.messages[0] && s.messages[0].content === content
                                );

                                if (duplicateSession) {
                                    // BUMP TIMESTAMP of existing session
                                    const dupId = duplicateSession.id;
                                    const updatedSession = { ...duplicateSession, timestamp: new Date().toISOString() };

                                    newSessionsMap[dupId] = updatedSession;
                                    storagePairs.push([`session_${dupId}`, JSON.stringify(updatedSession)]);

                                    // Ensure it's in index if missing (unlikely if found in sessions)
                                    if (!currentIndex.includes(dupId)) currentIndex.push(dupId);

                                    importedCount++; // Count as import so we show success
                                    continue;
                                }

                                // EXTRACT METADATA for Plain Text Files
                                let restoredHighlights = [];
                                if (!content.trim().startsWith('{') && !content.trim().startsWith('[')) {
                                    if (content.includes(METADATA_SEPARATOR)) {
                                        const parts = content.split(METADATA_SEPARATOR);
                                        content = parts.slice(0, -1).join(METADATA_SEPARATOR);
                                        const metaString = parts[parts.length - 1];
                                        try {
                                            const meta = JSON.parse(metaString);
                                            if (meta.highlights) restoredHighlights = meta.highlights;
                                        } catch (e: any) { }
                                    }
                                }

                                // Use 'writer' toolId so it appears in "Journals" tab
                                const docId = generateId();
                                const CONTENT_SIZE_THRESHOLD = 2 * 1024 * 1024; // 2MB (for chapters with images)

                                newSession = {
                                    id: docId,
                                    timestamp: new Date().toISOString(),
                                    lastOpened: new Date().toISOString(),
                                    messages: [{ role: "ai", content: content }],
                                    title: title,
                                    toolId: "writer",
                                    language: displaySettings.language,
                                    highlights: restoredHighlights
                                } as any;

                                // Handle Large Content - save to file to avoid database filling up
                                if (content.length > CONTENT_SIZE_THRESHOLD) {
                                    const filename = `content_${docId}.txt`;
                                    const filePath = `${docDir}${filename}`;
                                    try {
                                        await fs.writeAsStringAsync(filePath, content, { encoding: fs.EncodingType.UTF8 });
                                        newSession.contentPath = filePath;
                                        newSession.messages[0].content = content.substring(0, 200) + "... (Content saved to file)";
                                    } catch (e: any) {
                                        console.error('Failed to save large content to file:', e);
                                    }
                                }

                                // Load content from file if contentPath is set (for unified exports)
                                if (newSession.contentPath) {
                                    try {
                                        const fileContent = await fs.readAsStringAsync(newSession.contentPath, { encoding: fs.EncodingType.UTF8 });
                                        if (newSession.messages && newSession.messages[0]) {
                                            newSession.messages[0].content = fileContent;
                                        }
                                    } catch (e: any) {
                                        console.error('Failed to load content from file:', e);
                                    }
                                }

                                // Load images from files if they are file paths (for unified exports)
                                if (newSession.image && !newSession.image.startsWith('data:') && !newSession.image.startsWith('http')) {
                                    try {
                                        const base64Data = await fs.readAsStringAsync(newSession.image, { encoding: 'base64' });
                                        newSession.image = `data:image/jpeg;base64,${base64Data}`;
                                    } catch (e: any) {
                                        console.error('Failed to load session.image from file:', e);
                                    }
                                }

                                if (newSession.images && Array.isArray(newSession.images)) {
                                    const loadedImages: string[] = [];
                                    for (const imgPath of newSession.images) {
                                        if (imgPath && !imgPath.startsWith('data:') && !imgPath.startsWith('http')) {
                                            try {
                                                const base64Data = await fs.readAsStringAsync(imgPath, { encoding: 'base64' });
                                                loadedImages.push(`data:image/jpeg;base64,${base64Data}`);
                                            } catch (e: any) {
                                                console.error('Failed to load image from file:', e);
                                                loadedImages.push(imgPath); // Keep original if load fails
                                            }
                                        } else {
                                            loadedImages.push(imgPath); // Keep data URIs and URLs as-is
                                        }
                                    }
                                    newSession.images = loadedImages;
                                }

                                // Handle images - check if content contains base64 images and extract them
                                const imageRegex = /<img[^>]+src="(data:image\/[^"]+)"/g;
                                const matches = [...content.matchAll(imageRegex)];
                                if (matches.length > 0) {
                                    const savedImagePaths: string[] = [];
                                    for (let imgIdx = 0; imgIdx < matches.length; imgIdx++) {
                                        const base64Uri = matches[imgIdx][1];
                                        try {
                                            const base64Data = base64Uri.split(',')[1];
                                            const imageFilePath = `${docDir}image_${docId}_${imgIdx}.jpg`;
                                            await fs.writeAsStringAsync(imageFilePath, base64Data, { encoding: 'base64' });
                                            savedImagePaths.push(imageFilePath);
                                        } catch (e: any) {
                                            console.error(`Failed to save embedded image ${imgIdx} to file:`, e);
                                        }
                                    }
                                    if (savedImagePaths.length > 0) {
                                        newSession.images = savedImagePaths;
                                    }
                                }
                            }

                            if (newSession) {
                                newSessionsMap[newSession.id] = newSession;
                                storagePairs.push([`session_${newSession.id}`, JSON.stringify(newSession)]);
                                if (!currentIndex.includes(newSession.id)) currentIndex.push(newSession.id);
                                importedCount++;
                            }
                        }
                    } catch (err) {
                        console.warn("Failed to import file: " + asset.name, err);
                    }
                }

                if (importedCount > 0) {
                    // Update state if we have new sessions
                    if (Object.keys(newSessionsMap).length > 0) {
                        setChatSessions((prev: any) => ({ ...prev, ...newSessionsMap }));
                    }

                    // FIX: Split into chunks to avoid AsyncStorage size limits
                    if (storagePairs.length > 0) {
                        const CHUNK_SIZE = 50;
                        for (let i = 0; i < storagePairs.length; i += CHUNK_SIZE) {
                            const chunk = storagePairs.slice(i, i + CHUNK_SIZE);
                            try {
                                await AsyncStorage.multiSet(chunk as any);
                                console.log(`Saved chunk ${Math.floor(i / CHUNK_SIZE) + 1}/${Math.ceil(storagePairs.length / CHUNK_SIZE)}`);
                            } catch (chunkError) {
                                console.error(`Failed to save chunk ${Math.floor(i / CHUNK_SIZE) + 1}:`, chunkError);
                                // Continue with next chunk even if this one fails
                            }
                        }
                        await AsyncStorage.setItem('session_index', JSON.stringify(currentIndex));
                    }

                    // Reload Audio if needed
                    if (activeTab === 'library' && libraryTab === 'audio') {
                        loadAudioFiles();
                    }

                    let msg = `Successfully imported ${importedCount} items.`;
                    if (duplicateCount > 0) msg += `\n(${duplicateCount} duplicates skipped)`;
                    Alert.alert("Import Complete", msg);
                } else if (duplicateCount > 0) {
                    Alert.alert("Import Skipped", "All selected content already exists in your library.");
                } else {
                    Alert.alert("Import Failed", "No valid files could be imported.");
                }
            }
        } catch (e) {
            console.error("Import Library Error", e);
            Alert.alert("Error", "Could not import files.");
        }
    };

    // NEW: Handle Batch Export for Library
    const handleLibraryBatchExport = async () => {
        if (selectedLibraryIds.length === 0) return;

        // UPDATED: Audio Batch Export Support with Deep Search
        if (libraryTab === 'audio') {
            if (Platform.OS === 'android') {
                try {
                    // 1. Collect all files to export
                    const itemsToExport: any[] = []; // Array of objects { name, uri?, parts? }

                    // Helper to recursively find and collect files
                    const processAudioItem = (item: any) => {
                        // NEW: Recursively handle Book Groups
                        if (item.isBook && item.chapters) {
                            item.chapters.forEach((c: any) => processAudioItem(c));
                            return;
                        }

                        let niceName = item.matchedTitle || "Audio";
                        niceName = niceName.replace(/:/g, ' - ').replace(/[^a-zA-Z0-9 \-_]/g, '').trim().substring(0, 60);
                        if (!niceName) niceName = "Audio";

                        if (item.isGroup && item.files.length > 1) {
                            // Needs merging
                            itemsToExport.push({
                                name: `${niceName}.wav`,
                                parts: item.files.map((f: any) => f.uri)
                            });
                        } else {
                            // Single file (Orphan or Group with 1 file)
                            let uri = null;
                            if (item.isGroup && item.files.length > 0) uri = item.files[0].uri;
                            else if (item.uri) uri = item.uri;

                            if (uri) {
                                itemsToExport.push({
                                    name: `${niceName}.wav`,
                                    uri: uri
                                });
                            }
                        }
                    };

                    for (const id of selectedLibraryIds) {
                        // Find item at top level OR nested in books
                        let item = audioFiles.find((f: any) => f.id === id);

                        if (item) {
                            // Found at top level (could be File, Group, or Book)
                            processAudioItem(item);
                        } else {
                            // Not at top level, search inside Books for individual chapter selection
                            for (const top of audioFiles) {
                                if (top.isBook && top.chapters) {
                                    const found = top.chapters.find((c: any) => c.id === id);
                                    if (found) {
                                        processAudioItem(found);
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if (itemsToExport.length === 0) return;

                    showToast(`Preparing ${itemsToExport.length} audio files...`);
                    // Yield for toast
                    await new Promise(r => setTimeout(r, 100));

                    // 2. Get Directory Permission
                    const savedDir = await AsyncStorage.getItem('savedExportDirectory');
                    let targetDir = savedDir;

                    const verifyDir = async (uri: string) => {
                        try {
                            const testUri = await fs.StorageAccessFramework.createFileAsync(uri, "test_perm_check", "text/plain");
                            await fs.deleteAsync(testUri);
                            return true;
                        } catch (e: any) { return false; }
                    };

                    let hasPermission = false;
                    if (targetDir) {
                        hasPermission = await verifyDir(targetDir);
                    }

                    if (!hasPermission) {
                        const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                        if (permissions.granted) {
                            targetDir = permissions.directoryUri;
                            await AsyncStorage.setItem('savedExportDirectory', targetDir);
                            hasPermission = true;
                        }
                    }

                    if (!hasPermission) {
                        Alert.alert("Permission Denied", "Cannot save files without folder access.");
                        return;
                    }
                    if (!targetDir) return;

                    // 3. Save Loop
                    let successCount = 0;
                    const total = itemsToExport.length;

                    // NEW: Track used names in this batch to prevent OS file extension corruption (e.g. file.wav(1))
                    const usedNames = new Set();

                    for (let i = 0; i < total; i++) {
                        const exportItem = itemsToExport[i];
                        try {
                            let base64ToWrite = null;

                            if (exportItem.parts) {
                                // MERGE LOGIC
                                const parts = [];
                                let totalLength = 0;
                                let firstHeader = null;

                                for (let j = 0; j < exportItem.parts.length; j++) {
                                    const fUri = exportItem.parts[j];
                                    const b64 = await fs.readAsStringAsync(fUri, { encoding: fs.EncodingType.Base64 });
                                    const bytes = decodeBase64(b64);
                                    if (bytes.length < 44) continue;

                                    if (j === 0) {
                                        firstHeader = bytes.slice(0, 44);
                                        const data = bytes.slice(44);
                                        parts.push(data);
                                        totalLength += data.length;
                                    } else {
                                        const data = bytes.slice(44);
                                        parts.push(data);
                                        totalLength += data.length;
                                    }
                                }

                                if (parts.length > 0 && firstHeader) {
                                    const mergedBuffer = new Uint8Array(44 + totalLength);
                                    mergedBuffer.set(firstHeader, 0);

                                    let offset = 44;
                                    for (const part of parts) {
                                        mergedBuffer.set(part, offset);
                                        offset += part.length;
                                    }

                                    const view = new DataView(mergedBuffer.buffer);
                                    view.setUint32(4, 36 + totalLength, true);
                                    view.setUint32(40, totalLength, true);

                                    base64ToWrite = encodeBase64(mergedBuffer);
                                }
                            } else {
                                // Single File
                                base64ToWrite = await fs.readAsStringAsync(exportItem.uri, { encoding: fs.EncodingType.Base64 });
                            }

                            if (base64ToWrite) {
                                // NEW: Ensure filename uniqueness
                                let finalName = exportItem.name;
                                const baseName = finalName.replace(/\.wav$/i, '');
                                let counter = 1;

                                // If name exists in this batch, append counter
                                while (usedNames.has(finalName)) {
                                    finalName = `${baseName}_${counter}.wav`;
                                    counter++;
                                }
                                usedNames.add(finalName);

                                const newFileUri = await fs.StorageAccessFramework.createFileAsync(targetDir, finalName, 'audio/wav');
                                await fs.writeAsStringAsync(newFileUri, base64ToWrite, { encoding: fs.EncodingType.Base64 });
                                successCount++;
                                if (i % 3 === 0) showToast(`Saved ${i + 1} of ${total}...`);

                                // Clean up memory
                                base64ToWrite = null;
                            }
                        } catch (e: any) {
                            console.log(`Failed to save ${exportItem.name}`, e);
                        }
                    }

                    if (successCount > 0) {
                        setIsLibrarySelectionMode(false);
                        setSelectedLibraryIds([]);
                        Alert.alert("Export Complete", `Successfully saved ${successCount} audio files.`);
                    } else {
                        Alert.alert("Export Failed", "Could not save files.");
                    }

                } catch (e: any) {
                    console.error("Audio Batch Export Error", e);
                    Alert.alert("Error", "Batch export failed.");
                }
                return;
            } else {
                // iOS Fallback -> Reuse Share Logic (Loops Share Sheet)
                handleLibraryBatchShare();
                return;
            }
        }

        if (Platform.OS === 'android') {
            try {
                // Prepare the Bundle
                showToast(`Preparing ${selectedLibraryIds.length} items...`);
                await new Promise(r => setTimeout(r, 100));

                const selectedSessions = [];

                for (const id of selectedLibraryIds) {
                    const session = chatSessions[id];
                    if (session) {
                        // Push to selectedSessions directly, content resolution happens in createShareBundle
                        selectedSessions.push(session);
                    }
                }

                if (selectedSessions.length === 0) return;

                // Use Unified Bundle
                const bundle = await createShareBundle(selectedSessions, 'journals');
                const content = JSON.stringify(bundle, null, 2);

                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `Library_Export_${timestamp}.json`;

                // Check for saved directory
                const savedDir = await AsyncStorage.getItem('savedExportDirectory');

                const saveFile = async (uri: string) => {
                    try {
                        const newFileUri = await fs.StorageAccessFramework.createFileAsync(uri, filename, 'application/json');
                        await fs.writeAsStringAsync(newFileUri, content, { encoding: fs.EncodingType.UTF8 });
                        return true;
                    } catch (e: any) {
                        return false;
                    }
                };

                let success = false;
                if (savedDir) {
                    success = await saveFile(savedDir);
                }

                if (!success) {
                    try {
                        const permissions = await fs.StorageAccessFramework.requestDirectoryPermissionsAsync();
                        if (permissions.granted) {
                            await AsyncStorage.setItem('savedExportDirectory', permissions.directoryUri);
                            success = await saveFile(permissions.directoryUri);
                        }
                    } catch (e: any) { }
                }

                if (success) {
                    setIsLibrarySelectionMode(false);
                    setSelectedLibraryIds([]);
                    Alert.alert("Export Complete", `Saved ${selectedSessions.length} items to a single file.`);
                } else {
                    Alert.alert("Export Failed", "Could not save the file.");
                }

            } catch (e) {
                Alert.alert("Error", "Batch export failed.");
            }
        } else {
            // iOS Fallback
            handleLibraryBatchShare();
        }
    };

    // NEW: Handle Batch Share for Library (Social Media / Direct Share)
    const handleLibraryBatchShare = async () => {
        if (selectedLibraryIds.length === 0) return;

        // Audio Tab sharing logic (Keep loop as merging binary is complex)
        if (libraryTab === 'audio') {
            // ... (Audio share logic remains same as it handles binary files separately) ...
            try {
                let filesToShare: string[] = [];

                // Helper to collect URIs recursively
                const collectUris = (item: any) => {
                    if (item.uri) {
                        filesToShare.push(item.uri);
                    } else if (item.files) {
                        item.files.forEach((f: any) => filesToShare.push(f.uri));
                    } else if (item.chapters) {
                        item.chapters.forEach((c: any) => collectUris(c));
                    }
                };

                for (const id of selectedLibraryIds) {
                    // Search top level
                    let item = audioFiles.find(f => f.id === id);

                    // If not found, search inside books
                    if (!item) {
                        for (const top of audioFiles) {
                            if (top.isBook && top.chapters) {
                                const found = top.chapters.find((c: any) => c.id === id);
                                if (found) {
                                    item = found;
                                    break;
                                }
                            }
                        }
                    }

                    if (item) {
                        collectUris(item);
                    }
                }

                if (filesToShare.length === 0) return;

                // Remove duplicates just in case
                filesToShare = [...new Set(filesToShare)];

                if (filesToShare.length === 1) {
                    await Sharing.shareAsync(filesToShare[0]);
                } else {
                    Alert.alert("Share Multiple", `Sharing ${filesToShare.length} audio files will open multiple dialogs. Continue?`, [
                        { text: "Cancel", style: "cancel" },
                        {
                            text: "Share All", onPress: async () => {
                                for (const uri of filesToShare) {
                                    await Sharing.shareAsync(uri);
                                    // Small delay to prevent OS overload
                                    await new Promise(r => setTimeout(r, 800));
                                }
                            }
                        }
                    ]);
                }
                setIsLibrarySelectionMode(false);
                setSelectedLibraryIds([]);
            } catch (e) {
                Alert.alert("Error", "Could not share audio.");
            }
            return;
        }

        // Text Content Sharing (Notes/Journals/Quizzes) -> Share as Unified JSON Array

        try {
            const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
            const selectedSessions = [];
            showToast("Preparing bundle...");
            await new Promise(r => setTimeout(r, 100));

            for (const id of selectedLibraryIds) {
                const session = chatSessions[id];
                if (session) {
                    selectedSessions.push(session);
                }
            }

            if (selectedSessions.length === 0) {
                Alert.alert("Empty", "No content to share.");
                return;
            }

            // Create Unified Bundle
            const bundle = await createShareBundle(selectedSessions, 'journals');
            const content = JSON.stringify(bundle, null, 2);

            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `Library_Bundle_${timestamp}.json`;
            const fileUri = cacheDir + filename;

            await FileSystem.writeAsStringAsync(fileUri, content);
            await Sharing.shareAsync(fileUri);

            setIsLibrarySelectionMode(false);
            setSelectedLibraryIds([]);
        } catch (e) {
            console.error("Batch Share Error", e);
            Alert.alert("Error", "Could not share items.");
        }
    };

    // NEW: Handle Batch Restore


    const handleEditNote = (session: any) => {
        // UPDATED: Only overwrite if it's already a note. Otherwise create a copy.
        // This prevents editing a Story/Article from deleting the original source file.
        if (session.toolId === 'quick_notes') {
            setCurrentNoteId(session.id);
        } else {
            setCurrentNoteId(null); // Force new ID creation on save
        }

        setCurrentNoteTitle(session.title);
        setCurrentNoteInput(session.messages[0].content);

        // Initialize History with current content
        resetHistory(session.messages[0].content);

        if (session.images && Array.isArray(session.images)) {
            setCurrentNoteImages(session.images);
        } else if (session.image) {
            setCurrentNoteImages([session.image]);
        } else {
            setCurrentNoteImages([]);
        }

        setIsEditingNote(true);
    };

    // NEW: Notes Selection Handlers
    const handleNoteLongPress = (id: string) => {
        if (!isSelectionMode) {
            setIsSelectionMode(true);
            setSelectedNoteIds([id]);
        } else {
            // Toggle selection
            const newIds = selectedNoteIds.includes(id)
                ? selectedNoteIds.filter(i => i !== id)
                : [...selectedNoteIds, id];
            setSelectedNoteIds(newIds);
            if (newIds.length === 0) setIsSelectionMode(false);
        }
    };

    const handleNotePressInList = (session: any) => {
        if (isSelectionMode) {
            const id = session.id;
            const newIds = selectedNoteIds.includes(id)
                ? selectedNoteIds.filter(i => i !== id)
                : [...selectedNoteIds, id];
            setSelectedNoteIds(newIds);
            if (newIds.length === 0) setIsSelectionMode(false);
        } else {
            loadHistorySession(session);
        }
    };

    // NEW: Library Selection Handlers
    const handleLibraryLongPress = (id: string) => {
        if (!isLibrarySelectionMode) {
            setIsLibrarySelectionMode(true);
            setSelectedLibraryIds([id]);
        } else {
            const newIds = selectedLibraryIds.includes(id)
                ? selectedLibraryIds.filter(i => i !== id)
                : [...selectedLibraryIds, id];
            setSelectedLibraryIds(newIds);
            if (newIds.length === 0) setIsLibrarySelectionMode(false);
        }
    };

    // NEW: Handle Group Selection for Stories (Select All Chapters in Book)
    const handleGroupSelection = (chapterIds: string[]) => {
        const allSelected = chapterIds.every(id => selectedLibraryIds.includes(id));
        let newIds;

        if (allSelected) {
            // Deselect all chapters of this group
            newIds = selectedLibraryIds.filter(id => !chapterIds.includes(id));
        } else {
            // Select all (merge unique)
            newIds = [...new Set([...selectedLibraryIds, ...chapterIds])];
        }

        setSelectedLibraryIds(newIds);
        if (newIds.length === 0) setIsLibrarySelectionMode(false);
    };

    const handleToggleSelectAllNotes = () => {
        if (selectedNoteIds.length === filteredNotes.length && filteredNotes.length > 0) {
            setSelectedNoteIds([]); // Deselect all
        } else {
            setSelectedNoteIds(filteredNotes.map(n => n.id)); // Select all
        }
    };

    const handleToggleSelectAllLibrary = () => {
        const allTargetIds: string[] = [];

        filteredLibraryItems.forEach(item => {
            if (item.isGroup) {
                // Groups can have children in 'items' (chats) or 'chapters' (stories)
                const children = item.chapters || item.items || [];
                children.forEach((child: any) => allTargetIds.push(child.id));
                // FIX: Do NOT add item.id (the group virtual ID) to avoid count inflation
            } else {
                allTargetIds.push(item.id);
            }
        });

        // Check if all *target* items are selected
        const allSelected = allTargetIds.length > 0 && allTargetIds.every(id => selectedLibraryIds.includes(id));

        if (allSelected) {
            setSelectedLibraryIds([]);
        } else {
            // Select all visible items and their children
            setSelectedLibraryIds(allTargetIds);
        }
    };

    const handleLibraryPress = (session: any) => {
        if (!session) return;
        if (isLibrarySelectionMode) {
            const id = session.id;
            const newIds = selectedLibraryIds.includes(id)
                ? selectedLibraryIds.filter(i => i !== id)
                : [...selectedLibraryIds, id];
            setSelectedLibraryIds(newIds);
            if (newIds.length === 0) setIsLibrarySelectionMode(false);
        } else {
            loadHistorySession(session);
        }
    };

    // NEW: Handle Batch Pin for Notes (FIXED: Missing Function Added)
    const handleBatchPin = async () => {
        if (selectedNoteIds.length === 0) return;

        const newSessions = { ...chatSessions };
        const selectedSessions = selectedNoteIds.map(id => newSessions[id]).filter(Boolean);

        // Toggle logic: If ALL selected are pinned, then unpin. Otherwise pin all.
        const allPinned = selectedSessions.every(s => s.pinned);
        const newStatus = !allPinned;

        const updates: [string, string][] = [];
        selectedNoteIds.forEach(id => {
            if (newSessions[id]) {
                newSessions[id] = { ...newSessions[id], pinned: newStatus };
                updates.push([`session_${id}`, JSON.stringify(newSessions[id])]);
            }
        });

        setChatSessions(newSessions);
        await AsyncStorage.multiSet(updates);
        setIsSelectionMode(false);
        setSelectedNoteIds([]);
        showToast(newStatus ? "Notes Pinned" : "Notes Unpinned");
    };



    const handleLibraryBatchPin = async () => {
        if (selectedLibraryIds.length === 0) return;

        if (libraryTab === 'audio') {
            // Audio Mode Pinning logic
            const sessionIdsToPin: string[] = [];

            // Map selected ids to session IDs
            selectedLibraryIds.forEach(id => {
                // Deep Search for Item
                let item = audioFiles.find(f => f.id === id);
                if (!item) {
                    for (const top of audioFiles) {
                        if (top.isBook && top.chapters) {
                            const found = top.chapters.find((c: any) => c.id === id);
                            if (found) {
                                item = found;
                                break;
                            }
                        }
                    }
                }

                // Extract Session IDs
                if (item) {
                    const collectSessionIds = (obj: any) => {
                        if (obj.sessionId) sessionIdsToPin.push(obj.sessionId);
                        if (obj.files) obj.files.forEach((f: any) => { if (f.sessionId) sessionIdsToPin.push(f.sessionId); });
                        if (obj.chapters) obj.chapters.forEach((c: any) => collectSessionIds(c));
                    };
                    collectSessionIds(item);
                }
            });

            if (sessionIdsToPin.length === 0) {
                showToast("Cannot pin unknown recordings");
                setIsLibrarySelectionMode(false);
                setSelectedLibraryIds([]);
                return;
            }

            const newSessions = { ...chatSessions };
            const updates: [string, string][] = [];

            // Determine new status based on first item
            const firstSession = newSessions[sessionIdsToPin[0]];
            // Safety check if session still exists
            if (!firstSession) return;

            const newStatus = !firstSession.pinned;

            sessionIdsToPin.forEach(sid => {
                if (newSessions[sid]) {
                    newSessions[sid] = { ...newSessions[sid], pinned: newStatus };
                    updates.push([`session_${sid}`, JSON.stringify(newSessions[sid])]);
                }
            });

            setChatSessions(newSessions);
            await AsyncStorage.multiSet(updates);
            setIsLibrarySelectionMode(false);
            setSelectedLibraryIds([]);
            showToast(newStatus ? "Audio Sessions Pinned" : "Audio Sessions Unpinned");
            return;
        }

        const newSessions = { ...chatSessions };
        const selectedSessions = selectedLibraryIds.map(id => newSessions[id]).filter(Boolean);
        const allPinned = selectedSessions.every(s => s.pinned);
        const newStatus = !allPinned;

        const updates: [string, string][] = [];
        selectedLibraryIds.forEach(id => {
            if (newSessions[id]) {
                newSessions[id] = { ...newSessions[id], pinned: newStatus };
                updates.push([`session_${id}`, JSON.stringify(newSessions[id])]);
            }
        });

        setChatSessions(newSessions);
        await AsyncStorage.multiSet(updates);
        setIsLibrarySelectionMode(false);
        setSelectedLibraryIds([]);
        showToast(newStatus ? "Items Pinned" : "Items Unpinned");
    };




    const handleLibraryBatchDelete = () => {
        if (selectedLibraryIds.length === 0) return;

        // CASE 2: DELETE AUDIO FILES (Audio Tab) - Keep existing logic
        if (libraryTab === 'audio') {
            Alert.alert(
                "Delete Audio Files",
                `Permanently delete selected items?`,
                [
                    { text: "Cancel", style: "cancel" },
                    {
                        text: "Delete",
                        style: 'destructive',
                        onPress: async () => {
                            const idsToDelete = [...selectedLibraryIds];
                            const filesToDelete: string[] = [];

                            // Resolve IDs to file paths recursively
                            for (const id of idsToDelete) {
                                let item = audioFiles.find(f => f.id === id);
                                if (!item) {
                                    for (const top of audioFiles) {
                                        if (top.isBook && top.chapters) {
                                            const found = top.chapters.find((c: any) => c.id === id);
                                            if (found) {
                                                item = found;
                                                break;
                                            }
                                        }
                                    }
                                }

                                if (item) {
                                    const collectUris = (obj: any) => {
                                        if (obj.uri) filesToDelete.push(obj.uri);
                                        if (obj.files) obj.files.forEach((f: any) => filesToDelete.push(f.uri));
                                        if (obj.chapters) obj.chapters.forEach((c: any) => collectUris(c));
                                    };
                                    collectUris(item);
                                }
                            }

                            // Perform deletion
                            for (const uri of filesToDelete) {
                                try {
                                    await fs.deleteAsync(uri);
                                } catch (e: any) {
                                    console.log("Delete error", e);
                                }
                            }

                            // Update list locally
                            loadAudioFiles();

                            setIsLibrarySelectionMode(false);
                            setSelectedLibraryIds([]);
                            showToast("Files Deleted");
                        }
                    }
                ]
            );
            return;
        }

        // DEFAULT: PERMANENT DELETE
        Alert.alert(
            "Delete Items",
            `Permanently delete ${selectedLibraryIds.length} items? This cannot be undone.`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: 'destructive',
                    onPress: async () => {
                        const newSessions = { ...chatSessions };
                        const idsToDelete = [...selectedLibraryIds];

                        // 1. Remove from State
                        idsToDelete.forEach(id => delete newSessions[id]);
                        setChatSessions(newSessions);

                        // 2. Remove from Storage
                        const keysToRemove = idsToDelete.map(id => `session_${id}`);
                        await AsyncStorage.multiRemove(keysToRemove);

                        // 3. Update Index
                        const indexJson = await AsyncStorage.getItem('session_index');
                        if (indexJson) {
                            let index = JSON.parse(indexJson);
                            index = index.filter((id: string) => !idsToDelete.includes(id));
                            await AsyncStorage.setItem('session_index', JSON.stringify(index));
                        }

                        // 4. Update Metadata Index (Sync with Deletion)
                        try {
                            const metaJson = await AsyncStorage.getItem('library_metadata_index');
                            if (metaJson) {
                                let metaMap = JSON.parse(metaJson);
                                idsToDelete.forEach(id => delete metaMap[id]);
                                await AsyncStorage.setItem('library_metadata_index', JSON.stringify(metaMap));
                            }
                        } catch (e) {
                            console.log("Failed to sync metadata index delete", e);
                        }

                        // 5. Custom Audio Cleanup for Library Items
                        const newAudioUris = { ...customAudioUris };
                        let audioUpdated = false;
                        idsToDelete.forEach(id => {
                            if (newAudioUris[id]) {
                                try { FileSystem.deleteAsync(newAudioUris[id], { idempotent: true }); } catch (e) { }
                                delete newAudioUris[id];
                                audioUpdated = true;
                            }
                        });
                        if (audioUpdated) {
                            if (setCustomAudioUris) setCustomAudioUris(newAudioUris);
                            await AsyncStorage.setItem('customAudioUris', JSON.stringify(newAudioUris));
                        }

                        setIsLibrarySelectionMode(false);
                        setSelectedLibraryIds([]);
                        showToast(`Deleted ${idsToDelete.length} items`);
                    }
                }
            ]
        );
    };

    useEffect(() => {
        const backAction = () => {
            if (showWordModal) { setShowWordModal(false); return true; }
            if (showHistory) { setShowHistory(false); return true; }
            if (showAppearance) { setShowAppearance(false); return true; }
            if (showImageSourceModal) { setShowImageSourceModal(false); return true; }
            if (showVisionDraft) { setShowVisionDraft(false); return true; }
            if (showUnsavedChangesModal) { setShowUnsavedChangesModal(false); return true; }

            if (appMode === 'setup') {
                setAppMode('idle');
                return true;
            }

            if (appMode === 'live') {
                closeQuizSession();
                return true;
            }

            if (appMode === 'reader') {
                if (minimizedSession) {
                    setReadingSession(minimizedSession);
                    setMinimizedSession(null);
                    return true;
                }

                if (navOrigin === 'setup') {
                    setAppMode('setup');
                } else {
                    setAppMode("idle");
                }
                return true;
            }

            if (appMode === 'generating') {
                setAppMode("idle");
                return true;
            }

            // NEW: Handle Back Button for Flashcards
            if (appMode === 'flashcards') {
                Alert.alert("Exit Flashcards?", "Progress is not saved.", [
                    { text: "Cancel", style: "cancel" },
                    { text: "Exit", style: 'destructive', onPress: () => setAppMode('idle') }
                ]);
                return true;
            }

            if (appMode === 'idle' && (activeTab === 'library' || activeTab === 'notes' || activeTab === 'dictionary' || activeTab === 'story' || activeTab === 'settings' || activeTab === 'studio')) {
                if (activeTab === 'notes') {
                    if (isEditingNote) {
                        confirmCloseNote();
                        return true;
                    }

                    if (isSelectionMode) {
                        setIsSelectionMode(false);
                        setSelectedNoteIds([]);
                        return true;
                    }
                }

                if (activeTab === 'library') {
                    if (isLibrarySelectionMode) {
                        setIsLibrarySelectionMode(false);
                        setSelectedLibraryIds([]);
                        return true;
                    }
                }

                setActiveTab('home');
                return true;
            }

            return false;
        };

        const backHandler = BackHandler.addEventListener(
            "hardwareBackPress",
            backAction
        );

        return () => backHandler.remove();
    }, [appMode, activeTab, showWordModal, showHistory, showAppearance, dictionaryResult, isEditingNote, showImageSourceModal, showVisionDraft, quizState, currentNoteInput, currentNoteTitle, currentNoteId, navOrigin, currentNoteImages, minimizedSession, showUnsavedChangesModal, isSelectionMode, isLibrarySelectionMode]);

    const handleBatchDelete = () => {
        if (selectedNoteIds.length === 0) return;

        Alert.alert(
            "Delete Notes",
            `Permanently delete ${selectedNoteIds.length} notes? This cannot be undone.`,
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: 'destructive',
                    onPress: async () => {
                        const newSessions = { ...chatSessions };
                        const idsToDelete = [...selectedNoteIds];

                        // 1. Remove from State
                        idsToDelete.forEach(id => delete newSessions[id]);
                        setChatSessions(newSessions);

                        // 2. Remove from Storage
                        const keysToRemove = idsToDelete.map(id => `session_${id}`);
                        await AsyncStorage.multiRemove(keysToRemove);

                        // 3. Update Index
                        const indexJson = await AsyncStorage.getItem('session_index');
                        if (indexJson) {
                            let index = JSON.parse(indexJson);
                            index = index.filter((id: string) => !idsToDelete.includes(id));
                            await AsyncStorage.setItem('session_index', JSON.stringify(index));
                        }

                        // 4. Update Metadata Index
                        try {
                            const metaJson = await AsyncStorage.getItem('library_metadata_index');
                            if (metaJson) {
                                let metaMap = JSON.parse(metaJson);
                                idsToDelete.forEach(id => delete metaMap[id]);
                                await AsyncStorage.setItem('library_metadata_index', JSON.stringify(metaMap));
                            }
                        } catch (e) {
                            console.log("Failed to sync metadata index delete (notes)", e);
                        }

                        // Custom Audio Cleanup (from original logic)
                        const newAudioUris = { ...customAudioUris };
                        let audioUpdated = false;
                        await Promise.all(idsToDelete.map(async id => {
                            if (newAudioUris[id]) {
                                try { await FileSystem.deleteAsync(newAudioUris[id], { idempotent: true }); } catch (e) { }
                                delete newAudioUris[id];
                                audioUpdated = true;
                            }
                        }));
                        if (audioUpdated) {
                            if (setCustomAudioUris) setCustomAudioUris(newAudioUris);
                            await AsyncStorage.setItem('customAudioUris', JSON.stringify(newAudioUris));
                        }

                        setIsSelectionMode(false);
                        setSelectedNoteIds([]);
                        showToast(`Deleted ${idsToDelete.length} notes`);
                    }
                }
            ]
        );
    };



    const handleUploadAudio = async () => {
        try {
            const result = await DocumentPicker.getDocumentAsync({
                type: 'audio/*',
                copyToCacheDirectory: true
            });

            if (result.canceled) return;

            const file = result.assets[0];
            const sessionId = readingSession?.id;
            if (!sessionId) {
                Alert.alert('Error', 'No active reading session');
                return;
            }

            // Copy to permanent location
            const fileName = `custom_audio_${sessionId}_${Date.now()}.${file.name.split('.').pop()}`;
            const destPath = `${FileSystem.documentDirectory}${fileName}`;
            await FileSystem.copyAsync({
                from: file.uri,
                to: destPath
            });

            // Update state and persistence via the hooked setter
            // customAudioUris is the module-level variable which is synced
            const newMappings = { ...customAudioUris, [sessionId]: destPath };
            if (setCustomAudioUris) {
                setCustomAudioUris(newMappings);
            } else {
                // Fallback if setter not ready (unlikely)
                customAudioUris[sessionId] = destPath;
                await AsyncStorage.setItem('customAudioUris', JSON.stringify(customAudioUris));
            }

            Alert.alert('Success', 'Audio uploaded successfully! Use the play button to listen.');
        } catch (error) {
            console.error('Audio upload error:', error);
            Alert.alert('Error', 'Failed to upload audio file');
        }
    };

    const handleDeleteCustomAudio = (session: any = readingSession) => {
        if (!session) return;
        const sessionId = session.id;
        const audioUri = customAudioUris[sessionId];

        if (!audioUri) return;

        Alert.alert(
            "Delete Custom Audio?",
            "This will permanently remove the uploaded audio file for this chapter.",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: "destructive",
                    onPress: async () => {
                        try {
                            // Stop if playing
                            const isPlayingThis = (playingMeta?.id === sessionId && isCustomAudioPlaying);
                            if (isPlayingThis) {
                                stopCustomAudio();
                                stopTTS();
                            }

                            // Update State
                            const newMappings = { ...customAudioUris };
                            delete newMappings[sessionId];
                            if (setCustomAudioUris) setCustomAudioUris(newMappings);

                            // Persist
                            await AsyncStorage.setItem('customAudioUris', JSON.stringify(newMappings));

                            // File System Cleanup (Optional but good practice)
                            const fileInfo = await FileSystem.getInfoAsync(audioUri);
                            if (fileInfo.exists) {
                                await FileSystem.deleteAsync(audioUri, { idempotent: true });
                            }

                            showToast("Audio deleted");

                        } catch (error) {
                            console.error("Failed to delete audio:", error);
                            Alert.alert("Error", "Could not delete audio file.");
                        }
                    }
                }
            ]
        );
    };

    const playCustomAudio = async (sessionId: string) => {
        try {
            const audioUri = customAudioUris[sessionId];
            if (!audioUri) return false;

            // Check if file exists
            const fileInfo = await FileSystem.getInfoAsync(audioUri);
            console.log('[Audio Debug] File Info:', JSON.stringify(fileInfo));

            if (!fileInfo.exists || (fileInfo.size === 0)) {
                Alert.alert('Error', 'Audio file is empty or missing.');
                const newMappings = { ...customAudioUris };
                delete newMappings[sessionId];
                if (setCustomAudioUris) setCustomAudioUris(newMappings);
                return false;
            }

            // Stop any existing TTS and Audio
            stopTTS();
            stopCustomAudio();

            // Ensure Audio Mode
            await setAudioModeAsync({
                playsInSilentMode: true,
                shouldPlayInBackground: true,
                interruptionMode: 'duckOthers',
            });

            // Create new player
            const player = createAudioPlayer({ uri: audioUri });
            customAudioPlayerRef.current = player;

            // EXPERIMENTAL: Explicitly load source if createAudioPlayer isn't enough
            // @ts-ignore
            if (player.replace) {
                // @ts-ignore
                player.replace({ uri: audioUri });
            }

            // Ensure frequent updates
            // @ts-ignore - expo-audio types might be missing this method in some versions/mocks but it exists in native
            if ((player as any).setProgressUpdateInterval) {
                (player as any).setProgressUpdateInterval(100);
            }

            // Listen for finish and progress
            // Listen for finish and progress
            (player as any).addListener('playbackStatusUpdate', (status: any) => {
                if (!status.isLoaded) return;

                if (status.didJustFinish) {
                    setIsCustomAudioPlaying(false);
                    setTtsStatus('stopped');
                    customAudioPlayerRef.current = null;
                    setCustomAudioProgress({ position: 0, duration: 0 });
                    return;
                }

                if (status.playing) {
                    setCustomAudioProgress({
                        position: status.currentTime * 1000,
                        duration: (status.duration || 0) * 1000
                    });
                }
            });

            player.play();
            setIsCustomAudioPlaying(true);
            setTtsStatus('playing');

            // CRITICAL: Set playingMeta so Mini Player appears
            const sessionTitle = chatSessions[sessionId]?.title || "Custom Audio";
            setPlayingMeta({ id: sessionId, title: sessionTitle });

            return true;
        } catch (error) {
            console.error('Failed to play custom audio:', error);
            Alert.alert('Error', 'Failed to play custom audio');
            setIsCustomAudioPlaying(false);
            setTtsStatus('stopped');
            return false;
        }
    };

    const stopCustomAudio = () => {
        try {
            if (customAudioPlayerRef.current) {
                customAudioPlayerRef.current.pause();
                customAudioPlayerRef.current = null;
            }
        } catch (error) {
            console.error('Failed to stop custom audio:', error);
        }
        setIsCustomAudioPlaying(false);
    };

    const handleAnalyzeNote = async (type: string) => {
        const hasText = !!currentNoteInput.trim();
        const hasImages = currentNoteImages.length > 0;

        if (!hasText && !hasImages) {
            Alert.alert("Empty Note", "Please add text or an image.");
            return;
        }

        if (type === 'quiz') {
            await saveCurrentNote();
            handleStartQuiz(currentNoteInput, false, "General", true, currentNoteImages);
            return;
        }

        setIsNoteAnalyzing(true);
        setCurrentNoteSummary("");

        let prompt = "";
        let systemRole = "";
        let targetField = 'input';

        const textContext = hasText ? `Input Text: "${currentNoteInput}"` : "No input text provided, rely on images/documents.";

        switch (type) {
            case 'editor':
                systemRole = "Language Editor";
                targetField = 'input';
                prompt = `Act as a strict Language Editor.
            ${textContext}
            Task: Fix all grammar, spelling, and punctuation errors in the provided text and any text found in ALL attached documents/images.
            Output: ONLY the corrected text. If documents contain text, transcribe and correct it alongside the input text.`;
                break;
            case 'summary':
                systemRole = "Summarizer";
                targetField = 'summary';
                prompt = `Summarize the following content (text and ALL attached documents/images) in 1-2 clear sentences:\n"${textContext}"`;
                break;
            case 'translate':
                systemRole = "Translator";
                targetField = 'input';
                prompt = `Translate the content (text and text inside ALL attached documents/images) into ${displaySettings.language}. Only output the translation:\n"${textContext}"`;
                break;
            case 'expand':
                systemRole = "Content Writer";
                targetField = 'input';
                prompt = `Expand the following content. Add details, clarity, and context based on the text and information in ALL attached documents/images. Maintain the original meaning but make it more comprehensive:\n"${textContext}"`;
                break;
            case 'simplify':
                systemRole = "Teacher";
                targetField = 'input';
                prompt = `Rewrite the following content in simple, easy-to-understand language suitable for a beginner:\n"${textContext}"`;
                break;
            case 'key_points':
                systemRole = "Analyst";
                targetField = 'input';
                prompt = `Extract the main key points from the content and present them as a concise bulleted list:\n"${textContext}"`;
                break;
            case 'format':
                systemRole = "Editor";
                targetField = 'input';
                prompt = `Reformat the following text to be highly readable. Use Markdown headers, bullet points, and bold text where appropriate to structure the notes. Do not change the meaning:\n"${textContext}"`;
                break;
            case 'image_analysis':
                systemRole = "Visual Analyst";
                targetField = 'input';
                prompt = "Analyze ALL attached documents/images and create detailed study notes from them. Incorporate information from every file provided. Include headers and bullet points. " + (hasText ? `Also incorporate this text context: "${currentNoteInput}"` : "");
                break;
            case 'action_items':
                systemRole = "Project Manager";
                targetField = 'input';
                prompt = `Identify and list all actionable items or tasks from the following content as a checklist:\n"${textContext}"`;
                break;
            case 'email':
                systemRole = "Communication Coach";
                targetField = 'input';
                prompt = `Draft a professional email based on the following notes. Keep it concise and polite:\n"${textContext}"`;
                break;
            case 'critique':
                systemRole = "Reviewer";
                targetField = 'input';
                prompt = `Provide a constructive critique of this text. Identify logical gaps, tone inconsistencies, or areas for improvement:\n"${textContext}"`;
                break;
            case 'custom':
                systemRole = "Assistant";
                targetField = 'input';
                prompt = `Context Content:\n"${textContext}"\n\nUser Instruction: ${customNotePrompt}`;
                break;
        }

        try {
            let contents;

            if (hasImages) {
                const contentParts: any[] = [{ text: prompt }];

                const imageParts = await Promise.all(currentNoteImages.map(async (uri: any) => {
                    try {
                        const isPdf = uri.toLowerCase().endsWith('.pdf');
                        const mimeType = isPdf ? "application/pdf" : "image/jpeg";
                        let base64 = "";

                        if (uri.startsWith('data:')) {
                            base64 = uri.split(',')[1];
                        } else {
                            base64 = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.Base64 });
                        }

                        if (base64) base64 = base64.replace(/\r?\n|\r/g, '');
                        return { inlineData: { mimeType, data: base64 } };
                    } catch (e: any) {
                        console.warn("Failed to process asset:", uri);
                        return null;
                    }
                }));

                imageParts.forEach((part: any) => {
                    if (part && part.inlineData.data) {
                        contentParts.push(part);
                    }
                });

                contents = [{ role: "user", parts: contentParts }];
            } else {
                contents = prompt;
            }

            const content = await callLLM(contents, systemRole);

            if (content.startsWith("Error")) {
                Alert.alert("Analysis Failed", content);
                setIsNoteAnalyzing(false);
                return;
            }

            if (targetField === 'input') {
                pushToHistoryImmediate();

                let newContent = content.trim();

                if (type === 'image_analysis' && hasText) {
                    newContent = currentNoteInput + "\n\n# Document Notes\n" + content.trim();
                    setCurrentNoteInput((prev: any) => prev + "\n\n# Document Notes\n" + content.trim());
                } else if (type === 'custom') {
                    setCurrentNoteInput((prev: any) => {
                        const separator = prev.trim().length > 0 ? "\n\n" : "";
                        const appended = prev + separator + `### AI Response: ${customNotePrompt}\n` + content.trim();
                        newContent = appended;
                        return appended;
                    });
                } else {
                    setCurrentNoteInput(newContent);
                }

                setTimeout(() => {
                    lastHistoryState.current = newContent;
                }, 0);
            } else {
                setCurrentNoteSummary(content.trim());
            }
        } catch (e) {
            Alert.alert("Error", "Analysis failed.");
        } finally {
            setIsNoteAnalyzing(false);
        }
    };

    // NEW: Reusable function for processing word candidates (Vision & Reader)
    const processCandidatesAndFetchDefinitions = async (candidates: string[]) => {
        // 1. Filter against History (Local Dictionary)
        const knownWords = new Set();
        Object.keys(dictionaryCache).forEach(w => knownWords.add(w.toLowerCase()));
        savedWords.forEach(w => {
            if (typeof w === 'string') knownWords.add(w.toLowerCase());
            else if (w.word) knownWords.add(w.word.toLowerCase());
        });
        // REF CHANGE: Check against REF (Master List)
        recentSearchesRef.current.forEach(w => {
            if (typeof w === 'string') knownWords.add(w.toLowerCase());
            else if (w.word) knownWords.add(w.word.toLowerCase());
        });

        // Filter
        const newWords = candidates.filter(w => !knownWords.has(w.toLowerCase()));

        if (newWords.length === 0) {
            Alert.alert("No New Words", "No new intermediate/advanced words found (or you already have them in your history).");
            setIsDictionaryLoading(false);
            return;
        }

        // 2. Batch Processing Loop (Chunks of 25)
        const BATCH_SIZE = 25;
        let totalSuccessCount = 0;
        const totalBatches = Math.ceil(newWords.length / BATCH_SIZE);

        try {
            for (let i = 0; i < newWords.length; i += BATCH_SIZE) {
                const batchIndex = Math.floor(i / BATCH_SIZE) + 1;
                const batch = newWords.slice(i, i + BATCH_SIZE);

                if (batch.length === 0) continue;

                // Inform user of progress if multiple batches
                if (totalBatches > 1) {
                    showToast(`Analyzing batch ${batchIndex} of ${totalBatches}...`);
                }

                try {
                    // Fetch Definitions for current batch
                    const batchDefinitions = await fetchBatchDefinitions(batch);

                    let batchSuccessCount = 0;
                    const batchNewItems: any[] = [];
                    const newCacheEntries: any = {};

                    if (batchDefinitions && batchDefinitions.length > 0) {
                        for (const data of batchDefinitions) {
                            if (data && (data.definition || data.simple)) {
                                const cleanData = { ...data, word: data.word || "Unknown" };
                                const currentLang = displaySettings.language;

                                const completeData = {
                                    ...cleanData,
                                    language: currentLang,
                                    translations: { [currentLang]: cleanData }
                                };

                                // Accumulate cache updates
                                newCacheEntries[cleanData.word.toLowerCase()] = completeData;
                                batchNewItems.unshift({ word: cleanData.word, data: completeData });
                                batchSuccessCount++;
                            }
                        }
                    }

                    // Update Cache immediately
                    if (Object.keys(newCacheEntries).length > 0) {
                        setDictionaryCache((prev: any) => ({ ...prev, ...newCacheEntries }));
                    }

                    totalSuccessCount += batchSuccessCount;

                    // INCREMENTAL SAVE: Update FILE after EACH batch (Safety)
                    // USE ORCHESTRATOR with skipStateUpdate=true
                    if (batchSuccessCount > 0) {
                        // 1. Get Latest Master List from Ref
                        const currentMaster = recentSearchesRef.current;

                        // 2. Prepend NEW Batch Items to the Master List
                        const updatedForFile = [...batchNewItems, ...currentMaster];

                        // 3. Slice/Limit
                        const limit = displaySettings.dictionaryLimit || 1000;
                        const finalUpdated = updatedForFile.slice(0, limit);

                        // 4. Save via Orchestrator (Skip UI Update for performance)
                        await updateRecentSearchesOrchestrator(finalUpdated, true);
                    }

                } catch (batchError) {
                    console.error(`Error processing batch ${batchIndex}:`, batchError);
                    showToast(`Batch ${batchIndex} failed, trying next...`);
                }
            }

            // FINAL UI UPDATE: Update State ONCE at the end with the LATEST Ref data
            if (totalSuccessCount > 0) {
                // Force a UI update with the final Ref state
                setRecentSearches(recentSearchesRef.current);
                Alert.alert("Discovery Complete", `Added ${totalSuccessCount} new words to your dictionary.`);
            } else {
                Alert.alert("No Definitions Found", "Could not retrieve definitions for the found words.");
            }

        } catch (error) {
            console.error("Discovery process error:", error);
            Alert.alert("Error", "An unexpected error occurred during discovery.");
        } finally {
            setIsDictionaryLoading(false);
        }
    };

    // NEW: Reader Smart Discovery
    const handleReaderDiscovery = async () => {
        if (!readingSession) return;
        const content = readingSession.messages?.[0]?.content || "";
        if (!content.trim()) {
            Alert.alert("Empty Content", "No text found to analyze.");
            return;
        }

        setIsBatchProcessing(true); // Non-blocking batch indicator
        showToast("Scanning text for vocabulary..."); // Immediate feedback

        try {
            // Keep prompt simple and focused
            // UPDATED: Include A2, B1 for broader discovery
            const extractionPrompt = `
            Extract interesting vocabulary (CEFR B1, B2, C1, C2 levels) from the provided text.
            Exclude basic words (A1 and A2 like 'the', 'is', 'and', 'cat', 'walk', 'talk').
            Return strictly a JSON array of strings (the words).
            Example: ["journey", "difficult", "ubiquitous", "ephemeral", "pragmatic"]
            `;

            // Truncate content if too long to save tokens (first 2000 chars usually enough for vocabulary sampling)
            // But user asked for "all text", let's try a reasonable chunk or full if not huge.
            // 4000 chars is ~1000 tokens, safe.
            const contentSample = content.slice(0, 10000);

            const messages = [{
                role: "user",
                parts: [
                    { text: extractionPrompt + "\n\nTEXT:\n" + contentSample }
                ]
            }];

            const rawResponse = await callLLM(messages, "Linguist", true);
            const extractedWords = extractJSON(rawResponse);

            let wordList = [];
            try {
                wordList = JSON.parse(extractedWords);
                if (!Array.isArray(wordList)) throw new Error("Not an array");
            } catch (e) {
                console.log("JSON Parse Error (Reader)", e);
                wordList = extractedWords.split(/,|\n/).map(s => s.trim()).filter(s => s.length > 2);
            }

            await processCandidatesAndFetchDefinitions(wordList);

        } catch (error) {
            console.error("Reader Discovery Error", error);
            Alert.alert("Analysis Failed", "Could not analyze the text.");
        } finally {
            setIsBatchProcessing(false); // Always clear batch indicator
        }
    };

    // NEW: Dictionary Vision Handler (Batch Word Discovery)
    const handleDictionaryVision = async (uris: string[]) => {
        if (!uris || uris.length === 0) return;

        setIsBatchProcessing(true); // Non-blocking batch indicator
        setDictionaryResult(null); // Clear previous result view if any

        try {
            // 1. Prepare Image Data for Gemini
            const assetParts = await Promise.all(uris.map(async (uri) => {
                try {
                    const isPdf = uri.toLowerCase().endsWith('.pdf');
                    const mimeType = isPdf ? "application/pdf" : "image/jpeg";
                    let base64 = "";

                    if (uri.startsWith('data:')) {
                        base64 = uri.split(',')[1];
                    } else {
                        base64 = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.Base64 });
                    }

                    if (base64) base64 = base64.replace(/\r?\n|\r/g, '');
                    return { inlineData: { mimeType, data: base64 } };
                } catch (e: any) {
                    console.log("Error reading asset", e);
                    return null;
                }
            }));

            const validParts = assetParts.filter(p => p !== null);
            if (validParts.length === 0) {
                Alert.alert("Error", "Could not process the selected image(s).");
                setIsBatchProcessing(false); // Clear batch indicator
                return;
            }

            // 2. Construct Prompt for Word Extraction
            const userLang = displaySettings.language || "English";
            const extractionPrompt = `
            Role: Expert Linguist.
            Task: Analyze the provided image/document and extract a list of "Intermediate" (B1/B2) and "Advanced" (C1/C2) English words.
            user's language: ${userLang}.

            CRITERIA:
            1. Extract distinct, sophisticated vocabulary found in the text.
            2. Ignore basic words (A1 and A2 like 'the', 'is', 'and', 'cat', 'walk', 'talk').
            3. Return key technical terms if present.
            4. Lemmatize words (e.g., return "run" instead of "running").

            OUTPUT FORMAT:
            Strictly return a JSON array of strings. Do not include markdown code blocks.
            Example: ["ephemeral", "serendipity", "obfuscate"]
            `;

            const contents = [{
                role: "user",
                parts: [
                    { text: extractionPrompt },
                    ...validParts
                ]
            }];

            // 3. Call LLM to extract words
            const rawResponse = await callLLM(contents, "Linguist", true); // jsonMode=true if supported or we parse manually
            const extractedWords = extractJSON(rawResponse);
            let wordList = [];
            try {
                wordList = JSON.parse(extractedWords);
                if (!Array.isArray(wordList)) throw new Error("Not an array");
            } catch (e) {
                console.log("JSON Parse Error (Reader)", e);
                wordList = extractedWords.split(/,|\n/).map(s => s.trim()).filter(s => s.length > 2);
            }

            await processCandidatesAndFetchDefinitions(wordList);

        } catch (error) {
            console.error("Reader Discovery Error", error);
            Alert.alert("Analysis Failed", "Could not analyze the text.");
        } finally {
            setIsBatchProcessing(false); // Clear batch indicator
        }
    };

    const handleImagePicked = async (result: any) => {
        if (!result.canceled) {
            setShowImageSourceModal(false);
            const newUris = result.assets.map((asset: any) => {
                if (asset.base64) return `data:image/jpeg;base64,${asset.base64}`;
                return asset.uri;
            });

            if (imagePickerMode === 'note') {
                setCurrentNoteImages((prev: any) => [...prev, ...newUris]);
            } else if (imagePickerMode === 'dictionary_vision') {
                // NEW: Dictionary Vision (Batch Word Discovery)
                handleDictionaryVision(newUris);
            } else {
                setVisionDraft((prev: any) => ({
                    ...prev,
                    uris: [...(prev.uris || []), ...newUris]
                }));

                // FIXED: Don't open Vision Modal if we are in Personal Assistant (ai_tutor)
                // The images will appear in the specific AI Tutor UI instead.
                if (selectedScenario?.id !== 'ai_tutor') {
                    setShowVisionDraft(true);
                }
            }
        }
    };

    const onDocumentPress = async (modeOverride = null) => {
        try {
            const result = await DocumentPicker.getDocumentAsync({
                type: ['application/pdf'],
                copyToCacheDirectory: true,
                multiple: true
            });

            if (!result.canceled && result.assets) {
                setShowImageSourceModal(false);
                const newUris = result.assets.map(a => a.uri);

                const targetMode = (typeof modeOverride === 'string') ? modeOverride : imagePickerMode;

                if (targetMode === 'note') {
                    setCurrentNoteImages((prev: any) => [...prev, ...newUris]);
                } else if (targetMode === 'dictionary_vision') {
                    // NEW: Dictionary Vision (Batch Word Discovery)
                    handleDictionaryVision(newUris);
                } else {
                    setVisionDraft((prev: any) => ({
                        ...prev,
                        uris: [...(prev.uris || []), ...newUris]
                    }));
                    setShowVisionDraft(true);
                }
            }
        } catch (err) {
            console.log("Doc picker error", err);
        }
    };

    const onCameraPress = async () => {
        const perm = await ImagePicker.requestCameraPermissionsAsync();
        if (perm.status !== 'granted') { Alert.alert("Permission needed", "Camera permission is required."); return; }

        const result = await ImagePicker.launchCameraAsync({
            base64: true,
            quality: 0.5,
            allowsEditing: false
        });

        if (!result.canceled) {
            openImageEditor(result.assets[0]);
        }
    };

    const onGalleryCropPress = async () => {
        const result = await ImagePicker.launchImageLibraryAsync({
            mediaTypes: ImagePicker.MediaTypeOptions.Images,
            base64: true,
            quality: 0.5,
            allowsEditing: false,
            allowsMultipleSelection: false
        });

        if (!result.canceled) {
            openImageEditor(result.assets[0]);
        }
    };

    const onGalleryMultiplePress = async () => {
        const result = await ImagePicker.launchImageLibraryAsync({
            mediaTypes: ImagePicker.MediaTypeOptions.Images,
            base64: true,
            quality: 0.5,
            allowsEditing: false,
            allowsMultipleSelection: true
        });

        if (!result.canceled) {
            handleImagePicked(result);
        }
    };

    const openImageEditor = (asset: any) => {
        setShowImageSourceModal(false);
        setEditorTarget(asset);
        setEditorRotation(0);
        setCropRegion(null);
        setEditingImageIndex(null);
        setShowImageEditor(true);
    };

    const openEditorForExistingImage = (uri: string, index: number) => {
        if (isPdf(uri)) return;

        Image.getSize(uri, (width, height) => {
            setEditorTarget({ uri, width, height });
            setEditorRotation(0);
            setCropRegion(null);
            setEditingImageIndex(index);
            setShowImageEditor(true);
        }, (error) => {
            console.error("Could not get image size", error);
            Alert.alert("Error", "Could not edit this image.");
        });
    };

    const calculateDisplayedRect = (containerW: number, containerH: number, imageW: number, imageH: number, rotation: number) => {
        const isRotated = Math.abs(rotation) === 90 || Math.abs(rotation) === 270;
        const effectiveW = isRotated ? imageH : imageW;
        const effectiveH = isRotated ? imageW : imageH;

        const imageRatio = effectiveW / effectiveH;
        const containerRatio = containerW / containerH;

        let dispW, dispH, dispX, dispY;

        if (containerRatio > imageRatio) {
            dispH = containerH;
            dispW = containerH * imageRatio;
            dispY = 0;
            dispX = (containerW - dispW) / 2;
        } else {
            dispW = containerW;
            dispH = containerW / imageRatio;
            dispX = 0;
            dispY = (containerH - dispH) / 2;
        }
        return { x: dispX, y: dispY, width: dispW, height: dispH, effectiveW, effectiveH };
    };

    useEffect(() => {
        if (showImageEditor && editorTarget && editorContainerSize.width > 0) {
            const rect = calculateDisplayedRect(
                editorContainerSize.width,
                editorContainerSize.height,
                editorTarget.width,
                editorTarget.height,
                editorRotation
            );
            setDisplayedImageRect(rect);
            setCropRegion({ x: rect.x, y: rect.y, width: rect.width, height: rect.height });
        }
    }, [showImageEditor, editorTarget, editorContainerSize, editorRotation]);

    const tlResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => true,
            onStartShouldSetPanResponderCapture: () => true,
            onMoveShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponderCapture: () => true,
            onPanResponderGrant: () => {
                if (cropRegionRef.current) {
                    dragStartRef.current = { ...cropRegionRef.current };
                }
            },
            onPanResponderMove: (evt, gestureState) => {
                const start = dragStartRef.current;
                const bounds = displayedImageRectRef.current;
                if (!start || !bounds) return;

                let newX = start.x + gestureState.dx;
                let newY = start.y + gestureState.dy;

                newX = Math.max(bounds.x, newX);
                newY = Math.max(bounds.y, newY);

                const maxX = start.x + start.width - 40;
                const maxY = start.y + start.height - 40;
                newX = Math.min(newX, maxX);
                newY = Math.min(newY, maxY);

                const newWidth = (start.x + start.width) - newX;
                const newHeight = (start.y + start.height) - newY;

                setCropRegion({
                    x: newX,
                    y: newY,
                    width: newWidth,
                    height: newHeight
                });
            },
            onPanResponderTerminationRequest: () => false,
            onPanResponderRelease: () => { dragStartRef.current = null; }
        })
    ).current;

    const trResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => true,
            onStartShouldSetPanResponderCapture: () => true,
            onMoveShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponderCapture: () => true,
            onPanResponderGrant: () => {
                if (cropRegionRef.current) {
                    dragStartRef.current = { ...cropRegionRef.current };
                }
            },
            onPanResponderMove: (evt, gestureState) => {
                const start = dragStartRef.current;
                const bounds = displayedImageRectRef.current;
                if (!start || !bounds) return;

                let newY = start.y + gestureState.dy;
                newY = Math.max(bounds.y, newY);
                const maxY = start.y + start.height - 40;
                newY = Math.min(newY, maxY);

                const newHeight = (start.y + start.height) - newY;

                let newWidth = start.width + gestureState.dx;
                newWidth = Math.max(40, newWidth);

                const maxRight = bounds.x + bounds.width;
                if (start.x + newWidth > maxRight) newWidth = maxRight - start.x;

                setCropRegion({
                    x: start.x,
                    y: newY,
                    width: newWidth,
                    height: newHeight
                });
            },
            onPanResponderTerminationRequest: () => false,
            onPanResponderRelease: () => { dragStartRef.current = null; }
        })
    ).current;

    const blResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => true,
            onStartShouldSetPanResponderCapture: () => true,
            onMoveShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponderCapture: () => true,
            onPanResponderGrant: () => {
                if (cropRegionRef.current) {
                    dragStartRef.current = { ...cropRegionRef.current };
                }
            },
            onPanResponderMove: (evt, gestureState) => {
                const start = dragStartRef.current;
                const bounds = displayedImageRectRef.current;
                if (!start || !bounds) return;

                let newX = start.x + gestureState.dx;
                newX = Math.max(bounds.x, newX);
                const maxX = start.x + start.width - 40;
                newX = Math.min(newX, maxX);

                const newWidth = (start.x + start.width) - newX;

                let newHeight = start.height + gestureState.dy;
                newHeight = Math.max(40, newHeight);

                const maxBottom = bounds.y + bounds.height;
                if (start.y + newHeight > maxBottom) newHeight = maxBottom - start.y;

                setCropRegion({
                    x: newX,
                    y: start.y,
                    width: newWidth,
                    height: newHeight
                });
            },
            onPanResponderTerminationRequest: () => false,
            onPanResponderRelease: () => { dragStartRef.current = null; }
        })
    ).current;

    const brResponder = useRef(
        PanResponder.create({
            onStartShouldSetPanResponder: () => true,
            onStartShouldSetPanResponderCapture: () => true,
            onMoveShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponderCapture: () => true,
            onPanResponderGrant: () => {
                if (cropRegionRef.current) {
                    dragStartRef.current = { ...cropRegionRef.current };
                }
            },
            onPanResponderMove: (evt, gestureState) => {
                const start = dragStartRef.current;
                const bounds = displayedImageRectRef.current;
                if (!start || !bounds) return;

                let newWidth = start.width + gestureState.dx;
                let newHeight = start.height + gestureState.dy;

                newWidth = Math.max(40, newWidth);
                newHeight = Math.max(40, newHeight);

                const maxRight = bounds.x + bounds.width;
                const maxBottom = bounds.y + bounds.height;

                if (start.x + newWidth > maxRight) newWidth = maxRight - start.x;
                if (start.y + newHeight > maxBottom) newHeight = maxBottom - start.y;

                setCropRegion({
                    ...start,
                    width: newWidth,
                    height: newHeight
                });
            },
            onPanResponderTerminationRequest: () => false,
            onPanResponderRelease: () => { dragStartRef.current = null; }
        })
    ).current;

    const processEditorSave = async () => {
        if (!editorTarget || !cropRegion || !displayedImageRect) return;

        try {
            const actions = [];

            if (editorRotation !== 0) {
                actions.push({ rotate: editorRotation });
            }

            const currentImageWidth = displayedImageRect.effectiveW || 0;
            const currentImageHeight = displayedImageRect.effectiveH || 0;

            const scaleX = currentImageWidth / displayedImageRect.width;
            const scaleY = currentImageHeight / displayedImageRect.height;

            let cropX = (cropRegion.x - displayedImageRect.x) * scaleX;
            let cropY = (cropRegion.y - displayedImageRect.y) * scaleY;
            let cropW = cropRegion.width * scaleX;
            let cropH = cropRegion.height * scaleY;

            cropX = Math.max(0, cropX);
            cropY = Math.max(0, cropY);

            if (cropX + cropW > currentImageWidth) {
                cropW = currentImageWidth - cropX;
            }
            if (cropY + cropH > currentImageHeight) {
                cropH = currentImageHeight - cropY;
            }

            if (cropW > 0 && cropH > 0) {
                actions.push({
                    crop: {
                        originX: cropX,
                        originY: cropY,
                        width: cropW,
                        height: cropH
                    }
                });
            }

            const result = await ImageManipulator.manipulateAsync(
                editorTarget.uri,
                actions,
                { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG, base64: true }
            );

            if (editingImageIndex !== null) {
                const newUri = `data:image/jpeg;base64,${result.base64}`;
                if (imagePickerMode === 'note') {
                    setCurrentNoteImages((prev: any) => {
                        const updated = [...prev];
                        updated[editingImageIndex] = newUri;
                        return updated;
                    });
                } else {
                    setVisionDraft((prev: any) => {
                        const updatedUris = [...prev.uris];
                        updatedUris[editingImageIndex] = newUri;
                        return { ...prev, uris: updatedUris };
                    });
                }
                setEditingImageIndex(null);
            } else {
                handleImagePicked({ canceled: false, assets: [result] });
            }
            setShowImageEditor(false);

        } catch (e: any) {
            console.error("Editor Error", e);
            Alert.alert("Error", "Could not process image.");
        }
    };

    const processVisionRequest = async (overridePrompt: string | null = null) => {
        const effectivePrompt = typeof overridePrompt === 'string' ? overridePrompt : visionDraft.prompt;

        if (visionDraft.uris.length === 0) {
            Alert.alert("No Images", "Please select at least one image.");
            return;
        }

        const lowerPrompt = (effectivePrompt || "").toLowerCase();

        const isFlashcardIntent = lowerPrompt.includes('flashcard') ||
            lowerPrompt.includes('flash card') ||
            lowerPrompt.includes('study card');

        const isQuizIntent = (imagePickerMode === 'quiz' ||
            lowerPrompt.includes('quiz') ||
            lowerPrompt.includes('mcq') ||
            lowerPrompt.includes('multiple choice') ||
            lowerPrompt.includes('test me') ||
            /(\d+)\s+[\w\s]*?questions/i.test(lowerPrompt)) && !isFlashcardIntent; // Prioritize explicit flashcard requests

        if (isFlashcardIntent) {
            setShowVisionDraft(false);

            let requestedCount = null;
            const countMatch = lowerPrompt.match(/(\d+)/);
            if (countMatch) requestedCount = parseInt(countMatch[1], 10);

            const topic = effectivePrompt || "Generate Flashcards from Images";
            const subject = "General"; // Or derive from School Config

            // Pass isFlashcardMode = true (last argument)
            handleStartQuiz(topic, false, subject, true, visionDraft.uris, requestedCount, true);
            setVisionDraft({ uris: [], prompt: "" });
            return;
        }

        if (isQuizIntent) {
            setShowVisionDraft(false);

            let requestedCount = null;

            const explicitMatch = lowerPrompt.match(/(\d+)\s+[\w\s]*?(?:questions|qs|mcqs|items)/i);
            const actionMatch = lowerPrompt.match(/(?:make|create|generate|give)\s+(?:me\s+)?(?:a\s+)?(?:quiz\s+)?(?:with\s+)?(\d+)\b/i);
            const shortMatch = lowerPrompt.match(/(?:quiz|mcq|test)\s*(?:with|of|for)?\s*(\d+)/i);

            const countMatch = explicitMatch || actionMatch || shortMatch;

            if (countMatch) {
                requestedCount = parseInt(countMatch[1], 10);
            }

            const topic = effectivePrompt || (imagePickerMode === 'quiz' ? "Generate Quiz from Images" : "Generate Quiz");
            const subject = imagePickerMode === 'quiz' ? schoolConfig.subject : "General";

            handleStartQuiz(topic, false, subject, true, visionDraft.uris, requestedCount);
            setVisionDraft({ uris: [], prompt: "" });
            return;
        }

        setShowVisionDraft(false);
        setAppMode("generating");

        let systemRole = "Visual Analyst";
        let targetToolId = 'visual_learner';
        let loadingMsg = "Analyzing visual data...";

        if (imagePickerMode === 'story') {
            if (storyMode === 'character') {
                systemRole = "Method Actor / Screenwriter";
            } else {
                systemRole = "Creative Writer";
            }
            targetToolId = 'story_generator';
            loadingMsg = "Drafting story...";
        } else if (imagePickerMode === 'story_next') { // NEW: Handle Story Next Input
            systemRole = "Creative Assistant";
            targetToolId = 'story_generator';
            loadingMsg = "Analyzing scene...";
        } else if (imagePickerMode === 'writer') {
            systemRole = "Professional Writer";
            targetToolId = 'writer';
            loadingMsg = "Writing content...";
        } else if (imagePickerMode === 'email_pro') {
            systemRole = "Communication Expert";
            targetToolId = 'email_pro';
            loadingMsg = "Drafting email...";
        } else if (imagePickerMode === 'greetings_gen') {
            systemRole = "Creative Greetings Writer";
            targetToolId = 'greetings_gen';
            loadingMsg = "Crafting greeting...";
        } else if (imagePickerMode === 'word_help') {
            systemRole = "Vocabulary Expert";
            targetToolId = 'word_help';
            loadingMsg = "Extracting words...";
        } else if (imagePickerMode === 'editorial') {
            systemRole = "Senior Chief Editor";
            targetToolId = 'editorial_writer';
            loadingMsg = "Writing editorial...";
        } else if (imagePickerMode === 'doctor') {
            systemRole = "Experienced Medical Doctor";
            targetToolId = 'health_guide';
            loadingMsg = "Analyzing symptoms...";
        } else if (imagePickerMode === 'work_organizer') {
            systemRole = "Expert Organizer";
            targetToolId = 'work_organizer';
            loadingMsg = "Organizing...";
        } else if (imagePickerMode === 'custom') {
            systemRole = selectedScenario?.title || "Custom Role";
            targetToolId = selectedScenario?.id || 'custom';
            loadingMsg = `${selectedScenario?.title || "AI"} is thinking...`;
        } else if (imagePickerMode === 'math') {
            systemRole = "Math Expert";
            targetToolId = 'math_solver';
            loadingMsg = "Solving equation...";
        } else if (imagePickerMode === 'teacher') {
            systemRole = "Expert Teacher";
            targetToolId = 'teacher';
            loadingMsg = "Preparing lesson...";
        }

        setGenerationData(loadingMsg);

        let defaultPrompt = "Analyze these images in detail.";
        if (imagePickerMode === 'math') defaultPrompt = "Solve the math problem in this image.";
        if (imagePickerMode === 'doctor') defaultPrompt = "Analyze the visible symptoms in this image.";
        if (imagePickerMode === 'work_organizer') defaultPrompt = "Organize the content of this image.";
        if (imagePickerMode === 'teacher') defaultPrompt = "Explain the concept shown in this image.";
        if (imagePickerMode === 'story_next') defaultPrompt = "Describe the events, setting, and mood in this image to serve as a plot continuation for a story.";

        const userPrompt = effectivePrompt.trim() || defaultPrompt;

        try {
            let systemPrompt = userPrompt;

            if (imagePickerMode === 'story') {
                if (storyMode === 'character') {
                    systemPrompt += `
                  
                  MODE: AUDIO DRAMA SCRIPT
                  
                  STRICT RULES:
                  1. **FORMAT**: Use "**Narrator:**" for description and "**[Character Name]:**" for speech.
                  2. **IMMEDIATE ACTION**: Start immediately. No meta-intro like "Here is the script".
                  3. **VISUAL INTEGRATION**: The script must describe the scene shown in the image.
                  4. **STYLE**: Fast-paced and dialogue-heavy.
                  5. **NO GENERIC LABELS**: Do not use "Scene:" or "Action:". Use "Narrator:".
                  
                  Task: Write a script enacting the scene depicted in the image.
                  `;
                } else {
                    systemPrompt += `
                  
                  CREATIVE WRITING INSTRUCTIONS:
                  - Use the visual/text context as a launchpad for a deep, imaginative narrative.
                  - Do NOT just summarize or describe the image. Write a full story or biography with emotional depth, dialogue, and sensory details.
                  - Invent names, backstories, and world-building elements that fit the visual style.
                  - Length: Substantial and immersive (aim for a full chapter or detailed short story, ~800 words).
                  - Style: Professional storytelling. Avoid phrases like "The image shows...". Instead, immerse the reader in the scene.
                  `;
                }
            } else if (imagePickerMode === 'doctor') {
                systemPrompt = `
               Role: Experienced and Compassionate Medical Doctor.
               
               User Note: "${userPrompt}"
               
               Task: Analyze the provided image(s) for visible medical symptoms or issues.
               
               STRICT CONSTRAINT: 
               At the very end, you MUST hide the medical disclaimer using the toggle format:
               1. Output strictly on a new line: "[[TOGGLE_TABLE:Read Medical Disclaimer]]"
               2. Follow immediately with a Markdown table:
               | Notice |
               |---|
               | This is AI advice and not a substitute for professional emergency care. Always consult a qualified doctor. |
               
               STRUCTURE:
               1. **Visual Analysis**: Describe what medical signs are visible in the image.
               2. **Potential Causes**: List likely reasons (medical differential) based on visual evidence.
               3. **Immediate Advice/Remedies**: Actionable steps, home remedies, or OTC suggestions.
               4. **When to see a specialist**: Specific red flags requiring a physical visit.
               
               Format: Professional medical advice format using Markdown.
               `;
            } else if (imagePickerMode === 'email_pro') {
                systemPrompt = `
               Role: Professional Communication Expert.
               
               User Instruction: "${userPrompt}"
               
               Task: Analyze the provided image(s) (document, letter, screenshot, or handwritten notes) and draft a complete professional email based on it.
               
               Guidelines:
               1. **Context Analysis**: Extract key details (Sender, Topic, Urgency) from the image.
               2. **Drafting**: Write a clear Subject Line and Body.
               3. **Tone**: Professional, polite, and effective.
               4. **Constraint**: Do not output analysis of the image unless asked. Go straight to the Draft.
               
               Output Format:
               **Subject:** [Subject]
               
               [Body]
               `;
            } else if (imagePickerMode === 'greetings_gen') {
                systemPrompt = `
               Role: Creative Greetings Writer.
               
               User Instruction: "${userPrompt}"
               
               Task: Analyze the provided image(s) to determine the occasion, mood, context, or recipient, and write suitable greetings/messages.
               
               OUTPUT STRUCTURE:
               1. **Visual Context**: Briefly mention what you see (e.g., "A festive Diwali scene", "A birthday cake").
               2. **Short & Sweet**: A quick, punchy message.
               3. **Heartfelt**: A warm, emotional message.
               4. **Funny/Witty**: A humorous take.
               5. **Social Media**: A caption with emojis and hashtags.
               
               Format: Markdown. Use emojis freely.
               `;
            } else if (imagePickerMode === 'work_organizer') {
                systemPrompt = `
               Role: Elite Executive Assistant & Project Manager.
               
               User Instruction: "${userPrompt}"
               
               Task: Transform the provided image(s) (whiteboard, handwritten notes, screenshot, or document) into a perfectly organized professional document.
               
               INTELLIGENT STRUCTURING LOGIC:
               1. **Identify Type**: Is it a Meeting, To-Do List, Brainstorming, or Reference Doc?
               2. **If Meeting Notes**: Output clearly as **Agenda**, **Key Discussion Points**, **Decisions Made**, and **Action Items** (with assignees if found).
               3. **If Tasks/To-Do**: Extract all tasks. **Prioritize** them (High/Medium/Low) based on urgency context. Use Checkboxes (- [ ]).
               4. **If Brainstorming/Notes**: Group related ideas into clear Categories/Themes with headers.
               5. **If Schedule/Itinerary**: Organize chronologically.
               
               Format: Clean, structured Markdown. Use Tables where appropriate for data. Use Bold for emphasis.
               `;
            } else if (imagePickerMode === 'editorial') {
                systemPrompt = `
               Role: Senior Chief Editor.
               
               User Instruction: "${userPrompt}"
               
               Task: Analyze the provided image(s) deeply and write a compelling **Editorial** or **Opinion Piece** based on it.
               
               VOCABULARY REQUIREMENT:
               - Use a sophisticated blend of **intermediate and advanced vocabulary**.
               - Avoid basic phrasing; aim for academic eloquence (e.g., use "paradigm shift" instead of "big change", "exacerbate" instead of "make worse").
               
               Guidelines:
               1. **Visual Hook**: Start by describing the striking elements of the image to set the scene.
               2. **The Argument**: Pivot to the broader issue, theme, or story the image represents.
               3. **Tone**: Authoritative, engaging, and polished. (Adjust based on prompt: Satirical, Serious, or Analytical).
               
               STRUCTURE:
               1. **Headline**: Catchy and provocative.
               2. **The Lede**: Strong opening hook connecting the visual to the topic.
               3. **The Body**: Analysis, argument, and context.
               4. **The Kicker**: A memorable closing thought.
               

               Format: Standard Journalism Markdown.
               `;
            } else if (imagePickerMode === 'word_help') {
                const targetLang = displaySettings.language;
                const isBilingual = targetLang !== 'English';

                systemPrompt = `
               Role: Creative Vocabulary Expert.
               
               User Instruction: "${userPrompt}"
               
               Task: 
               1. **Analyze** the provided image/document to identify text.
               2. **Extract** exactly 5 distinct, interesting, or challenging words found in the text. (If fewer than 5 found, use all of them).
               3. **Generate Lesson**: For these specific words, generate a complete vocabulary lesson following this EXACT structure:
               ${isBilingual ? `\nBILINGUAL MODE ENABLED: The user's primary language is ${targetLang}. For "Meaning", "Memory Trick", and "Examples", strictly provide the text in BOTH English and ${targetLang}.` : ''}
               
               1. **Deep Dive Definitions**: 
                  - STRICTLY DO NOT USE TABLES. Use a clear, readable list format.
                  - For EACH word, use this format:
                    ### [Word]
                    **Meaning**: [Definition${isBilingual ? ` / Definition in ${targetLang}` : ''}]
                    **Part of Speech**: [e.g. Verb, Noun, Adjective]
                    **Forms/Degree**: [If Verb: V1, V2, V3, -ing; If Adj: Positive/Comparative/Superlative; Else: Plurals or N/A]
                    **Synonyms**: [List 2-3 common synonyms]
                    **Antonyms**: [List 2-3 common antonyms]
                    **Origin**: [Brief Etymology/History]
                    **Memory Trick**: [A fun mnemonic, rhyme, or association to help remember it${isBilingual ? ` (translated to ${targetLang})` : ''}]
                    **Examples**:
                    1. [Sentence 1]${isBilingual ? `\n   ([Translation in ${targetLang}])` : ''}
                    2. [Sentence 2]${isBilingual ? `\n   ([Translation in ${targetLang}])` : ''}
               
               2. **Mixed Practice Exercises**:
                  - **Fill in the Blanks**: 
                    1. Generate a single mixed list of numbered sentences (2 per word) where the target words are missing (use [[Blank]]). Shuffle the order.
                    2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **3-column Markdown table** to save space. (e.g. \`| 1. Answer | 2. Answer | 3. Answer |\`).
                  
                  - **True/False**: 
                    1. Generate a single mixed list of numbered statements (2 per word) about the meanings or usage of the words. Shuffle the order.
                    2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **3-column Markdown table**.
                  
                  - **One Word Substitution**: 
                    1. Generate a list of numbered descriptions or definitions (1 per word) where the answer is one of the target words.
                    2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **3-column Markdown table**.
               
               3. **Creative Finale**:
                  Write a **Short Creative Story** that naturally incorporates ALL the target words. Highlight the words in **bold**.
               
               Format: Markdown. Use emojis freely.
               `;
            } else if (imagePickerMode === 'custom') {
                systemPrompt = `
               Context/Role: ${selectedScenario?.systemPrompt || "Assistant"}
               
               User Request: "${userPrompt}"
               
               Instructions:
               - Respond strictly according to the Role defined above.
               - Analyze the provided images/documents if relevant to the request.
               `;
            } else if (imagePickerMode === 'math') {
                systemPrompt = `
               Role: Expert Math Solver.
               
               User Note: "${userPrompt}"
               
               Task: Identify the math problem in the image and SOLVE it directly.
               - Do NOT give advice or "how to".
               - Provide the final answer and the step-by-step working.
               - If it's a word problem, solve it.
               - If it's a diagram/geometry, calculate the missing values.
               
               Output Structure:
               1. **Problem**: [Transcription of the equation/problem]
               2. **Solution**: [Step-by-step calculation]
               3. **Final Answer**: [The Result]
               
               Format: Use clear text and Unicode symbols (e.g. xÂ², âˆš, Ï€, Ã·). Do NOT use LaTeX $ delimiters.
               `;
            } else if (imagePickerMode === 'teacher') {
                systemPrompt = `
               Role: Expert Teacher.
               
               User Note: "${userPrompt}"
               
               Task: Analyze the provided image(s) (diagram, textbook page, scene, or object) and teach the concept shown.
               
               STRUCTURE:
               1. **Concept Identification**: Clearly state the core subject or phenomenon shown.
               2. **Detailed Explanation**: Explain how it works or what it means in simple, educational terms.
               3. **Visual Breakdown**: Describe the key elements visible in the image and their significance.
               4. **Real-World Analogy**: Use an analogy to make the concept easier to grasp.
               5. **Key Takeaways**: A brief bulleted summary.
               
               Format: Educational Markdown. Use bold headers.
               `;
            } else if (imagePickerMode === 'story_next') { // NEW: Prompt for Story Next
                systemPrompt = `
               Role: Creative Assistant.
               User Note: "${userPrompt}"
               Task: Analyze the image and provide a concise, descriptive paragraph of the scene, action, or characters.
               Goal: This description will be used as user input to generate the next chapter of a story.
               Format: Just the description. No intro/outro.
               `;
            }

            if (displaySettings.imageGenerationEnabled) {
                if (imagePickerMode === 'story') {
                    systemPrompt += `\n\nVISUAL REQUIREMENT:\nAt the very end of your response, strictly on a new line, provide a detailed image generation prompt to create a cinematic cover illustration for this story. Format: IMAGE_PROMPT: <prompt>`;
                } else if (imagePickerMode === 'writer' || imagePickerMode === 'math' || imagePickerMode === 'doctor' || imagePickerMode === 'email_pro' || imagePickerMode === 'greetings_gen' || imagePickerMode === 'word_help' || imagePickerMode === 'work_organizer' || imagePickerMode === 'editorial' || imagePickerMode === 'teacher' || imagePickerMode === 'story_next') {
                    systemPrompt += `\n\nVISUAL REQUIREMENT:\nOnly if the user explicitly asks for an image, provide a prompt. Otherwise, do NOT generate an image prompt.`;
                } else {
                    systemPrompt += `\n\nVISUAL REQUIREMENT:\nAssess if a visual summary is necessary. If the analysis is basic or text-sufficient, DO NOT generate an image. Only provide an image prompt if the insights are complex and require a visual diagram or chart to be understood. If needed, format strictly on a new line at the end: IMAGE_PROMPT: <prompt>`;
                }
            }

            const contentParts = [{ text: systemPrompt }];

            const assetParts = await Promise.all(visionDraft.uris.map(async (uri: string) => {
                try {
                    const isPdf = uri.toLowerCase().endsWith('.pdf');
                    const mimeType = isPdf ? "application/pdf" : "image/jpeg";
                    let base64 = "";

                    if (uri.startsWith('data:')) {
                        base64 = uri.split(',')[1];
                    } else {
                        base64 = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.Base64 });
                    }

                    if (base64) base64 = base64.replace(/\r?\n|\r/g, '');
                    return { inlineData: { mimeType, data: base64 } };
                } catch (e: any) {
                    return null;
                }
            }));

            assetParts.forEach((part: any) => {
                if (part) contentParts.push(part);
            });

            const contents = [{ role: "user", parts: contentParts }];

            const rawResponse = await callLLM(contents, systemRole);

            if (!rawResponse || rawResponse.startsWith("Error")) {
                if (rawResponse && rawResponse.includes("Network request failed")) {
                    throw new Error("Network connection failed. Please check your internet.");
                } else if (rawResponse && rawResponse.includes("API limits")) {
                    throw new Error("API limits reached.");
                }
                throw new Error("Failed to analyze images.");
            }

            let responseText = rawResponse;
            let generatedImage = null;

            if (displaySettings.imageGenerationEnabled) {
                const imgMatch = responseText.match(/IMAGE_PROMPT:\s*(.*)/);
                if (imgMatch) {
                    const imgPrompt = imgMatch[1].trim();
                    responseText = responseText.replace(/IMAGE_PROMPT:.*$/, '').trim();
                    setGenerationData("Creating Visual Summary...");
                    generatedImage = await generateImage(imgPrompt);
                }
            }

            // NEW: Intercept for Story Next Input Filling
            if (imagePickerMode === 'story_next') {
                setNextChapterInput(responseText);
                setAppMode('reader'); // Restore reader view
                return;
            }

            const savedImages = await Promise.all(visionDraft.uris.map((uri: string) => ensureImageIsSavedToFile(uri)));

            let title = "Vision Analysis";
            if (imagePickerMode === 'story') {
                const lines = responseText.split('\n');
                const possibleTitle = lines.find((l: string) => l.trim().startsWith('#'));
                title = possibleTitle ? possibleTitle.replace(/^#+\s*/, '') : "Story from Image";
            } else if (imagePickerMode === 'writer') {
                title = userPrompt.trim() ? `Writer: ${userPrompt.substring(0, 20)}...` : "Writer Output";
            } else if (imagePickerMode === 'email_pro') {
                title = userPrompt.trim() ? `Email: ${userPrompt.substring(0, 20)}...` : "Draft Email";
            } else if (imagePickerMode === 'work_organizer') {
                title = userPrompt.trim() ? `Organizer: ${userPrompt.substring(0, 20)}...` : "Organized Notes";
            } else if (imagePickerMode === 'greetings_gen') {
                title = userPrompt.trim() ? `Greeting: ${userPrompt.substring(0, 20)}...` : "Greeting from Image";
            } else if (imagePickerMode === 'word_help') {
                title = userPrompt.trim() ? `Vocab: ${userPrompt.substring(0, 20)}...` : "Extracted Vocabulary";
            } else if (imagePickerMode === 'editorial') {
                title = userPrompt.trim() ? `Editorial: ${userPrompt.substring(0, 20)}...` : "Editorial Piece";
            } else if (imagePickerMode === 'doctor') {
                title = userPrompt.trim() ? `Dr: ${userPrompt.substring(0, 15)}...` : "Symptom Analysis";
            } else if (imagePickerMode === 'math') {
                title = userPrompt.trim() ? `Math: ${userPrompt.substring(0, 15)}...` : "Math Solution";
            } else if (imagePickerMode === 'teacher') {
                title = userPrompt.trim() ? `Lesson: ${userPrompt.substring(0, 15)}...` : "Visual Lesson";
            } else if (imagePickerMode === 'custom') {
                title = `${selectedScenario?.title}: ${userPrompt.substring(0, 15)}...`;
            } else {
                title = userPrompt.trim() ? `Vision: ${userPrompt.substring(0, 20)}...` : "Vision Analysis";
            }

            const newSession = {
                id: generateId(),
                timestamp: new Date().toISOString(),
                messages: [{ role: "ai", content: responseText }],
                title: title,
                toolId: targetToolId,
                images: savedImages,
                image: generatedImage,
                translations: { [displaySettings.language]: responseText },
                language: displaySettings.language
            };

            await persistSession(newSession);
            loadHistorySession(newSession, (imagePickerMode === 'story' || imagePickerMode === 'writer' || imagePickerMode === 'custom' || imagePickerMode === 'math' || imagePickerMode === 'work_organizer' || imagePickerMode === 'editorial' || imagePickerMode === 'email_pro' || imagePickerMode === 'greetings_gen' || imagePickerMode === 'word_help' || imagePickerMode === 'doctor' || imagePickerMode === 'teacher') ? 'idle' : 'vision');

        } catch (e: any) {
            console.error("Vision Request Error", e);
            const msg = (e as Error).message || "Could not analyze the images.";
            Alert.alert("Analysis Failed", msg);
            setAppMode("idle");
        } finally {
            setGenerationData(null);
            setVisionDraft({ uris: [], prompt: "" });
        }
    };

    const handleStartScenario = async () => {
        const { id, type } = selectedScenario;

        if (id === "visual_learner") {
            setImagePickerMode('vision');
            setVisionDraft({ uris: [], prompt: "" });
            setShowImageSourceModal(true);
            return;
        }

        if (!schoolConfig.input.trim() && id !== "examiner") { Alert.alert("Input Required", "Please enter a topic."); return; }

        if (selectedScenario.isCustom) {
            setAppMode("generating");
            setGenerationData(`${selectedScenario.title} is thinking...`);

            const currentInput = schoolConfig.input;
            setSchoolConfig((prev: any) => ({ ...prev, input: "" }));

            let prompt = "";

            if (teacherMode === 'discussion') {
                prompt = `
             Context/Role: ${selectedScenario.systemPrompt}
             
             User Request: "${currentInput}"
             
             Task: Discuss this request with the user through a **Q&A Dialogue** or **Conversation**.
             
             Instructions:
             - Respond strictly according to the Role defined above.
             - Engage in a dialogue format (e.g. User: ..., [Role Name]: ...).
             - Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.
             `;
            } else {
                prompt = `
             Context/Role: ${selectedScenario.systemPrompt}
             
             User Request: "${currentInput}"
             
             Instructions:
             - Respond strictly according to the Role defined above.
             - Format the output nicely using Markdown (headers, bullet points).
             `;
            }

            const visualPrompt = prompt + `\n\nVISUAL REQUIREMENT:\nAt the very end of your response, strictly on a new line, provide a detailed image generation prompt to create a relevant cover image, diagram, or infographic that visually explains the concept. Format: IMAGE_PROMPT: <prompt>`;

            const rawContent = await callLLM(visualPrompt, selectedScenario.title);

            if (rawContent.startsWith("Error")) {
                setGenerationData(null);
                setAppMode("setup");
                setSchoolConfig((prev: any) => ({ ...prev, input: currentInput }));
                Alert.alert("Generation Failed", rawContent);
                return;
            }

            let content = rawContent;
            let image = null;
            const imgMatch = content.match(/IMAGE_PROMPT:\s*(.*)/);
            if (imgMatch) {
                const imgPrompt = imgMatch[1].trim();
                content = content.replace(/IMAGE_PROMPT:.*$/, '').trim();
                setGenerationData("Illustrating...");
                image = await generateImage(imgPrompt);
            }

            const safeTitleInput = currentInput.length > 30 ? currentInput.substring(0, 30) + "..." : currentInput;

            const newSession = {
                id: generateId(),
                timestamp: new Date().toISOString(),
                messages: [{ role: "ai", content }],
                title: `${selectedScenario.title}: ${safeTitleInput}`,
                toolId: id,
                image: image,
                translations: { [displaySettings.language]: content },
                language: displaySettings.language
            };
            await persistSession(newSession);

            loadHistorySession(newSession, 'setup');
            setGenerationData(null);
            return;
        }

        if (id === "quick_notes") {
            const title = schoolConfig.input.split('\n')[0].substring(0, 30) || "New Note";
            const newSession = {
                id: generateId(),
                timestamp: new Date().toISOString(),
                messages: [{ role: "user", content: schoolConfig.input }],
                title: title,
                toolId: id
            };
            await persistSession(newSession);

            setSchoolConfig((prev: any) => ({ ...prev, input: "" }));
            loadHistorySession(newSession);
            return;
        }

        if (id === "examiner") {
            handleStartQuiz(schoolConfig.input || "General Knowledge", false, schoolConfig.subject, false, [], null, isFlashcardMode);
            setSchoolConfig((prev: any) => ({ ...prev, input: "" }));
            return;
        }

        setAppMode("generating"); setGenerationData("Writing...");

        const currentInput = schoolConfig.input;
        setSchoolConfig((prev: any) => ({ ...prev, input: "" }));

        let lengthInstruction = "";
        switch (schoolConfig.length) {
            case "Short": lengthInstruction = "Format: Concise Cheat Sheet. Start with a direct answer (TL;DR), then bullet points. No fluff."; break;
            case "Medium": lengthInstruction = "Format: Structured & Precise. 1. Direct Answer (2-3 sentences). 2. Deep Dive Explanation. 3. Key Takeaways. Comprehensive but efficient."; break;
            case "Large": lengthInstruction = "Format: Extensive but Structured. Cover every aspect in detail (History, Mechanism, Pros/Cons), but maintain the 'Direct Answer -> Deep Dive' structure."; break;
            default: lengthInstruction = "Format: Structured & Precise. 1. Direct Answer. 2. Deep Dive. 3. Key Points.";
        }

        let complexityInstruction = "";
        switch (schoolConfig.complexity) {
            case "Basic": complexityInstruction = "Use very simple, beginner-friendly vocabulary (A1/A2 level). Short, clear sentences. Avoid jargon entirely."; break;
            case "Intermediate": complexityInstruction = "Standard tone (High School level). Use appropriate terminology but explain complex terms."; break;
            case "Advanced": complexityInstruction = "Academic/Professional tone (College level). Use sophisticated vocabulary, nuanced arguments, and technical depth."; break;
            default: complexityInstruction = "Standard difficulty.";
        }

        let prompt = "";
        let systemRole = selectedScenario.role;

        const structureInstruction = `
     STRICT RESPONSE STRUCTURE:
     1. **Direct Answer**: Start immediately with a clear, high-level summary (2-3 sentences) answering the user's input.
     2. **Deep Dive**: Detailed explanation, context, or mechanisms.
     3. **Key Points**: A bulleted list of the most important facts or takeaways.
     4. **Conclusion/Action**: A brief wrap-up or next step.
     `;

        switch (id) {
            case "ai_tutor":
                // 1. VISION HANDLING
                if (visionDraft.uris && visionDraft.uris.length > 0) {
                    setGenerationData("Analyzing images...");

                    // Prepare Content
                    const contentParts = [{
                        text: `Act as a friendly, helpful Personal Assistant. The user has sent you an image. Your task is to analyze it and answer their request in a warm, conversational, and helper-like tone. Do not just describe the image unless asked. Focus on helping the user with their goal related to the image. Request: "${currentInput}".`
                    }];

                    // Read Images
                    const assetParts = await Promise.all(visionDraft.uris.map(async (uri: string) => {
                        try {
                            let base64 = "";
                            if (uri.startsWith('data:')) {
                                base64 = uri.split(',')[1];
                            } else {
                                base64 = await fs.readAsStringAsync(uri, { encoding: fs.EncodingType.Base64 });
                            }
                            if (base64) base64 = base64.replace(/\r?\n|\r/g, '');
                            return { inlineData: { mimeType: "image/jpeg", data: base64 } };
                        } catch (e: any) { return null; }
                    }));

                    assetParts.forEach((part: any) => { if (part) contentParts.push(part); });

                    // Call LLM directly
                    const contents = [{ role: "user", parts: contentParts }];
                    let responseText = await callLLM(contents, "Personal Assistant");

                    if (!responseText || responseText.startsWith("Error")) {
                        setGenerationData(null);
                        Alert.alert("Error", "Could not analyze images.");
                        return;
                    }

                    // Save Session
                    const savedImages = await Promise.all(visionDraft.uris.map((uri: string) => ensureImageIsSavedToFile(uri)));
                    const newSession = {
                        id: generateId(),
                        timestamp: new Date().toISOString(),
                        messages: [{ role: "ai", content: responseText }],
                        title: `${selectedScenario.title}: ${currentInput.substring(0, 20)}...`,
                        toolId: id,
                        images: savedImages,
                        translations: { [displaySettings.language]: responseText },
                        language: displaySettings.language
                    };
                    await persistSession(newSession);

                    setVisionDraft({ uris: [], prompt: "" });
                    loadHistorySession(newSession, 'idle'); // Open in Reader
                    setGenerationData(null);
                    return; // EXIT FUNCTION
                }

                // 2. TEXT HANDLING (Fallthrough to standard flow)

                if (teacherMode === 'discussion') {
                    systemRole = "Personal Assistant";
                    prompt = `Act as a friendly Personal Assistant and Tutor.
                    
                    User Request: "${currentInput}"
                    
                    Task: Chat with the user to explain this or help them.
                    - Be encouraging and supportive.
                    - Use simple, clear language.
                    - Ask follow-up questions to ensure understanding.
                    - Use \`[[CONCEPT_CARD: Title]] ... [[END_CARD]]\` for any key terms, formulas, or code.
                    
                    Format: Short conversational response. End with a relevant follow-up question.`;
                } else if (teacherMode === 'lesson') {
                    systemRole = "Personal Tutor";
                    prompt = `Act as a friendly Personal Assistant.
                    
                    User Request: "${currentInput}"
                    
                    Task: Explain concepts in simple, beginner-friendly language, like easy-to-read study notes.
                    
                    Guidelines:
                    - Avoid complex jargon.
                    - Use **tables**, **charts** (using text/markdown), **diagrams**, and **bullet points** to make information visual and clear.
                    - **Bold** important key points.
                    - **CONCEPT CARD RULE**:
                      - **USAGE**: Use for formulas, code, OR key definitions in ANY subject (History, Grammar, Science, etc.).
                      - **PLACEMENT**: Insert \`[[CONCEPT_CARD]]\` **IMMEDIATELY** after determining a key concept. Do NOT group them all at the end.
                      - **CONSTRAINT**: **STRICTLY MAX 30-50 WORDS (5-10 lines)** per card. If a concept is complex, **split it into MULTIPLE separate Concept Cards**. Never write a whole chapter in one card.
                      - **CONTENT**: "Cheat Sheet" style. Title, 2-3 Bullet Points, 1 Key Formula/Date.
                      - **Example**:
                      \`[[CONCEPT_CARD: NEWTON'S 2ND LAW]]
                      **Formula**: F = ma
                      **Meaning**: Force equals mass times acceleration.
                      **Key Point**: Heavier objects need more force.
                      [[END_CARD]]\`

                    - **CHAPTER SUMMARY (Compulsory End)**:
                      - You MUST end with \`[[CONCEPT_CARD: CHAPTER SUMMARY]]\`.
                      - **Content**: A concise summary of the chapter/response (approx 30-50 words).
                      - **Intelligent Synthesis**: Summarize the *core narrative* (how concepts connect).
                      - 4-6 meaningful takeaways. Do not just list random words.
                    
                    - Structure the response logically (Intro, Key Examples, Summary).
                    
                    Logic Config:
                    - ${lengthInstruction}
                    - ${complexityInstruction}
                    
                    Format: Markdown Study Notes.`;
                } else {
                    // Safety Fallback (Default to Discussion)
                    systemRole = "Personal Assistant";
                    prompt = `Act as a friendly Personal Assistant. Request: "${currentInput}"`;
                }
                break;


            case "health_guide":
                systemRole = "Experienced Medical Doctor";
                prompt = `Act as an experienced and compassionate Medical Doctor.
             
             User Input/Symptoms: "${currentInput}"
             
             Task: Analyze the input, provide a potential diagnosis (differential), and suggest a treatment plan or next steps.
             
             STRICT CONSTRAINT: 
             At the very end of the response, you MUST hide the medical disclaimer using the toggle format:
             1. Output strictly on a new line: "[[TOGGLE_TABLE:Read Medical Disclaimer]]"
             2. Follow immediately with a Markdown table:
             | Notice |
             |---|
             | This is AI advice and not a substitute for professional emergency care. Always consult a qualified doctor. |
             
             STRUCTURE:
             1. **Clinical Analysis**: Empathetic understanding of the symptoms described.
             2. **Potential Causes**: List likely reasons (medical differential).
             3. **Immediate Advice/Remedies**: Actionable steps, home remedies, or OTC suggestions the user can take now.
             4. **When to see a specialist**: Specific red flags or warning signs that require a physical visit.
             
             Format: Professional medical advice format using Markdown. Use bold headers.`;
                break;

            case "journal_buddy":
                systemRole = "Language Editor";
                prompt = `Act as a strict Language Editor.
            Input Text: "${currentInput}"
            Task:
            1. Provide a "Corrected Version" of the text.
            2. Provide a "Change Log" listing errors found (Type: Grammar/Spelling/Punctuation) and why it was changed.
            Format: Markdown, with bold headings for "Corrected Version" and "Change Log".`;
                break;

            case "math_solver":
                systemRole = "Math Expert";
                prompt = `Act as an expert Math Solver.
             
             Problem: "${currentInput}"
             
             Task: Solve the problem directly. Do NOT give advice on how to solve it. Provide the solution.
             
             Structure:
             1. **Final Answer**: [The Result]
             2. **Step-by-Step Solution**: [Detailed calculations and steps]
             
             Format: Use clear text and Unicode math symbols (e.g. xÂ², âˆš, Ï€, Ã·). Do NOT use LaTeX $ delimiters.`;
                break;

            case "email_pro":
                systemRole = "Professional Communication Expert";
                prompt = `Act as a professional email writer.
             
             User Input: "${currentInput}"
             
             Task: Write a complete, polished, and professional email based on the user's input.
             
             Constraints:
             - Do NOT provide advice, analysis, or "Key Points".
             - Output ONLY the email content (Subject, Body, Sign-off).
             - Tone: Professional, clear, and effective.
             
             Format:
             **Subject:** [Compelling Subject Line]
             
             [Salutation],
             
             [Body Paragraphs]
             
             [Sign-off],
             [Placeholder for Name]`;
                break;

            case "greetings_gen":
                systemRole = "Creative Writer & Poet";
                let gPrompt = "";

                if (greetingsMode === 'quote') {
                    gPrompt = `Act as a Motivational Speaker.
                 Topic: "${currentInput}"
                 Task: Generate 5-7 powerful, inspiring, and unique quotes on this topic.
                 Format: Bulleted list. Use bold for key phrases.`;
                } else if (greetingsMode === 'shayari') {
                    const targetLang = displaySettings.language;
                    gPrompt = `Act as a Shayar (Poet).
                 Topic/Emotion: "${currentInput}"
                 Task: Write 3 beautiful Shayari (Couplets) on this topic in ${targetLang}.
                 Requirements:
                 - Output the Shayari STRICTLY in ${targetLang}.
                 - Do NOT provide translations, transliterations, or meanings in other languages.
                 Format: Clear sections for each Shayari.`;
                } else {
                    gPrompt = `Act as a Creative Greetings Writer.
                 Occasion/Recipient: "${currentInput}"
                 Task: Generate a variety of greeting options for this occasion.
                 Logic Config: - ${complexityInstruction}
                 OUTPUT STRUCTURE:
                 1. **Short & Sweet**: A quick, punchy message (Social Media style).
                 2. **Heartfelt & Emotional**: A longer, warmer message (Card style).
                 3. **Professional/Formal**: A polite, respectful message.
                 4. **Funny/Witty**: A humorous take.
                 5. **Quote**: A relevant famous quote to include.
                 Format: Markdown. Use emojis freely.`;
                }
                prompt = gPrompt;
                break;

            case "word_help":
                const targetLang = displaySettings.language;
                const isBilingual = targetLang !== 'English';

                systemRole = "Vocabulary Expert";
                prompt = `Act as a creative Vocabulary Expert.
             
             User Request: "${currentInput}"
             
             Instructions:
             - If the user provides specific words, teach those.
             - If the user asks for "random" or a category of words, select 3-5 challenging and interesting words yourself that fit the request.
             
             Task: 
             ${isBilingual ? `\nBILINGUAL MODE: The user's primary language is ${targetLang}. Provide definitions, memory tricks, and example translations in BOTH English and ${targetLang}.` : ''}
             
             1. **Deep Dive Definitions**: 
                - STRICTLY DO NOT USE TABLES. Use a clear, readable list format.
                - For EACH word, use this format:
                  ### [Word]
                  **Meaning**: [Definition${isBilingual ? ` / Definition in ${targetLang}` : ''}]
                  **Part of Speech**: [e.g. Verb, Noun, Adjective]
                  **Forms/Degree**: [If Verb: V1, V2, V3, -ing; If Adj: Positive/Comparative/Superlative; Else: Plurals or N/A]
                  **Synonyms**: [List 2-3 common synonyms]
                  **Antonyms**: [List 2-3 common antonyms]
                  **Origin**: [Brief Etymology/History]
                  **Memory Trick**: [A fun mnemonic, rhyme, or association${isBilingual ? ` (translated to ${targetLang})` : ''}]
                  **Examples**:
                  1. [Sentence 1]${isBilingual ? `\n   ([Translation in ${targetLang}])` : ''}
                  2. [Sentence 2]${isBilingual ? `\n   ([Translation in ${targetLang}])` : ''}
             
             2. **Mixed Practice Exercises**:
                - **Fill in the Blanks**: 
                  1. Generate a single mixed list of numbered sentences (2 per word) where the target words are missing (use [[Blank]]). Shuffle the order so words are mixed.
                  2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **3-column Markdown table** to save space. (e.g. \`| 1. Answer | 2. Answer | 3. Answer |\`).
                
                - **True/False**: 
                  1. Generate a single mixed list of numbered statements (2 per word) about the meanings or usage of the words. Shuffle the order.
                  2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **3-column Markdown table**.
                
                - **One Word Substitution**: 
                  1. Generate a list of numbered descriptions or definitions (1 per word) where the answer is one of the target words.
                  2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **3-column Markdown table**.
             
             3. **Creative Finale**:
                Write a **Short Creative Story** that naturally incorporates ALL the target words provided. Highlight the target words in **bold** within the story.
             
             Format: Markdown. Use emojis freely.`;
                break;

            case "study_planner":
                systemRole = "Expert Curriculum Designer";
                prompt = `Act as an expert Study Coach and Curriculum Designer.
             
             User Goal/Input: "${currentInput}"
             
             Task: Create a structured, actionable **Study Plan** or **Learning Path** based on the user's request.
             
             Instructions:
             1. **Analyze the Request**: Identify the subject (e.g., Python, History) and any time constraints mentioned (e.g., "in 2 weeks", "for exams tomorrow"). If no time is mentioned, assume a standard pace (e.g., 4 weeks) or a crash course depending on context.
             2. **Structure the Plan**: Break it down logically (e.g., Day-by-Day for short term, Week-by-Week for long term).
             3. **Be Specific**: Don't just say "Learn basics". Say specific topics like "Variables, Loops, and Functions".
             
             Output Structure:
             **Goal**: [Clear Goal Statement]
             **Timeline**: [Estimated Duration]
             
             ### Phase 1: Foundations (Week 1 / Days 1-X)
             - [Topic 1]: [Brief description]
             - [Topic 2]: [Brief description]
             - **Action Item**: [Specific practice task]
             
             ### Phase 2: Core Concepts
             ...
             
             ### Phase 3: Advanced / Application
             ...
             
             ### Recommended Resources
             - [Resource 1]
             - [Resource 2]
             
             **Success Milestone**: How will the user know they are ready?
             
             Format: Markdown. Use bold headers and lists.`;
                break;

            case "debate_coach":
                systemRole = "Debate Moderator";
                prompt = `Act as a skilled Debate Moderator and Scriptwriter.
             
             Topic: "${currentInput}"
             
             Task: Create a lively, balanced, and intellectual debate script on the topic.
             
             Instructions:
             1. **Define Sides**: Create two distinct characters/personas with opposing views (e.g., Proponent vs. Opponent, or Optimist vs. Skeptic). Give them names or titles.
             2. **Structure**:
                - **Moderator Intro**: Briefly introduce the topic and the speakers.
                - **Opening Statements**: Each side presents their core argument.
                - **Rebuttal Round**: They directly address each other's points (back-and-forth dialogue).
                - **Closing**: A summary or final thought from each.
             3. **Style**: Use dialogue format. Make it engaging, logical, and persuasive on both sides.
             
             Format: Markdown. Use bold names for speakers (e.g. **Proponent:**).
             `;
                break;

            case "grammar_guide":
                const grammarTargetLang = displaySettings.language;

                if (teacherMode === 'discussion') {
                    systemRole = `Grammar Coach (${grammarTargetLang})`;
                    prompt = `Act as a friendly Grammar Coach specialized in ${grammarTargetLang} Grammar.
                Topic: "${currentInput}"
                
                Task: Discuss this grammar topic specifically regarding the ${grammarTargetLang} language through a **Q&A Dialogue**.
                
                Logic Config:
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Topic**: Brief Intro to the concept in ${grammarTargetLang}.
                2. **Dialogue**:
                   - **Student**: [Asks about the grammar rule in ${grammarTargetLang}]
                   - **Coach**: [Explains clearly in ${grammarTargetLang}]
                   - **Student**: [Asks for examples]
                   - **Coach**: [Provides examples in ${grammarTargetLang}]
                3. **Summary**: Quick recap in ${grammarTargetLang}.
                
                Format: Standard Markdown. Use bold names for speakers (e.g. **Coach:**). STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = `Expert Grammarian (${grammarTargetLang})`;
                    prompt = `Act as an Expert Grammarian for the ${grammarTargetLang} language.
                Topic: "${currentInput}"
                
                Task: Write a complete **Book Chapter** on this grammar topic within ${grammarTargetLang} grammar.
                
                Logic Config:
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Chapter Title**: Professional and clear in ${grammarTargetLang}.
                2. **Overview**: A brief introduction in ${grammarTargetLang}.
                3. **Section 1: The Core Rules**: The fundamental definition and structure in ${grammarTargetLang}.
                4. **Section 2: Usage in Context**: Detailed situations where this grammar is applied in ${grammarTargetLang}.
                5. **Section 3: Examples**: Correct examples in ${grammarTargetLang}.
                6. **Advanced Notes**: Nuances in ${grammarTargetLang}.
                7. **Chapter Summary**: Key takeaways in bullet points in ${grammarTargetLang}.
                
                Format: Standard Markdown. Use clear headings (##) for sections. Do not use the 'Direct Answer' summary style.`;
                }
                break;

            case "idiom_guide":
                const idiomTargetLang = displaySettings.language;
                const isIdiomBilingual = idiomTargetLang !== 'English';

                if (teacherMode === 'discussion') {
                    systemRole = "Conversation Coach";
                    prompt = `Act as a Conversation Coach helping a student sound more native.
                User Request: "${currentInput}"
                
                Instructions:
                - If the user asks for a category (e.g., "Business idioms"), select 3 suitable idioms yourself.
                - If the user provides specific idioms, use those.
                
                Task: Teach these idioms through a **Natural Dialogue**.
                ${isIdiomBilingual ? `\nBILINGUAL MODE: The user's primary language is ${idiomTargetLang}. Provide explanations in BOTH English and ${idiomTargetLang} where helpful, but keep the dialogue natural.` : ''}
                
                Logic Config:
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Context**: Setting the scene.
                2. **Dialogue**: Create a conversation between two people (e.g., friends or colleagues) where the selected idioms are used naturally in context.
                3. **Breakdown**: After the dialogue, explain the idioms used within the conversation${isIdiomBilingual ? ` (Provide meanings in English and ${idiomTargetLang})` : ''}.
                
                Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = "Idiom & Phrase Expert";
                    prompt = `Act as an expert in Idioms and Phrases.
                User Request: "${currentInput}"
                
                Instructions:
                - If the user asks for a category (e.g. "Teach me food idioms"), select 3-5 interesting idioms fitting that category.
                - If the input is a specific idiom (e.g. "Break a leg"), explain that specific one.
                - If the input is a single word (e.g. "Cat"), list idioms containing that word.
                
                Task: Create a complete lesson.
                ${isIdiomBilingual ? `\nBILINGUAL MODE: The user's primary language is ${idiomTargetLang}. You MUST provide Meanings and Examples in BOTH English and ${idiomTargetLang}.` : ''}

                1. **Deep Dive Explanations**:
                   For EACH idiom selected, use this format:
                   ### [Idiom Name]
                   **Meaning**: [Definition${isIdiomBilingual ? ` / Definition in ${idiomTargetLang}` : ''}]
                   **Origin**: [Brief origin/history if interesting]
                   > Example: "[Sentence]"${isIdiomBilingual ? `\n     > ([Translation in ${idiomTargetLang}])` : ''}

                2. **Practice Exercises**:
                   - **Fill in the Blanks**: 
                     1. Generate a single mixed list of numbered sentences (1-2 per idiom) where the idiom is missing (use [[Blank]]). Shuffle the order.
                     2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **Markdown table** to save space. (e.g. \`| 1. Answer | 2. Answer |\`).
                   
                   - **Match the Meaning / Usage**: 
                     1. Generate a list of numbered scenarios (1 per idiom) where the user must guess which of the taught idioms fits best.
                     2. **Answers**: Immediately below the list, output the line "[[TOGGLE_TABLE]]" and then present the answers in a **Markdown table**.

                3. **Creative Finale**:
                   Write a short, engaging paragraph or story that naturally uses ALL the idioms taught above. Highlight the idioms in **bold**.
                
                Logic Config:
                - ${complexityInstruction}
                
                Format: Standard Markdown. Use headers (###) for idiom names and blockquotes (>) for examples.`;
                }
                break;

            case "ai_for_everyone":
                if (teacherMode === 'discussion') {
                    systemRole = "AI Guide";
                    prompt = `Act as a friendly AI Guide chatting with a curious user.
                Topic: "${currentInput}"
                
                Task: Explain how AI impacts this area through a **Q&A Dialogue**.
                
                Logic Config:
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Intro**: Casual greeting.
                2. **Dialogue**:
                   - **User**: [Asks how AI is used in this field]
                   - **AI Guide**: [Explains with simple analogies]
                   - **User**: [Asks about privacy or future trends]
                   - **AI Guide**: [Answers honestly and simply]
                3. **Takeaway**: One main thing to remember.
                
                Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = "AI Literacy Guide";
                    prompt = `Act as a friendly AI Literacy Guide.
                Topic: "${currentInput}"
                
                Task: Write a comprehensive **Educational Article** explaining how AI works in this context.
                
                Logic Config:
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Title**: An engaging title (e.g., "How AI Powers Your [Topic]").
                2. **The Daily Experience**: A relatable introduction describing the user experience.
                3. **Behind the Scenes**: Simple explanation of the technology/algorithms involved.
                4. **Real-World Impact**: Why it matters, benefits, and potential risks/ethics.
                5. **Future Outlook**: What might change in the future?
                6. **Fun Fact / Key Takeaway**: A memorable closing point.
                
                Format: Standard Markdown article format. Do NOT use the 'Direct Answer' summary style.`;
                }
                break;

            case "tech_guide":
                if (teacherMode === 'discussion') {
                    systemRole = "Tech Mentor";
                    prompt = `Act as a Senior Tech Mentor having a coffee chat with a mentee.
                Topic: "${currentInput}"
                
                Task: Discuss this technology or career topic through a **Mentorship Dialogue**.
                
                Logic Config:
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Topic**: Setting the stage.
                2. **Dialogue**:
                   - **Mentee**: [Asks advice or technical questions]
                   - **Mentor**: [Provides practical, experienced-based advice]
                   - **Mentee**: [Asks about best practices or pitfalls]
                   - **Mentor**: [Shares "war stories" or pro-tips]
                3. **Action Plan**: 3 things the mentee should do next.
                
                Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = "Senior Software Architect & Tech Mentor";
                    prompt = `Act as a Senior Software Architect and Tech Mentor.
                Topic/Input: "${currentInput}"
                
                Task: Write a comprehensive **Technical Article** on this topic.
                
                Logic Config:
                - ${lengthInstruction}
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Title**: A professional and engaging title.
                2. **Introduction**: Context, definition, and relevance.
                3. **Technical Deep Dive**: Architecture, inner workings, or core concepts.
                4. **Implementation/Usage**: Practical examples, code snippets, or step-by-step guides.
                5. **Best Practices**: Tips, pros/cons, or security considerations.
                6. **Conclusion**: Summary and next steps.
                
                Format: Standard Markdown article format. Do NOT use the 'Direct Answer' summary style.`;
                }
                break;

            case "ai_usage":
                if (teacherMode === 'discussion') {
                    systemRole = "Productivity Coach";
                    prompt = `Act as an AI Productivity Coach brainstorming with a client.
                 Topic: "${currentInput}"
                 
                 Task: Explore how to use AI for this task through a **Strategy Session Dialogue**.
                 
                 Logic Config:
                 - ${complexityInstruction}
                 
                 STRUCTURE:
                 1. **Goal**: Define what the user wants to achieve.
                 2. **Dialogue**:
                    - **Client**: "I want to use AI to..."
                    - **Coach**: "Here is a strategy. Have you tried prompting like this...?"
                    - **Client**: "What if I want...?"
                    - **Coach**: "Then tweak the prompt this way..."
                 3. **Prompt Library**: List the specific prompts discussed.
                 
                 Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = "Expert AI Productivity Strategist";
                    prompt = `Act as an Expert AI Productivity Strategist.
                 Topic: "${currentInput}"
                 Task: Write a practical **"How-To" Guide** on leveraging AI for this specific task.
                 
                 Logic Config:
                 - ${lengthInstruction}
                 - ${complexityInstruction}
                 
                 STRUCTURE:
                 1. **Title**: A clear, actionable title (e.g., "Mastering [Topic] with AI").
                 2. **Strategic Value**: Why use AI for this? (Efficiency, Creativity, etc.).
                 3. **The Workflow**: Step-by-step process to execute this task with AI tools.
                 4. **The 'Golden' Prompt**: Provide concrete prompt templates the user can copy.
                 5. **Refinement & Tips**: How to iterate if the first result isn't perfect.
                 6. **Conclusion**: Encouraging closing.
                 
                 Format: Standard Markdown article format. Do NOT use the 'Direct Answer' summary style.`;
                }
                break;

            case "teacher":
                if (teacherMode === 'lesson') {
                    systemRole = "Expert Lecturer";
                    prompt = `Act as an expert Teacher delivering a comprehensive Lesson.
                 Topic: "${currentInput}"
                 
                 Task: Explain this topic clearly and structuredly as a **Lecture Note**.
                 
                 Logic Config:
                 - ${lengthInstruction}
                 - ${complexityInstruction}
                 
                 STRUCTURE:
                 1. **Lesson Title**: A clear title for the topic.
                 2. **Learning Objectives**: Briefly list what the student will understand by the end.
                 3. **Core Concept**: The main definition or explanation of the topic.
                 4. **Detailed Breakdown**: Explain the mechanisms, history, or components using headers, analogies, and examples.
                 5. **Common Misconceptions**: Clarify what people often get wrong.
                 6. **Lesson Summary**: Key takeaways in bullet points.
                 
                 Format: Standard Markdown. Use headers (##) and bullet points. Do NOT use dialogue format.`;
                } else {
                    systemRole = "Interactive Teacher";
                    prompt = `Act as an expert Teacher conducting a one-on-one session with a curious Student.
                 Topic: "${currentInput}"
                 
                 Task: Explain this topic completely through a **Q&A Dialogue**.
                 
                 Logic Config:
                 - ${lengthInstruction}
                 - ${complexityInstruction}
                 
                 STRUCTURE:
                 1. **Title**: Class Topic.
                 2. **Introduction**: Brief context setting.
                 3. **Dialogue Session**:
                    - **Student**: [Asks a fundamental question about the topic]
                    - **Teacher**: [Provides a clear, detailed, and engaging answer]
                    - **Student**: [Asks a logical follow-up question or asks for clarification]
                    - **Teacher**: [Explains further, using analogies or real-world examples]
                    (Continue this Q&A pattern to comprehensively cover the topic)
                 4. **Summary**: A final wrap-up of the key takeaways from the lesson.
                 
                 Format: Standard Markdown. Use bold "**Student:**" and "**Teacher:**" to denote the speakers clearly. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                }
                break;

            case "ml_tutor":
                if (teacherMode === 'discussion') {
                    systemRole = "AI Mentor";
                    prompt = `Act as an AI Mentor explaining concepts to a junior developer.
                 Topic: "${currentInput}"
                 
                 Task: Demystify this ML concept through a **Technical Q&A Dialogue**.
                 
                 Logic Config:
                 - ${complexityInstruction}
                 
                 STRUCTURE:
                 1. **Concept**: The topic.
                 2. **Dialogue**:
                    - **Dev**: "I don't get how X works."
                    - **Mentor**: "Think of it like Y..." (Use analogies)
                    - **Dev**: "But what about Z?"
                    - **Mentor**: "Good question. Z happens because..."
                 3. **Code Snippet**: If applicable, show a small Python snippet in the dialogue.
                 
                 Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = "Principal AI Scientist";
                    prompt = `Act as a Principal AI Scientist.
                 Topic: "${currentInput}"
                 Task: Write a comprehensive **Technical Article** on this machine learning topic.
                 
                 Logic Config:
                 - ${lengthInstruction}
                 - ${complexityInstruction}
                 
                 STRUCTURE:
                 1. **Title**: A professional title.
                 2. **Introduction**: Definition, context, and why it matters.
                 3. **Core Concepts / Theory**: The math, logic, or mechanism behind it.
                 4. **Architecture / Implementation**: How it is built or used (diagram descriptions or pseudo-code).
                 5. **Applications & State-of-the-Art**: Real-world use cases and modern advancements.
                 6. **Conclusion**: Summary and future outlook.
                 
                 Format: Standard Markdown article format. Do NOT use the 'Direct Answer' summary style.`;
                }
                break;

            case "prompt_engineer":
                if (teacherMode === 'discussion') {
                    systemRole = "Prompt Doctor";
                    prompt = `Act as a Prompt Doctor in a workshop.
                Topic/Prompt: "${currentInput}"
                
                Task: Analyze and improve prompts through a **Consultation Dialogue**.
                
                Logic Config:
                - ${complexityInstruction}
                
                STRUCTURE:
                1. **Diagnosis**: "Here is what's tricky about the original idea."
                2. **Dialogue**:
                   - **User**: "I tried this prompt but it failed."
                   - **Doctor**: "That's because it lacks context. Try adding..."
                   - **User**: "Like this?"
                   - **Doctor**: "Better, but let's refine the constraints."
                3. **Final Prescription**: The polished prompt.
                
                Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = "Lead Prompt Engineer";
                    prompt = `Act as a Lead Prompt Engineer.
                Topic/Input: "${currentInput}"
                
                Task: Write a technical **Prompt Engineering Guide** or **Optimization Analysis**.
                
                STRUCTURE:
                1. **Title**: Technical title regarding the prompt technique or optimization.
                2. **Concept / Diagnosis**: Define the technique or analyze the user's draft prompt.
                3. **The Optimized Prompt**: Provide the high-quality prompt clearly in a code block.
                4. **Mechanics**: Explain *why* this prompt works (Chain of Thought, Delimiters, Persona, etc.).
                5. **Advanced Variables**: How to tweak parameters (Temperature, Top-P) or modify the prompt for different models.
                6. **Conclusion**: Final best practices.
                
                Format: Standard Markdown article format. Do NOT use the 'Direct Answer' summary style.`;
                }
                break;

            case "writer":
                if (teacherMode === 'discussion') {
                    systemRole = "Writing Coach";
                    prompt = `Act as a Writing Coach brainstorming with an author.
                 Topic/Draft: "${currentInput}"
                 
                 Task: Discuss ideas, plot points, or improvements through a **Coaching Session**. Do NOT write the full content yet.
                 
                 Logic Config:
                 - ${complexityInstruction}
                 
                 STRUCTURE:
                 1. **Session Goal**: What are we solving?
                 2. **Dialogue**:
                    - **Author**: "I'm stuck on this scene."
                    - **Coach**: "What if the character did X instead?"
                    - **Author**: "That works, but what about the theme?"
                    - **Coach**: "You could weave that in by..."
                 3. **Next Steps**: Bullet points for the author to write.
                 
                 Format: Standard Markdown. Use bold names for speakers. STRICTLY NO MARKDOWN TABLES for the dialogue.`;
                } else {
                    systemRole = "Professional Writer";
                    prompt = `Act as a Professional Writer.
                 
                 User Request: "${currentInput}"
                 
                 Instructions:
                 1. **Analyze the Request**: Determine the desired format (e.g., Letter, Application, Email, Story, Review, Speech) from the input.
                 2. **If Format is Specified**: Strictly follow the standard conventions, tone, and structure for that specific format. (e.g., for a formal letter, use date, salutation, body, sign-off).
                 3. **If No Format Specified (General Topic)**: Default to a high-quality **Article** structure with headlines and subheadings.
                 
                 Logic Config:
                 - ${lengthInstruction}
                 - ${complexityInstruction}
                 
                 Format: Standard Markdown. Focus on flow, engagement, and depth.`;
                }
                break;

            case "summarizer":
                systemRole = "Expert Summarizer";
                prompt = `Act as a strict Summarizer.
             
             INPUT TEXT:
             """
             ${currentInput}
             """
             
             TASK:
             Summarize the content above. 
             - If the input is a long text: Condense it into key points and a short summary.
             - If the input is a short topic (e.g. "AI"): Provide a brief executive summary of the concept.
             
             STRICT CONSTRAINT: Do not generate an essay. Do not simply explain the topic. Focus on compressing the input information provided.
             
             OUTPUT STRUCTURE:
             **TL;DR**: [1 sentence overview]
             
             **Key Takeaways**:
             * [Point 1]
             * [Point 2]
             * [Point 3]
             
             **Conclusion**: [Final thought]
             
             Format: Markdown.`;
                break;

            case "story_generator":
                systemRole = "Essayist";
                prompt = `Write an essay/story about "${currentInput}".
             
             Logic Config:
             - ${lengthInstruction} (If Short/Medium, keep it focused. If Large, expand fully.)
             - Vocabulary: Use language complexity that matches the user's profession and bio instructions. If no profile is available, use simple, beginner-friendly words (A2/B1 level).
             - ${complexityInstruction}
             
             Format: Plain text only, organized with clear headings. NEVER use $$ signs.`;
                break;

            case "work_organizer":
                systemRole = "Expert Organizer & Project Manager";
                prompt = `Act as an Expert Organizer and Project Manager.
             
             User Input:
             """
             ${currentInput}
             """
             
             Task: Structure and organize this content effectively.
             
             Logic Config:
             - ${complexityInstruction}
             
             STRUCTURE (Adaptive):
             1. **Overview**: Brief context of what this information is.
             2. **The Structured List**: Use whichever format fits best (Meeting Minutes, Prioritized To-Do, Timeline, or Categorized Sections).
             3. **Action Plan / Next Steps**: A clear list of what needs to be done.
             
             Format: Clean Markdown. Use headers (##), bullet points, and checkboxes (- [ ]) for actionable items.`;
                break;

            case "editorial_writer":
                systemRole = "Senior Chief Editor";

                let exclusionList = "";
                if (currentInput.includes("Identify a random significant global news event")) {
                    const existingTopics = Object.values(chatSessions)
                        .filter((s: any) => s.toolId === 'editorial_writer')
                        .map((s: any) => {
                            const parts = s.title.split(':');
                            const topic = parts.length > 1 ? parts.slice(1).join(':').trim() : s.title;
                            return topic;
                        })
                        .filter(t => t && !t.includes("Identify a random"))
                        .slice(0, 20)
                        .join(', '); // FIX: Properly chained join

                    if (existingTopics) {
                        exclusionList = `\n\nCONSTRAINT: You have already written editorials on the following topics: [${existingTopics}]. You MUST select a DIFFERENT news event/topic.`;
                    }
                }

                prompt = `Act as a Senior Chief Editor for a major publication.
             
             Topic: "${currentInput}"${exclusionList}
             
             Task: Write a compelling **Editorial Piece**.
             
             Logic Config:
             - ${lengthInstruction}
             - ${complexityInstruction}
             
             VOCABULARY REQUIREMENT:
             - Prioritize the user's specific Bio/Context instructions for tone and vocabulary.
             - Default (if profile is sparse): Use a rich mix of **intermediate and advanced vocabulary** to elevate the writing style. Choose precise, impactful, and academic terms suitable for high-level reading comprehension (e.g., "substantiate", "mitigate", "juxtaposition").
             
             STRUCTURE:
             1. **Headline**: Catchy, provocative, and relevant.
             2. **The Lede**: Hook the reader immediately and state the core argument or theme clearly.
             3. **The Argument**: Develop the main point with strong evidence, logic, and rhetorical flair.
             4. **The Counter**: Acknowledge the opposing view briefly but dismantle it or provide a stronger alternative.
             5. **The Kicker**: A strong concluding thought, call to action, or memorable closing line.
             
             
             Tone: Authoritative, persuasive, and polished.
             Format: Standard Journalism Markdown. Use bold for the Lede.`;


                break;

            case "help_guide_char":
                systemRole = selectedScenario.role || "ReaderApp Guide";
                prompt = `${selectedScenario.prompt}
        
        User Request: "${currentInput}"
        
        Task: Assist the user with their request regarding the app features.
        - Be helpful, clear, and concise.
        - If they ask about a specific tool, explain how to use it.
        - If they are confused, offer step-by-step guidance.
        `;
                break;

            default:
                prompt = `Write about ${currentInput}. 
             
             Logic Config:
                - ${lengthInstruction}
                - ${complexityInstruction}
             
             ${structureInstruction} `;
                break;
        }

        prompt += `\n\nVISUAL REQUIREMENT: \nAssess if this topic REQUIRES a visual aid to be understood.If it is a basic concept, definition, or text - heavy explanation, DO NOT generate an image.Only provide an image generation prompt if the concept is complex, spatial, or abstract(e.g.architectures, anatomy, physics diagrams) and hard to understand without it.If needed, provide it strictly on a new line at the end: IMAGE_PROMPT: <prompt>`;

        const rawContent = await callLLM(prompt, systemRole);

        // NEW: Check for error before saving
        if (rawContent.startsWith("Error")) {
            setGenerationData(null);
            setAppMode("setup");
            setSchoolConfig((prev: any) => ({ ...prev, input: currentInput })); // Restore input
            Alert.alert("Generation Failed", rawContent);
            return;
        }

        let content = rawContent;
        let image = null;
        const imgMatch = content.match(/IMAGE_PROMPT:\s*(.*)/);
        if (imgMatch) {
            const imgPrompt = imgMatch[1].trim();
            content = content.replace(/IMAGE_PROMPT:.*$/, '').trim();
            setGenerationData("Painting...");
            image = await generateImage(imgPrompt);
        }

        // Clean and truncate input for the title to keep history clean
        const cleanInput = currentInput.replace(/\n/g, " ").trim();
        let safeTitleInput = cleanInput.length > 50 ? cleanInput.substring(0, 50) + "..." : cleanInput;

        // NEW: Intelligent Title Extraction
        // Attempt to extract a real title from the generated content to replace generic user prompts
        const titleMatchers = [
            /\*\*Headline\*\*:\s*(.*)/i,      // For Editorials
            /^Headline:\s*(.*)/im,            // For Editorials (Plain text)
            /\*\*Subject\*\*:\s*(.*)/i,       // For Emails
            /\*\*Title\*\*:\s*(.*)/i,         // Generic
            /^#\s+(.*)/m,                     // Markdown H1
            /^##\s+(.*)/m,                    // Markdown H2
            /^###\s+(.*)/m                    // Markdown H3
        ];

        for (const matcher of titleMatchers) {
            const match = content.match(matcher);
            if (match && match[1]) {
                const extracted = match[1].replace(/[\*_]/g, '').trim(); // Remove formatting

                // Sanity check: Ensure captured title is valid and not too long
                const lowerExtracted = extracted.toLowerCase();
                const invalidTitles = [
                    "introduction",
                    "editorial assessment",
                    "comprehension check",
                    "vocabulary analysis",
                    "cloze test"
                ];

                if (
                    extracted &&
                    extracted.length > 2 &&
                    extracted.length < 80 &&
                    !invalidTitles.some(bad => lowerExtracted.includes(bad))
                ) {
                    safeTitleInput = extracted;
                    break;
                }
            }
        }

        const newSession = {
            id: generateId(),
            timestamp: new Date().toISOString(),
            messages: [{ role: "ai", content }],
            title: `${selectedScenario.title}: ${safeTitleInput}`,
            toolId: id,
            image: image,
            translations: { [displaySettings.language]: content },
            language: displaySettings.language
        };
        await persistSession(newSession);

        loadHistorySession(newSession, 'setup'); // Pass 'setup' to indicate we came from tool setup
        setGenerationData(null);
    };

    // ... (getDictionaryData and subsequent functions)
    // Updated to support specific target language
    // NEW: Batch Definition Fetching
    const fetchBatchDefinitions = async (words: string[], targetLang: string | null = null) => {
        if (!words || words.length === 0) return [];

        const userLanguages = displaySettings.availableLanguages && displaySettings.availableLanguages.length > 0
            ? displaySettings.availableLanguages
            : [displaySettings.language || "English"];

        let languageInstruction = "";
        if (userLanguages.length === 1) {
            languageInstruction = `Provide definitions and examples strictly in ${userLanguages[0]}.`;
        } else {
            const langsToInclude = userLanguages.join(' and ');
            languageInstruction = `Provide definitions and examples bilingually in ${langsToInclude}. Ensure definitions are SINGLE STRINGS (e.g. "Def 1 / Def 2"). Do NOT return objects for definitions.`;
        }

        const prompt = `
        Task: Analyze the following list of words: ${JSON.stringify(words)}.
        User's Available Languages: ${userLanguages.join(', ')}.
        ${languageInstruction}

        INSTRUCTION:
        For EACH word in the list, return a Dictionary Object.
        
        STRICT OUTPUT FORMAT:
        Return a single JSON Array containing an object for each word.
        [
          {
            "word": "Base form",
            "simple": { "definition": "...", "examples": [...] },
            "advanced": { "definition": "...", "examples": [...], "collocations": [...], "nuances": "..." },
            "phonetic": "...",
            "partOfSpeech": "...",
            "forms": string[],
            "synonyms": string[],
            "antonyms": string[]
          },
          ...
        ]
        `;

        try {
            // Use callLLM's built-in model fallback for reliability
            const raw = await callLLM(prompt, "Dictionary", true);

            if (!raw || raw.startsWith("Error")) {
                console.error("Dictionary lookup failed.");
                return [];
            }

            console.log(`Dictionary lookup successful`);
            const cleanJson = extractJSON(raw);
            const parsed = JSON.parse(cleanJson);

            // SANITIZATION: Ensure definitions are strings, not objects (fixes "Objects are not valid as React child" error)
            const sanitized = Array.isArray(parsed) ? parsed.map((item: any) => {
                if (item.simple && typeof item.simple.definition === 'object') {
                    item.simple.definition = Object.values(item.simple.definition).join(' / ');
                }
                if (item.advanced && typeof item.advanced.definition === 'object') {
                    item.advanced.definition = Object.values(item.advanced.definition).join(' / ');
                }
                return item;
            }) : [];

            return sanitized;
        } catch (e: any) {
            console.error("Batch Dictionary Error", e);
            return [];
        }
    };

    const getDictionaryData = async (word: string, targetLang: any = null) => {
        // NEW: Use the same fast model chain as batch processing
        // This ensures consistency across all dictionary features
        try {
            const results = await fetchBatchDefinitions([word]);

            if (results && results.length > 0) {
                return results[0]; // Return the first (and only) result
            } else {
                return { error: "Definition not found" };
            }
        } catch (error: any) {
            console.error("getDictionaryData Error:", error);
            return { error: error.message || "Could not define. Please try again." };
        }
    };

    const handleDictionaryTabSearch = async (word: string) => {
        if (!word.trim()) return;
        const lowerWord = word.trim().toLowerCase();
        Keyboard.dismiss();
        setDictionaryInput("");

        const checkDataMatch = (data: any) => {
            if (!data) return false;
            if (data.word && data.word.toLowerCase() === lowerWord) return true;
            if (data.forms && Array.isArray(data.forms) && data.forms.some((f: any) => typeof f === 'string' && f.toLowerCase() === lowerWord)) return true;
            return false;
        };

        // 1. Check Dictionary Cache
        let cachedData: any = Object.values(dictionaryCache).find(d => checkDataMatch(d));

        // 2. Check Saved Words if not found
        if (!cachedData) {
            const liteMatch = savedWords.find(w => checkDataMatch(w));
            if (liteMatch) {
                // NEW: Hydrate from file
                cachedData = await loadWordFromFile(liteMatch);
            }
        }

        // 3. Check Recent Searches if not found
        if (!cachedData) {
            const recentItem = recentSearches.find(item => {
                const d = typeof item === 'object' ? item.data : null;
                return checkDataMatch(d);
            });
            if (recentItem) cachedData = recentItem.data;
        }

        // Helper to update history list with the latest search at the top
        const updateHistory = (fullData: any) => {
            const rootWord = fullData.word || word;
            // FIX: Read from Ref to ensure we have the absolute latest data (including pending updates)
            const currentMaster = recentSearchesRef.current;

            const filtered = currentMaster.filter((w: any) => {
                const existingWord = typeof w === 'string' ? w : w.word;
                return existingWord.toLowerCase() !== rootWord.toLowerCase();
            });

            // Use dynamic limit, preferring ref if available for freshness, fallback to state
            const limit = (displaySettingsRef.current && displaySettingsRef.current.dictionaryLimit)
                ? displaySettingsRef.current.dictionaryLimit
                : (displaySettings.dictionaryLimit || 1000);

            const updated = [{ word: rootWord, data: fullData }, ...filtered].slice(0, limit);

            // Use Orchestrator to update Ref, File, and State immediately
            updateRecentSearchesOrchestrator(updated, false);
        };

        // Use existing data if available (Offline priority)
        if (cachedData && !cachedData.error) {
            setDictionaryResult(cachedData);
            setDictionaryCurrentWord(cachedData.word); // Switch context to root word (e.g. show "Decide" even if searched "Decided")
            updateHistory(cachedData);
            return;
        }

        // 5. Fetch from API
        setDictionaryCurrentWord(word); // Set to input word temporarily while loading
        setIsDictionaryLoading(true);
        setDictionaryResult(null);

        const data = await getDictionaryData(word);

        if (data && (data.definition || data.simple || data.advanced) && !data.error) {
            const currentLang = displaySettings.language;
            // Clean data just in case
            const cleanData = { ...data, word: data.word || word };

            // Initialize with translation structure
            const completeData = {
                ...cleanData,
                language: currentLang,
                translations: { [currentLang]: cleanData }
            };

            // Cache locally using the ROOT word
            setDictionaryCache((prev: any) => ({ ...prev, [cleanData.word.toLowerCase()]: completeData }));

            updateHistory(completeData);
            setDictionaryResult(completeData);
            setDictionaryCurrentWord(cleanData.word); // Update to returned root word
        } else {
            setDictionaryResult(data);
        }

        setIsDictionaryLoading(false);
    };

    // REMOVED: Auto-load last dictionary search useEffect. 
    // This allows the "My Dictionary" list (with Import/Export) to be the default view.

    const handleWordLookup = async (word: string) => {
        if (!word) return;
        // Use refined word
        const cleanWordInput = word.trim();
        setSelectedWord({ word: cleanWordInput });
        setShowWordModal(true);
        setIsDefining(true);
        setWordData(null);
        setDictionaryViewMode('advanced');

        setModalLanguage(displaySettingsRef.current.language);

        const lowerWord = cleanWordInput.toLowerCase();

        const checkDataMatch = (data: any) => {
            if (!data) return false;
            if (data.word && data.word.toLowerCase() === lowerWord) return true;
            if (data.forms && Array.isArray(data.forms) && data.forms.some((f: any) => typeof f === 'string' && f.toLowerCase() === lowerWord)) return true;
            return false;
        };

        let cachedData = null;

        // 1. Check Saved Words Ref (Use Ref for consistency in callbacks, but here we are in main body so State is fine, 
        // but ref is safer if called from closure)
        const liteMatch = savedWordsRef.current.find(w => checkDataMatch(w));
        if (liteMatch) {
            // NEW: Hydrate from file
            cachedData = await loadWordFromFile(liteMatch);
        }

        // 2. Check Dictionary Cache Ref
        if (!cachedData) {
            cachedData = Object.values(dictionaryCacheRef.current).find(d => checkDataMatch(d));
        }

        // 3. Check Recent Searches Ref
        if (!cachedData) {
            const recentItem = recentSearchesRef.current.find(item => {
                const d = typeof item === 'object' ? item.data : null;
                return checkDataMatch(d);
            });
            if (recentItem) cachedData = recentItem.data;
        }

        // Helper to update recent searches history
        const updateHistory = (fullData: any) => {
            // FIX: Use Orchestrator for concurrency safety
            const rootWord = fullData.word || cleanWordInput;
            const currentMaster = recentSearchesRef.current; // Read from Ref

            const filtered = currentMaster.filter((item: any) => {
                const w = typeof item === 'string' ? item : item.word;
                return w.toLowerCase() !== rootWord.toLowerCase();
            });

            // Ensure fullData has the word property
            const dataToSave = { ...fullData, word: rootWord };
            // UPDATED: Use dynamic dictionaryLimit from Ref to avoid stale closure
            const limit = displaySettingsRef.current.dictionaryLimit || 1000;

            const updated = [{ word: dataToSave.word, data: dataToSave }, ...filtered].slice(0, limit);

            // Orchestrator: Update Ref, File, and State (false = do NOT skip state update)
            updateRecentSearchesOrchestrator(updated, false);
        };

        if (cachedData && !cachedData.error) {
            setWordData(cachedData);
            // If we found a form match (e.g. searched "decided", found "decide"), update the selected word title
            if (cachedData.word && cachedData.word.toLowerCase() !== lowerWord) {
                setSelectedWord({ word: cachedData.word });
            }
            updateHistory(cachedData);
            setIsDefining(false);
            return;
        }

        // API Call
        const data = await getDictionaryData(cleanWordInput);

        if (!data.error) {
            const currentLang = displaySettingsRef.current.language; // Use ref
            const cleanData = { ...data, word: data.word || cleanWordInput };
            const completeData = {
                ...cleanData,
                language: currentLang,
                translations: { [currentLang]: cleanData }
            };

            setWordData(completeData);
            // If API corrected the word (e.g. decided -> decide), update title
            if (cleanData.word.toLowerCase() !== lowerWord) {
                setSelectedWord({ word: cleanData.word });
            }

            setDictionaryCache((prev: any) => ({ ...prev, [cleanData.word.toLowerCase()]: completeData }));
            updateHistory(completeData);
        } else {
            setWordData(data);
        }
        setIsDefining(false);
    };

    const handleWordQuiz = async () => {
        setShowWordModal(false);
        const topic = selectedWord?.word ? `The meaning and usage of the word '${selectedWord.word}'` : "Vocabulary";
        handleStartQuiz(topic);
    };

    // NEW: Cycle Global Language from Home Screen
    const cycleGlobalLanguage = () => {
        const langs = displaySettings.availableLanguages;
        if (!langs || langs.length === 0) return;

        if (langs.length < 2) {
            Alert.alert(
                "Language",
                "You only have one language selected. Go to Settings to add more.",
                [{ text: "Settings", onPress: () => setActiveTab('settings') }, { text: "Cancel" }]
            );
            return;
        }

        const currentIndex = langs.indexOf(displaySettings.language);
        const nextIndex = (currentIndex + 1) % langs.length;
        const nextLang = langs[nextIndex];

        saveSettings({ language: nextLang });
        showToast(`Switched to ${nextLang}`);
    };

    const handleCycleLanguage = async () => {
        const langs = displaySettings.availableLanguages;
        if (!langs || langs.length === 0) return;

        if (langs.length < 2) {
            Alert.alert(
                "Language",
                "You only have one language selected. Go to Settings to add more.",
                [{ text: "Settings", onPress: () => { setShowWordModal(false); setActiveTab('settings'); } }, { text: "Cancel" }]
            );
            return;
        }

        const currentIndex = langs.indexOf(modalLanguage);
        const nextIndex = (currentIndex + 1) % langs.length;
        const nextLang = langs[nextIndex];

        setModalLanguage(nextLang);

        // Perform isolated definition translation/lookup for the modal
        if (selectedWord?.word && wordData) {
            // Helper to get raw data stripped of meta
            const getCleanData = (d: any) => {
                if (!d) return null;
                const { translations, ...rest } = d;
                return rest;
            };

            // Initialize translations if not present
            let currentTranslations = wordData.translations;
            if (!currentTranslations) {
                const originLang = wordData.language || 'English';
                currentTranslations = { [originLang]: getCleanData(wordData) };
            }

            if (currentTranslations[nextLang]) {
                // Restore from cache
                const restoredData = {
                    ...currentTranslations[nextLang],
                    language: nextLang,
                    translations: currentTranslations
                };
                setWordData(restoredData);
                // Update general cache silently
                setDictionaryCache((prev: any) => ({ ...prev, [selectedWord.word.toLowerCase()]: restoredData }));
            } else {
                // Fetch new definition in target language
                setIsDefining(true);
                try {
                    const newData = await getDictionaryData(selectedWord.word, nextLang);
                    const completeData = { ...newData, word: newData.word || selectedWord.word };

                    if (!newData.error) {
                        const cleanNewData = getCleanData(completeData);
                        const updatedTranslations = { ...currentTranslations, [nextLang]: cleanNewData };

                        const finalData = {
                            ...cleanNewData,
                            language: nextLang,
                            translations: updatedTranslations
                        };

                        setWordData(finalData);

                        const cacheKey = selectedWord.word.toLowerCase();
                        setDictionaryCache((prev: any) => ({ ...prev, [cacheKey]: finalData }));
                    }
                } catch (e: any) {
                    console.error("Modal language switch error", e);
                } finally {
                    setIsDefining(false);
                }
            }
        }
    };

    // NEW: Local Reader Language Switcher (Does not affect Global Settings)
    const switchReaderLanguage = async () => {
        const langs = displaySettings.availableLanguages;
        if (langs.length < 2) {
            Alert.alert("Language", "Add more languages in Settings to switch.");
            return;
        }

        // Determine current language from session, falling back to global if untagged
        const currentLang = readingSession.language || displaySettings.language || 'English';

        // Find index of current, default to 0 if not found
        let currentIndex = langs.indexOf(currentLang);
        if (currentIndex === -1) currentIndex = 0;

        const nextIndex = (currentIndex + 1) % langs.length;
        const targetLang = langs[nextIndex];

        // Stop TTS if playing to avoid mismatch between audio and text
        stopTTS();

        if (readingSession) {
            // Initialize translations if missing
            let sessionTranslations = readingSession.translations || {};
            if (Object.keys(sessionTranslations).length === 0) {
                const initialLang = readingSession.language || displaySettings.language || 'English';
                sessionTranslations = { [initialLang]: readingSession.messages[0].content };
            }

            if (sessionTranslations[targetLang]) {
                // Switch instantly using cached translation
                const newContent = sessionTranslations[targetLang];
                const updatedSession = {
                    ...readingSession,
                    translations: sessionTranslations,
                    messages: [{ role: 'ai', content: newContent }],
                    language: targetLang
                };
                setReadingSession(updatedSession);
                await persistSession(updatedSession);
            } else {
                // Perform Translation
                setIsTranslating(true);
                try {
                    // Source text: Try to find English first as pivot (best quality), otherwise use current content
                    const sourceText = sessionTranslations['English'] || readingSession.messages[0].content;

                    // NEW: Intelligent Language Detection & Switching Prompt
                    // This handles the user's request to automatically detect if the text is already in the target language
                    // and flip the direction if necessary, preventing "Hindi to Hindi" errors.
                    const prompt = `
                    Role: Expert Translator.

                    Input Text:
                    """
                    ${sourceText}
                    """

                    Context:
                    - The user wants to switch the language of this text.
                    - Intended Target: ${targetLang}
                    - Alternative Target: ${currentLang}

                    Logic:
                    1. Detect the language of the Input Text.
                    2. If the Input Text is ALREADY in ${targetLang} (or very similar), translate it to ${currentLang} instead.
                    3. Otherwise, translate it to ${targetLang}.
                    4. Maintain all Markdown formatting (headers, bold, bullet points) exactly as is.

                    Output strictly valid JSON:
                    {
                        "targetLanguage": "The name of the language you translated TO (e.g. 'English', 'Hindi')",
                    "detectedInputLanguage": "The name of the language of the INPUT text (e.g. 'English', 'Hindi')",
                    "content": "The full translated markdown text"
                  }
                    `;

                    // Call LLM in JSON mode
                    const rawResponse = await callLLM(prompt, "Expert Translator", true);

                    if (!rawResponse.startsWith("Error")) {
                        let parsed;
                        try {
                            parsed = JSON.parse(extractJSON(rawResponse));
                        } catch (e: any) {
                            // Fallback if JSON fails but text is there (unlikely with jsonMode)
                            console.warn("JSON parse failed for translation, using raw", e);
                            // Assume it translated to targetLang if parsing fails, but use raw content
                            parsed = { targetLanguage: targetLang, content: rawResponse, detectedInputLanguage: currentLang };
                        }

                        const finalLang = parsed.targetLanguage || targetLang;
                        const translatedText = parsed.content;
                        const detectedSourceLang = parsed.detectedInputLanguage; // Get detected source language

                        // Prepare updates
                        const updatedTranslations = { ...sessionTranslations };

                        // 1. FIX: Ensure the SOURCE text is saved under the CORRECT detected language key.
                        // This fixes the issue where a Note (e.g. in Hindi) was initially assumed to be 'English' (default),
                        // causing the Hindi text to be overwritten when translating to English.
                        if (detectedSourceLang && sourceText) {
                            updatedTranslations[detectedSourceLang] = sourceText;
                        }

                        // 2. Save the NEW translation
                        updatedTranslations[finalLang] = translatedText;

                        const updatedSession = {
                            ...readingSession,
                            translations: updatedTranslations,
                            messages: [{ role: 'ai', content: translatedText }],
                            language: finalLang
                        };
                        setReadingSession(updatedSession);
                        await persistSession(updatedSession);
                    } else {
                        Alert.alert("Translation Failed", rawResponse);
                    }
                } catch (e: any) {
                    console.error("Reader translation error", e);
                    Alert.alert("Error", "Translation failed.");
                } finally {
                    setIsTranslating(false);
                }
            }
        }
    };

    // NEW: Local Quiz Language Switcher (Does not affect Global Settings)
    const switchQuizLanguage = async () => {
        const langs = displaySettings.availableLanguages;
        if (langs.length < 2) {
            Alert.alert("Language", "Add more languages in Settings to switch.");
            return;
        }

        if (!quizState) return;

        // Determine current language from session, falling back to global if untagged
        const currentLang = quizState.language || displaySettings.language || 'English';

        // Find index of current, default to 0 if not found
        let currentIndex = langs.indexOf(currentLang);
        if (currentIndex === -1) currentIndex = 0;

        const nextIndex = (currentIndex + 1) % langs.length;
        const targetLang = langs[nextIndex];

        if (quizState.preventTranslation) {
            showToast(`Language Learning On: Translation skipped.`);
            return;
        }

        if (quizState.translations && quizState.translations[targetLang]) {
            // Swap questions but Preserve User State (selections, scores, time)
            const translatedQuestions = quizState.translations[targetLang];
            const currentQuestions = quizState.questions;

            // Merge state: Take text from translated, state from current
            const mergedQuestions = translatedQuestions.map((q: any, idx: number) => ({
                ...q, // New text
                selected: currentQuestions[idx]?.selected ?? null,
                markedForReview: currentQuestions[idx]?.markedForReview ?? false,
                visited: currentQuestions[idx]?.visited ?? false,
                // Preserve visual props if they are missing in translated data
                visualUri: currentQuestions[idx]?.visualUri,
                visualPrompt: currentQuestions[idx]?.visualPrompt,
                isGeneratingVisual: currentQuestions[idx]?.isGeneratingVisual
            }));

            const updatedState = {
                ...quizState,
                questions: mergedQuestions,
                language: targetLang,
                title: quizState.title
            };
            setQuizState(updatedState);

            // Persist the language switch
            if (quizState.originId && chatSessions[quizState.originId]) {
                const session = chatSessions[quizState.originId];
                session.quizData = mergedQuestions;
                session.language = targetLang;
                session.translations = quizState.translations;
                await persistSession(session);
            }
        } else {
            // Translate Quiz JSON
            setIsTranslating(true);
            try {
                // Use English as source if available, else current
                const sourceQuestions = quizState.translations['English'] || quizState.questions;

                // Strip user state to save tokens and avoid confusion
                const cleanSource = sourceQuestions.map(({ question, options, correctOptionIndex, explanation }: any) => ({ question, options, correctOptionIndex, explanation }));

                const prompt = `Translate this JSON quiz content to ${targetLang}.
                    Strictly maintain JSON structure: [{"question":"...","options":["..."],"correctOptionIndex":0,"explanation":"..."}].
                    Do NOT change 'correctOptionIndex'. Translate 'question', 'options', and 'explanation'.
                    Output ONLY valid JSON.

                    Source JSON:
                    ${JSON.stringify(cleanSource)}`;

                const raw = await callLLM(prompt, "Translator", true);
                const cleanJson = extractJSON(raw);
                const newQuestionsData = JSON.parse(cleanJson);

                if (Array.isArray(newQuestionsData) && newQuestionsData.length === sourceQuestions.length) {
                    const updatedTranslations = { ...quizState.translations, [targetLang]: newQuestionsData };

                    // Merge state
                    const currentQuestions = quizState.questions;
                    const mergedQuestions = newQuestionsData.map((q, idx) => ({
                        ...q,
                        selected: currentQuestions[idx]?.selected ?? null,
                        markedForReview: currentQuestions[idx]?.markedForReview ?? false,
                        visited: currentQuestions[idx]?.visited ?? false,
                        visualUri: currentQuestions[idx]?.visualUri,
                        visualPrompt: currentQuestions[idx]?.visualPrompt,
                        isGeneratingVisual: currentQuestions[idx]?.isGeneratingVisual
                    }));

                    const updatedState = {
                        ...quizState,
                        translations: updatedTranslations,
                        questions: mergedQuestions,
                        language: targetLang
                    };
                    setQuizState(updatedState);

                    if (quizState.originId && chatSessions[quizState.originId]) {
                        const session = chatSessions[quizState.originId];
                        session.quizData = mergedQuestions;
                        session.language = targetLang;
                        session.translations = updatedTranslations;
                        await persistSession(session);
                    }
                }
            } catch (e: any) {
                console.error("Quiz translation error", e);
                Alert.alert("Translation Failed", "Could not translate quiz content.");
            } finally {
                setIsTranslating(false);
            }
        }
    };

    // NEW: Flashcard Language Switcher
    const switchFlashcardLanguage = async () => {
        const langs = displaySettings.availableLanguages;
        if (langs.length < 2) {
            Alert.alert("Language", "Add more languages in Settings to switch.");
            return;
        }

        if (!flashcardSession) return;

        // Determine current language from session, falling back to global if untagged
        const currentLang = flashcardSession.language || displaySettings.language || 'English';

        // Find index of current, default to 0 if not found
        let currentIndex = langs.indexOf(currentLang);
        if (currentIndex === -1) currentIndex = 0;

        const nextIndex = (currentIndex + 1) % langs.length;
        const targetLang = langs[nextIndex];

        // Check cache/existing translations
        if (flashcardSession.translations && flashcardSession.translations[targetLang]) {
            const translatedItems = flashcardSession.translations[targetLang];
            const currentItems = flashcardSession.items;

            // Merge state: Take text from translated, state from current
            const mergedItems = translatedItems.map((item: any, idx: number) => ({
                ...item, // New text
                // Preserve user state if any (though flashcards are mostly stateless per session execution, but preservation is good)
            }));

            // Preserve current index and flipped state
            setFlashcardSession((prev: any) => ({
                ...prev,
                items: mergedItems,
                language: targetLang
            }));

            // Persist
            // (Optional: If we want to persist translations to the original session, we'd need to look it up in chatSessions via ID if it exists)
        } else {
            // Translate Flashcard JSON
            setIsTranslating(true);
            try {
                // Use English as source if available, else current
                // Handle session.translations potentially being undefined
                const sourceItems = (flashcardSession.translations && flashcardSession.translations['English']) || flashcardSession.items;

                // Strip unnecessary fields to save tokens
                const cleanSource = sourceItems.map((item: any) => {
                    const { front, back, question, answer, word, definition, explanation, example, examples } = item;
                    // Return only present fields
                    const obj: any = {};
                    if (front) obj.front = front;
                    if (back) obj.back = back;
                    if (question) obj.question = question;
                    if (answer) obj.answer = answer;
                    if (word) obj.word = word;
                    if (definition) obj.definition = definition;
                    if (explanation) obj.explanation = explanation;
                    if (example) obj.example = example;
                    if (examples) obj.examples = examples;
                    return obj;
                });

                const prompt = `Translate this JSON flashcard content to ${targetLang}.
                    Strictly maintain JSON structure: Array of objects.
                    Translate ALL text fields (front, back, question, answer, word, definition, explanation, example, examples).
                    Output ONLY valid JSON.
                    
                    Source JSON:
                    ${JSON.stringify(cleanSource)}`;

                const raw = await callLLM(prompt, "Translator", true);
                const cleanJson = extractJSON(raw);
                const newItemsData = JSON.parse(cleanJson);

                if (Array.isArray(newItemsData) && newItemsData.length === sourceItems.length) {
                    const updatedTranslations = { ...(flashcardSession.translations || {}), [targetLang]: newItemsData };

                    // If we didn't have English saved, save the source as English (assuming source was English or we treat it as such for pivot)
                    if (!updatedTranslations['English']) {
                        updatedTranslations['English'] = sourceItems;
                    }

                    // Update Session
                    setFlashcardSession((prev: any) => ({
                        ...prev,
                        items: newItemsData, // Use new items for display
                        language: targetLang,
                        translations: updatedTranslations
                    }));
                } else {
                    throw new Error("Mismatch in translation items count");
                }

            } catch (e: any) {
                console.error("Flashcard translation error", e);
                Alert.alert("Translation Failed", "Could not translate flashcards.");
            } finally {
                setIsTranslating(false);
            }
        }
    };

    const handleExpandTable = (data: any) => {
        setIsTableLandscape(true);
        setExpandedTableData(data);
    };

    const renderReaderItem = useCallback(({ item }: any) => {
        if (item.type === 'table') {
            return (
                <SimpleTable
                    key={`${item.id}-${theme.id}`} // NEW: Force re-render on theme change
                    rows={item.rows}
                    theme={theme}
                    onExpand={handleExpandTable}
                    initiallyHidden={item.initiallyHidden}
                    toggleLabel={item.toggleLabel}
                    fontSize={displaySettings.fontSize}
                    initialCustomWidths={savedTableWidths.current[readingSession.id]?.[item.id] || {}}
                    onSaveWidths={(colIndex: number, width: number | null) => {
                        if (width !== null) handleSaveTableWidth(readingSession.id, item.id, colIndex, width);
                    }}
                />
            );
        }
        // NEW: Concept Card Rendering
        if (item.type === 'concept-card') {
            return (
                <ConceptCard
                    key={`${item.id}-${theme.id}`}
                    title={item.title}
                    content={item.content}
                    theme={theme}
                    fontSize={displaySettings.fontSize}
                    // NEW: Props for Tap to Define & TTS Highlighting
                    onWordPress={handleWordLookup}
                    onLinkPress={handleLinkPress}
                    activeSentence={activeSentence}
                    offset={item.offset} // Pass offset from readerParagraphs
                    tapToDefineEnabled={displaySettings.tapToDefine}
                    isHighlightMode={isHighlightMode}
                    highlights={readingSession.highlights}
                    onHighlightPress={handleWordHighlight}
                />
            );
        }
        return (
            <InteractiveText
                key={`${item.id}-${theme.id}`} // NEW: Force re-render on theme change
                rawText={item.text}
                onWordPress={handleWordLookup}
                onLinkPress={handleLinkPress}
                activeSentence={activeSentence}
                paragraphOffset={item.offset}
                theme={theme}
                isHighlightMode={isHighlightMode}
                highlights={readingSession.highlights}
                onHighlightPress={handleWordHighlight}
                tapToDefineEnabled={displaySettings.tapToDefine}
                style={[
                    styles.articleText,
                    {
                        color: theme.text,
                        fontSize: 18 * displaySettings.fontSize,
                        lineHeight: 30 * displaySettings.fontSize,
                        textAlign: 'justify',
                        marginBottom: 15,
                        ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles)
                    }
                ]}
            />
        );
    }, [theme, displaySettings.fontSize, displaySettings.fontFamily, displaySettings.textStyles, displaySettings.tapToDefine, activeSentence, isHighlightMode, readingSession?.highlights, handleWordHighlight, handleWordLookup, handleLinkPress, handleExpandTable, readingSession?.id]);


    const isDay = displaySettings.theme === 'day';
    // Replaced manual checks with primary color from theme object
    const primaryColor = theme.primary;

    const renderHeader = () => {
        // NEW: Hide header if Reader + Minimized Search OR Orphan Audio
        if (appMode === 'reader' && (!isReaderSearchExpanded || readingSession?.toolId === 'orphan_audio')) {
            return null;
        }

        let displayTitle = APP_TITLE;
        let showBack = false;
        let backAction = () => { };

        // Actions for the right side
        let rightAction = null;
        let closeAction = null; // New distinct close action

        // Helper for Appearance Button
        const AppearanceButton = () => (
            <TouchableOpacity onPress={() => setShowAppearance(true)} style={[styles.iconBtn, { backgroundColor: isDay ? 'rgba(255, 255, 255, 0.2)' : theme.buttonBg, borderColor: 'transparent' }]}>
                <Palette size={24} color={isDay ? '#ffffff' : theme.text} />
            </TouchableOpacity>
        );

        const handleWifiPress = () => {
            // ... existing handleWifiPress logic ...
            const hasKey = customApiKey || apiKey;

            if (!hasKey) {
                Alert.alert(
                    "Offline Mode",
                    "You are currently using offline features.\n\nTo enable AI chat, vision, and quizzes, please add a free Gemini API Key in Settings.",
                    [
                        { text: "Cancel", style: "cancel" },
                        { text: "Open Settings", onPress: () => setActiveTab('settings') }
                    ]
                );
                return;
            }

            if (isRateLimited) {
                Alert.alert(
                    "Connection Limited",
                    "We've hit the free tier rate limit. The system will automatically recover shortly.\n\nOffline features (Notes, History) still work.",
                    [
                        { text: "Wait", style: "cancel" },
                        { text: "Check Now", onPress: () => { setIsRateLimited(false); handleTestConnection(); } }
                    ]
                );
                return;
            }

            // Online
            Alert.alert(
                "AI System Online",
                `Connected to Google Gemini.\n\nPriority: ${displaySettings.modelPriority === 'speed' ? 'Speed' : 'Quality'}`,
                [
                    { text: "OK", style: "cancel" },
                    { text: "Test Latency", onPress: handleTestConnection }
                ]
            );
        };

        if (appMode === 'reader') {
            displayTitle = "R";
            showBack = false; // Disable back button on left

            // Handle Close Logic (Formerly Back Action)
            const handleClose = () => {
                // UPDATED: Handle Minimized Session
                if (minimizedSession) {
                    setReadingSession(minimizedSession);
                    setMinimizedSession(null);
                    return;
                }

                // IMPROVEMENT: Logic to return to setup if that was origin
                if (navOrigin === 'setup') {
                    setAppMode("setup");
                } else {
                    setAppMode("idle");
                }
            };

            // NEW: Share as File Logic (Replaces old text share)
            const onShare = async () => {
                try {
                    if (!readingSession) return;
                    const content = readingSession.messages?.[0]?.content || "";

                    // If text only AND no images, allow empty check to return (otherwise we might share image-only)
                    const hasImages = readingSession.images && readingSession.images.length > 0;
                    const hasGeneratedImage = !!readingSession.image;
                    if (!hasImages && !hasGeneratedImage && !content.trim()) return;

                    const title = readingSession.title || "Shared Content";
                    const safeName = title.replace(/[<>:"/\\|?*]/g, '-').replace(/\s+/g, '_').substring(0, 50);

                    showToast("Preparing share...");

                    // Determine source tab based on tool ID
                    let sourceTab = 'journals';
                    if (readingSession.toolId === 'quick_notes') sourceTab = 'notes';
                    if (readingSession.toolId === 'story_generator') sourceTab = 'story';
                    if (readingSession.toolId === 'quiz_save') sourceTab = 'quiz';

                    // Use Unified Bundle
                    const bundle = await createShareBundle([readingSession], sourceTab);

                    const filename = `${safeName}.json`;
                    const cacheDir = fs.cacheDirectory || FileSystem.cacheDirectory;
                    const fileUri = cacheDir + filename;

                    await fs.writeAsStringAsync(fileUri, JSON.stringify(bundle), { encoding: fs.EncodingType.UTF8 });

                    await Sharing.shareAsync(fileUri, {
                        mimeType: 'application/json',
                        dialogTitle: `Share ${title}`,
                        UTI: 'public.json'
                    });

                } catch (error: any) {
                    console.log(error.message);
                    Alert.alert("Error", "Could not share content.");
                }
            };

            // NEW: Edit Action Logic
            const onEdit = () => {
                // FIX: Only stop TTS if we are editing the exact session that is currently playing.
                // This prevents stopping background audio when editing a different note.
                if (ttsStatus === 'playing' && playingMeta?.id === readingSession?.id) {
                    stopTTS();
                }

                if (readingSession) {
                    // Check if we are merely returning to the active editor session (Preview scenario)
                    const isReturningToPreview = isEditingNote && (
                        (currentNoteId && readingSession.id === currentNoteId) ||
                        (!currentNoteId && readingSession.id === 'temp_preview')
                    );

                    if (isReturningToPreview) {
                        // Just exit reader mode, revealing the underlying editor with its state intact
                        setAppMode('idle');
                        setActiveTab('notes');
                    } else {
                        // Loading a different note or starting edit from scratch (Resets history)
                        handleEditNote(readingSession);
                        setActiveTab('notes');
                        setAppMode('idle');
                    }
                }
            };

            // NEW: Toggle Highlighter Mode
            const toggleHighlighter = () => {
                setIsHighlightMode(prev => !prev);
                if (!isHighlightMode) {
                    // When turning ON, stop TTS to avoid conflict/confusion
                    stopTTS();
                    showToast("Tap words to highlight");
                }
            };

            // NEW: Standardized Header Button Style for Reader Mode
            const readerBtnStyle: any = {
                width: 34,
                height: 34,
                borderRadius: 10,
                alignItems: 'center',
                justifyContent: 'center',
                borderWidth: 1,
                borderColor: isDay ? 'rgba(255,255,255,0.15)' : theme.border,
                backgroundColor: isDay ? 'rgba(255, 255, 255, 0.15)' : theme.buttonBg,
            };

            rightAction = (
                <View style={{ flex: 1, flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>

                    {/* NEW: Smart Discovery Button */}
                    <TouchableOpacity
                        onPress={handleReaderDiscovery}
                        style={readerBtnStyle}
                    >
                        <Sparkles size={18} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>

                    {/* Highlighter Button */}
                    <TouchableOpacity
                        onPress={toggleHighlighter}
                        style={[readerBtnStyle, isHighlightMode && { backgroundColor: primaryColor, borderColor: primaryColor }] as any}
                    >
                        <Highlighter size={18} color={isHighlightMode ? 'white' : (isDay ? '#ffffff' : theme.text)} />
                    </TouchableOpacity>

                    {/* Language Switch Toggle (Code Only) */}
                    <TouchableOpacity
                        onPress={switchReaderLanguage}
                        disabled={isTranslating} // Disable while translating
                        style={readerBtnStyle}
                    >
                        {isTranslating ? (
                            <ActivityIndicator size="small" color={isDay ? '#ffffff' : theme.text} />
                        ) : (
                            <Text style={{ color: isDay ? '#ffffff' : theme.text, fontWeight: '900', fontSize: 11 }}>
                                {(readingSession?.language || displaySettings.language).substring(0, 2).toUpperCase()}
                            </Text>
                        )}
                    </TouchableOpacity>

                    {/* Edit Button */}
                    <TouchableOpacity
                        onPress={onEdit}
                        style={readerBtnStyle}
                    >
                        <PenLine size={18} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>

                    {/* Export Text Button (Save to Device) */}
                    <TouchableOpacity onPress={handleReaderExport} style={readerBtnStyle}>
                        <Download size={18} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>

                    {/* Share Button (Share File) - Restored */}
                    <TouchableOpacity onPress={onShare} style={readerBtnStyle}>
                        <Share2 size={18} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>

                    {/* Appearance Button */}
                    <TouchableOpacity onPress={() => setShowAppearance(true)} style={readerBtnStyle}>
                        <Palette size={18} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>

                    {/* Audio Upload Button */}
                    <TouchableOpacity onPress={handleUploadAudio} style={readerBtnStyle}>
                        <Music size={18} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>

                    {/* TTS Button */}
                    <TouchableOpacity
                        onPress={async () => {
                            const isPlayingCurrent = ttsStatus === 'playing' && playingMeta?.id === readingSession?.id;
                            const isPlayingOther = ttsStatus === 'playing' && playingMeta?.id !== readingSession?.id;

                            if (ttsStatus === 'stopped') {
                                // Check for custom audio first
                                const sessionId = readingSession?.id;
                                if (sessionId && customAudioUris[sessionId]) {
                                    const played = await playCustomAudio(sessionId);
                                    if (played) {
                                        setPlayingMeta({ id: readingSession.id, title: readingSession.title });
                                        return;
                                    }
                                }
                                // Fall back to TTS
                                speak(readingSession?.messages[0]?.content);
                                setPlayingMeta({ id: readingSession.id, title: readingSession.title });
                            } else if (isPlayingOther) {
                                // Check for custom audio first
                                const sessionId = readingSession?.id;
                                if (sessionId && customAudioUris[sessionId]) {
                                    const played = await playCustomAudio(sessionId);
                                    if (played) {
                                        setPlayingMeta({ id: readingSession.id, title: readingSession.title });
                                        return;
                                    }
                                }
                                // Fall back to TTS
                                speak(readingSession?.messages[0]?.content, 0, false, true);
                                setPlayingMeta({ id: readingSession.id, title: readingSession.title });
                            } else {
                                stopTTS();
                                stopCustomAudio();
                            }
                        }}
                        style={readerBtnStyle}
                    >
                        {isTtsDownloading ? (
                            <ActivityIndicator size="small" color={isDay ? '#ffffff' : theme.text} />
                        ) : ((ttsStatus === 'playing' && playingMeta?.id === readingSession?.id) || isCustomAudioPlaying) ? (
                            <Square size={16} color={isDay ? '#ffffff' : theme.text} fill={isDay ? '#ffffff' : theme.text} />
                        ) : (
                            <Volume2 size={18} color={isDay ? '#ffffff' : theme.text} />
                        )}
                    </TouchableOpacity>

                    {/* NEW: Minimize Button (Only in Landscape) - Moves functionality from sidebar header to here */}
                    {isLandscape && (
                        <TouchableOpacity
                            onPress={() => setIsReaderSearchExpanded(false)}
                            style={readerBtnStyle}
                        >
                            <Maximize2 size={18} color={isDay ? '#ffffff' : theme.text} />
                        </TouchableOpacity>
                    )}

                    {/* Close Button */}
                    <TouchableOpacity
                        onPress={handleClose}
                        style={readerBtnStyle}
                    >
                        <X size={20} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>
                </View>
            );
        } else if (appMode === 'live') {
            displayTitle = quizState?.title || "Quiz";
            const currentQ = quizState?.questions[quizState?.currentIndex];
            const isSaved = currentQ ? savedQuestions.some(sq => sq.question === currentQ.question) : false;

            // Close action for right side
            closeAction = closeQuizSession;

            rightAction = (
                <View style={{ flexDirection: 'row', gap: 10, alignItems: 'center' }}>
                    {isTranslating && (
                        <View style={{ marginRight: 5 }}>
                            <ActivityIndicator size="small" color={isDay ? '#fff' : theme.text} />
                        </View>
                    )}

                    <TouchableOpacity
                        onPress={switchQuizLanguage} // UPDATED: Use local switcher instead of changing global settings
                        disabled={isTranslating}
                        style={[styles.iconBtn, { backgroundColor: isDay ? 'rgba(255, 255, 255, 0.2)' : theme.buttonBg, borderColor: 'transparent', flexDirection: 'row', alignItems: 'center', gap: 4, paddingHorizontal: 10 }]}
                    >
                        <Languages size={18} color={isDay ? '#ffffff' : theme.text} />
                        <Text style={{ color: isDay ? '#ffffff' : theme.text, fontWeight: 'bold', fontSize: 12 }}>
                            {(quizState?.language || displaySettings.language).substring(0, 2).toUpperCase()}
                        </Text>
                    </TouchableOpacity>

                    {quizState?.completed && (
                        <TouchableOpacity
                            onPress={() => toggleSaveQuestion(currentQ)}
                            style={{ padding: 8 }}
                        >
                            <Star size={24} color={isDay ? '#ffffff' : theme.text} fill={isSaved ? (isDay ? '#ffffff' : theme.text) : 'transparent'} />
                        </TouchableOpacity>
                    )}

                    <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: isDay ? 'rgba(255, 255, 255, 0.2)' : theme.buttonBg, paddingHorizontal: 12, paddingVertical: 6, borderRadius: 20 }}>
                        <Clock size={16} color={isDay ? '#ffffff' : theme.text} style={{ marginRight: 6 }} />
                        <Text style={{ color: isDay ? '#ffffff' : theme.text, fontWeight: 'bold', fontSize: 14 }}>
                            {formatTimer(quizSecondsElapsed)}
                        </Text>
                    </View>

                    <TouchableOpacity onPress={closeAction} style={[styles.iconBtn, { backgroundColor: isDay ? 'rgba(255, 255, 255, 0.2)' : theme.buttonBg, borderColor: 'transparent', marginLeft: 5 }]}>
                        <X size={24} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>
                </View>
            );
        } else if (appMode === 'setup') {
            displayTitle = selectedScenario?.title || "Studio";
            // Close action for right side
            closeAction = () => setAppMode("idle");

            rightAction = (
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                    <TouchableOpacity
                        onPress={() => {
                            const newPriority = displaySettings.modelPriority === 'speed' ? 'quality' : 'speed';
                            saveSettings({ modelPriority: newPriority });
                        }}
                        style={{
                            flexDirection: 'row',
                            alignItems: 'center',
                            backgroundColor: isDay ? 'rgba(255, 255, 255, 0.2)' : theme.buttonBg,
                            paddingHorizontal: 12,
                            paddingVertical: 6,
                            borderRadius: 20,
                        }}
                    >
                        {displaySettings.modelPriority === 'speed' ? (
                            <Zap size={14} color={isDay ? '#ffffff' : '#22c55e'} fill={isDay ? '#ffffff' : '#22c55e'} style={{ marginRight: 6 }} />
                        ) : (
                            <Sparkles size={14} color={isDay ? '#ffffff' : '#a855f7'} fill={isDay ? '#ffffff' : '#a855f7'} style={{ marginRight: 6 }} />
                        )}
                        <Text style={{ fontSize: 11, fontWeight: 'bold', color: isDay ? '#ffffff' : theme.text }}>
                            {displaySettings.modelPriority === 'speed' ? 'SPEED' : 'QUALITY'}
                        </Text>
                    </TouchableOpacity>

                    {/* REMOVED: AppearanceButton from Setup Mode */}
                    <TouchableOpacity onPress={closeAction} style={{ padding: 5 }}>
                        <X size={24} color={isDay ? '#ffffff' : theme.text} />
                    </TouchableOpacity>
                </View>
            );
        } else if (appMode === 'idle') {
            if (activeTab === 'library') {
                displayTitle = "Library";
            }
            if (activeTab === 'notes') {
                if (isSaving) {
                    displayTitle = "Saving...";
                } else {
                    displayTitle = isEditingNote ? "Edit Note" : "My Notes";
                }
            }
            if (activeTab === 'dictionary') displayTitle = "Dictionary";
            if (activeTab === 'studio') displayTitle = "All Apps";
            if (activeTab === 'story') {
                displayTitle = storyTabMode === 'editorial' ? "Editorial Writer" : "Story Generator";
            }
            if (activeTab === 'settings') displayTitle = "Settings";

            if (activeTab !== 'home') {
                closeAction = () => {
                    if (activeTab === 'notes' && isEditingNote) {
                        // CHANGED: Use confirmation instead of direct discard
                        confirmCloseNote();
                    } else {
                        setActiveTab('home');
                    }
                };
            }

            if (activeTab === 'notes' && isEditingNote) {
                rightAction = (
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                        {/* NEW: Undo/Redo Buttons */}
                        <View style={{ flexDirection: 'row', gap: 4, marginRight: 5 }}>
                            <TouchableOpacity
                                onPress={handleUndo}
                                disabled={undoStack.length === 0}
                                style={{ padding: 6, opacity: undoStack.length === 0 ? 0.3 : 1 }}
                            >
                                <Undo2 size={20} color={isDay ? '#ffffff' : theme.text} />
                            </TouchableOpacity>
                            <TouchableOpacity
                                onPress={handleRedo}
                                disabled={redoStack.length === 0}
                                style={{ padding: 6, opacity: redoStack.length === 0 ? 0.3 : 1 }}
                            >
                                <Redo2 size={20} color={isDay ? '#ffffff' : theme.text} />
                            </TouchableOpacity>
                        </View>

                        {/* NEW: Export Button (Upload Icon) */}
                        <TouchableOpacity
                            onPress={handleExportNote}
                            style={{ padding: 6 }}
                        >
                            <Upload size={22} color={isDay ? '#ffffff' : theme.text} />
                        </TouchableOpacity>

                        {/* NEW: Preview Button */}
                        <TouchableOpacity
                            onPress={handlePreviewNote}
                            style={{ padding: 6 }}
                        >
                            <Eye size={24} color={isDay ? '#ffffff' : theme.text} />
                        </TouchableOpacity>

                        <TouchableOpacity
                            onPress={handleSaveNote}
                            disabled={isSaving}
                            style={{
                                backgroundColor: isDay ? 'white' : primaryColor,
                                paddingHorizontal: 16,
                                paddingVertical: 8,
                                borderRadius: 20,
                                alignItems: 'center',
                                justifyContent: 'center',
                                flexDirection: 'row',
                                gap: 6,
                                opacity: isSaving ? 0.7 : 1
                            }}
                        >
                            {isSaving ? (
                                <ActivityIndicator size="small" color={isDay ? primaryColor : 'white'} />
                            ) : (
                                <>
                                    <Save size={16} color={isDay ? primaryColor : 'white'} />
                                    <Text style={{ color: isDay ? primaryColor : 'white', fontWeight: 'bold', fontSize: 14 }}>Save</Text>
                                </>
                            )}
                        </TouchableOpacity>

                        {closeAction && (
                            <TouchableOpacity onPress={closeAction} style={{ padding: 5 }}>
                                <X size={24} color={isDay ? '#ffffff' : theme.text} />
                            </TouchableOpacity>
                        )}
                    </View>
                );
            } else if (activeTab === 'notes' && !isEditingNote) {


                rightAction = (
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                        {/* NEW: Import Button (Only in Active Mode) */}
                        {/* NEW: Import Button (Only in Active Mode) */}
                        <TouchableOpacity
                            onPress={handleImportNote}
                            style={{ padding: 6, marginRight: 5 }}
                        >
                            <FileDown size={22} color={isDay ? '#ffffff' : theme.text} />
                        </TouchableOpacity>



                        {/* REMOVED: AppearanceButton from Notes List */}
                        <TouchableOpacity onPress={closeAction || undefined} style={{ padding: 5 }}>
                            <X size={24} color={isDay ? '#ffffff' : theme.text} />
                        </TouchableOpacity>
                    </View>
                );
            } else if (activeTab !== 'home') {

                rightAction = (
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                        {/* Library Import Button (Active Mode, Non-Audio Tabs Only) */}
                        {activeTab === 'library' && libraryTab !== 'audio' && (
                            <TouchableOpacity
                                onPress={async () => {
                                    await handleImportLibraryItem();
                                }}
                                style={{ padding: 6 }}
                            >
                                <FileDown size={22} color={isDay ? '#ffffff' : theme.text} />
                            </TouchableOpacity>
                        )}

                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8, marginRight: 5 }}>
                        </View>

                        {/* REMOVED: AppearanceButton from Library/Settings/etc */}
                        <TouchableOpacity onPress={closeAction || undefined} style={{ padding: 5 }}>
                            <X size={24} color={isDay ? '#ffffff' : theme.text} />
                        </TouchableOpacity>
                    </View>
                );
            } else {
                rightAction = (
                    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                        {/* Model Priority Toggle */}
                        <TouchableOpacity
                            onPress={() => {
                                const newPriority = displaySettings.modelPriority === 'speed' ? 'quality' : 'speed';
                                saveSettings({ modelPriority: newPriority });
                            }}
                            style={{
                                flexDirection: 'row',
                                alignItems: 'center',
                                backgroundColor: isDay ? 'rgba(255, 255, 255, 0.2)' : theme.buttonBg,
                                paddingHorizontal: 12,
                                paddingVertical: 6,
                                borderRadius: 20,
                                marginRight: 8,
                            }}
                        >
                            {displaySettings.modelPriority === 'speed' ? (
                                <Zap size={14} color={isDay ? '#ffffff' : '#22c55e'} fill={isDay ? '#ffffff' : '#22c55e'} style={{ marginRight: 6 }} />
                            ) : (
                                <Sparkles size={14} color={isDay ? '#ffffff' : '#a855f7'} fill={isDay ? '#ffffff' : '#a855f7'} style={{ marginRight: 6 }} />
                            )}
                            <Text style={{ fontSize: 11, fontWeight: 'bold', color: isDay ? '#ffffff' : theme.text }}>
                                {displaySettings.modelPriority === 'speed' ? 'SPEED' : 'QUALITY'}
                            </Text>
                        </TouchableOpacity>

                        <AppearanceButton />
                        <TouchableOpacity onPress={() => setActiveTab('settings')} style={[styles.iconBtn, { backgroundColor: isDay ? 'rgba(255, 255, 255, 0.2)' : theme.buttonBg, borderColor: 'transparent', marginLeft: 10 }]}>
                            <Settings size={20} color={isDay ? '#ffffff' : theme.text} />
                        </TouchableOpacity>
                    </View>
                );
            }
        }

        // Dynamic header color logic
        const headerBg = isDay ? theme.primary : theme.uiBg;
        const headerTextColor = isDay ? '#ffffff' : theme.text;
        const headerIconColor = isDay ? '#ffffff' : theme.text;
        const logoBoxBg = isDay ? '#ffffff' : theme.logoBg;
        const logoTextColor = isDay ? theme.primary : theme.logoText;
        const borderColor = isDay ? 'transparent' : theme.border;
        const borderBottomWidth = isDay ? 0 : 1;

        return (
            <View style={[styles.header, { backgroundColor: headerBg, borderColor: borderColor, borderBottomWidth: borderBottomWidth }]}>
                {appMode !== 'reader' && (
                    <View style={styles.logoContainer}>
                        {showBack ? (
                            <TouchableOpacity onPress={backAction} style={{ marginRight: 15 }}>
                                <ArrowLeft size={24} color={headerIconColor} />
                            </TouchableOpacity>
                        ) : (
                            <TouchableOpacity
                                onPress={() => Linking.openURL('https://youtube.com/@rreaderapp?si=30Ms4Wi1hyJOaUDi')}
                                activeOpacity={0.7}
                                style={[styles.logoBox, { backgroundColor: logoBoxBg }]}
                            >
                                <Text style={[styles.logoText, { color: logoTextColor }]}>R</Text>
                            </TouchableOpacity>
                        )}

                        <View style={{ flex: 1, flexDirection: 'row', alignItems: 'center', gap: 6 }}>
                            <Text style={[styles.appTitle, { color: headerTextColor, marginBottom: 0, flexShrink: 1 }]} numberOfLines={1}>
                                {displayTitle.length > 25 ? displayTitle.substring(0, 25) + '...' : displayTitle}
                            </Text>
                            {activeTab === 'home' && (
                                <TouchableOpacity
                                    onPress={handleDownloadDictionary}
                                    style={{ padding: 4, marginLeft: 2 }}
                                >
                                    <DownloadCloud size={18} color={headerIconColor} />
                                </TouchableOpacity>
                            )}
                        </View>
                    </View>
                )}

                <View style={appMode === 'reader' ? { flex: 1 } : { flexDirection: 'row', gap: 10 }}>
                    {rightAction}
                </View>
            </View>
        );
    };

    const renderDefinitionContent = (data: any, word: string, isSaved: any, toggleSave: any, hideHeader = false, onStartQuiz: any = null, onRefresh: any = null) => {
        if (data?.error) {
            return (
                <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 20 }}>
                    <AlertTriangle size={48} color="#ef4444" style={{ marginBottom: 20 }} />
                    <Text style={{ fontSize: 18, fontWeight: 'bold', color: theme.text, textAlign: 'center', marginBottom: 10 }}>Connection Issue</Text>
                    <Text style={{ fontSize: 14, color: theme.secondary, textAlign: 'center' }}>{data.error}</Text>
                    {onRefresh && (
                        <TouchableOpacity
                            onPress={onRefresh}
                            style={{ marginTop: 20, flexDirection: 'row', alignItems: 'center', backgroundColor: theme.buttonBg, padding: 12, borderRadius: 12 }}
                        >
                            <RefreshCcw size={18} color={theme.text} style={{ marginRight: 8 }} />
                            <Text style={{ color: theme.text, fontWeight: 'bold' }}>Try Again</Text>
                        </TouchableOpacity>
                    )}
                </View>
            );
        }

        const onDefWordClick = (w: string) => {
            if (activeTab === 'dictionary' && appMode === 'idle') {
                handleDictionaryTabSearch(w);
            } else {
                handleWordLookup(w);
            }
        };

        const handleToggleSave = () => {
            if (toggleSave) {
                // FIX: Spread data first, then overwrite 'word' with the explicit argument.
                // This prevents the 'word' property in 'data' (which might be undefined, English transliteration, or null)
                // from overwriting the correct 'word' (e.g. Hindi input) passed to this function.
                toggleSave({
                    ...data,
                    word: word
                });
            }
        };

        // REMOVED: isBeginner check. Always use 'advanced' data (which now has simple definitions).
        const definition = data?.advanced?.definition || data?.definition;

        // Use advanced examples if available, fallback to root examples
        const examples = data?.advanced?.examples || data?.examples || [];

        const advancedData = data?.advanced || {};

        return (
            <View style={{ flex: 1 }}>
                {!hideHeader && (
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 15 }}>
                        <View style={{ flex: 1 }}>
                            <Text style={{ fontSize: 24, fontWeight: 'bold', color: theme.text }}>{word}</Text>
                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8, marginTop: 4, flexWrap: 'wrap' }}>
                                {data?.phonetic && (
                                    <Text style={{ color: theme.secondary, fontSize: 16, fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace' }}>{data.phonetic}</Text>
                                )}
                                {data?.partOfSpeech && (
                                    <Text style={{ color: primaryColor, fontSize: 14, fontWeight: '700', fontStyle: 'italic', backgroundColor: theme.highlight, paddingHorizontal: 6, paddingVertical: 2, borderRadius: 4, overflow: 'hidden' }}>
                                        {data.partOfSpeech}
                                    </Text>
                                )}
                            </View>
                        </View>

                        <View style={{ flexDirection: 'row', gap: 10 }}>
                            {onRefresh && (
                                <TouchableOpacity onPress={onRefresh} style={{ padding: 5 }}>
                                    <RefreshCcw size={24} color={theme.text} />
                                </TouchableOpacity>
                            )}
                            <TouchableOpacity
                                onPress={() => {
                                    speak(word, 0, false, false, "Word Pronunciation");
                                    // NEW: Clear playingMeta so this short audio doesn't trigger chapter highlighting
                                    setPlayingMeta(null);
                                }}
                                style={{ padding: 5 }}
                            >
                                <Volume2 size={24} color={theme.text} />
                            </TouchableOpacity>
                            {toggleSave && (
                                <TouchableOpacity onPress={handleToggleSave} style={{ padding: 5 }}>
                                    <Star size={24} color={theme.text} fill={isSaved(word) ? theme.text : "transparent"} />
                                </TouchableOpacity>
                            )}
                        </View>
                    </View>
                )}

                {/* REMOVED: Beginner/Advanced Toggle */}
                {/* <View style={{ flexDirection: 'row', marginBottom: 20... }}> ... </View> */}

                <ScrollView
                    style={{ flex: 1 }}
                    showsVerticalScrollIndicator={false}
                    contentContainerStyle={{ paddingBottom: 100, flexGrow: 1 }}
                >
                    <View style={{ marginBottom: 20 }}>

                        <View style={{ padding: 15, backgroundColor: theme.uiBg, borderRadius: 12, borderWidth: 1, borderColor: theme.border }}>
                            <InteractiveText
                                rawText={definition || "No definition found."}
                                onWordPress={onDefWordClick}
                                theme={theme}
                                activeSentence={null}
                                style={{ fontSize: 18, color: theme.text, lineHeight: 28, fontWeight: '500', textAlign: 'justify', ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                            />
                        </View>

                        <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginTop: 12 }}>
                            {/* Part of Speech removed from here as it is now in header, keeping forms */}
                            {data?.forms && data.forms.map((form: any, idx: number) => (
                                <View key={idx} style={{ backgroundColor: theme.uiBg, paddingHorizontal: 10, paddingVertical: 6, borderRadius: 6, borderWidth: 1, borderColor: theme.border }}>
                                    <Text style={{ fontSize: 14, color: theme.secondary, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>{form}</Text>
                                </View>
                            ))}
                        </View>

                        {examples && examples.length > 0 && (
                            <View style={{ marginTop: 20 }}>
                                <Text style={{ fontSize: 12, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase', marginBottom: 10 }}>Examples</Text>
                                {examples.map((ex: any, i: number) => (
                                    <View key={i} style={{ flexDirection: 'row', marginBottom: 10, paddingLeft: 10 }}>
                                        <View style={{ width: 3, height: '100%', backgroundColor: theme.highlight, marginRight: 12, borderRadius: 2 }} />
                                        <InteractiveText
                                            rawText={`"${ex}"`}
                                            onWordPress={onDefWordClick}
                                            theme={theme}
                                            activeSentence={null}
                                            style={{ fontStyle: 'italic', color: theme.secondary, fontSize: 16, lineHeight: 24, flex: 1, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                        />
                                    </View>
                                ))}
                            </View>
                        )}

                        {/* Always show Collocations if available */}
                        {advancedData.collocations && advancedData.collocations.length > 0 && (
                            <View style={{ marginTop: 20 }}>
                                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
                                    <Layers size={14} color={theme.secondary} style={{ marginRight: 6 }} />
                                    <Text style={{ fontSize: 12, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase' }}>Collocations</Text>
                                </View>
                                <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8 }}>
                                    {advancedData.collocations.map((col: any, idx: number) => (
                                        <View key={idx} style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 10, paddingVertical: 6, borderRadius: 8, borderWidth: 1, borderColor: theme.border }}>
                                            <Text style={{ color: theme.text, fontSize: 14, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>{col}</Text>
                                        </View>
                                    ))}
                                </View>
                            </View>
                        )}

                        {/* Always show Nuances if available */}
                        {advancedData.nuances && (
                            <View style={{ marginTop: 20, backgroundColor: theme.highlight, padding: 12, borderRadius: 8, borderLeftWidth: 3, borderLeftColor: primaryColor }}>
                                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6 }}>
                                    <Quote size={14} color={primaryColor} style={{ marginRight: 6 }} />
                                    <Text style={{ fontSize: 12, color: primaryColor, fontWeight: 'bold', textTransform: 'uppercase' }}>Nuance</Text>
                                </View>
                                <Text style={{ color: theme.text, fontSize: 15, fontStyle: 'italic', ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>{advancedData.nuances}</Text>
                            </View>
                        )}
                    </View>

                    {/* Always show Etymology/Origins */}
                    {(
                        <View style={{ borderTopWidth: 1, borderTopColor: theme.border, paddingTop: 20 }}>
                            {(data?.synonyms?.length > 0 || data?.antonyms?.length > 0) && (
                                <View style={{ marginBottom: 25 }}>
                                    {data?.synonyms?.length > 0 && (
                                        <View style={{ marginBottom: 15 }}>
                                            <Text style={{ fontSize: 12, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase', marginBottom: 8 }}>Synonyms</Text>
                                            <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8 }}>
                                                {data.synonyms.map((syn: any, i: number) => (
                                                    <TouchableOpacity
                                                        key={i}
                                                        onPress={() => onDefWordClick(syn)}
                                                        style={{ backgroundColor: theme.highlight, paddingHorizontal: 10, paddingVertical: 6, borderRadius: 8, borderWidth: 1, borderColor: theme.border }}
                                                    >
                                                        <Text style={{ color: theme.text, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>{syn}</Text>
                                                    </TouchableOpacity>
                                                ))}
                                            </View>
                                        </View>
                                    )}

                                    {data?.antonyms?.length > 0 && (
                                        <View>
                                            <Text style={{ fontSize: 12, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase', marginBottom: 8 }}>Antonyms</Text>
                                            <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8 }}>
                                                {data.antonyms.map((ant: any, i: number) => (
                                                    <TouchableOpacity
                                                        key={i}
                                                        onPress={() => onDefWordClick(ant)}
                                                        style={{ backgroundColor: theme.uiBg, paddingHorizontal: 10, paddingVertical: 6, borderRadius: 8, borderWidth: 1, borderColor: theme.border, opacity: 0.8 }}
                                                    >
                                                        <Text style={{ color: theme.secondary, textDecorationLine: 'line-through', ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>{ant}</Text>
                                                    </TouchableOpacity>
                                                ))}
                                            </View>
                                        </View>
                                    )}
                                </View>
                            )}

                            {(data?.usageNote || data?.etymology) && (
                                <View style={{ gap: 20 }}>
                                    {data?.usageNote && (
                                        <View>
                                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                                <ScrollText size={14} color={theme.secondary} style={{ marginRight: 6 }} />
                                                <Text style={{ fontSize: 12, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase' }}>Usage Note</Text>
                                            </View>
                                            <Text style={{ color: theme.text, fontSize: 15, lineHeight: 22, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>{data.usageNote}</Text>
                                        </View>
                                    )}

                                    {data?.etymology && (
                                        <View>
                                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                                <Globe size={14} color={theme.secondary} style={{ marginRight: 6 }} />
                                                <Text style={{ fontSize: 12, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase' }}>Origin & Etymology</Text>
                                            </View>
                                            <Text style={{ color: theme.secondary, fontSize: 14, lineHeight: 20, fontStyle: 'italic', ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>{data.etymology}</Text>
                                        </View>
                                    )}
                                </View>
                            )}
                        </View>
                    )}

                    {/* Always show Quiz Button if not loading */}
                    {onStartQuiz && (
                        <View style={{ marginTop: 30, marginBottom: 20 }}>
                            <TouchableOpacity
                                onPress={onStartQuiz}
                                style={{
                                    backgroundColor: primaryColor,
                                    padding: 16,
                                    borderRadius: 12,
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: 10,
                                    shadowColor: primaryColor,
                                    shadowOffset: { width: 0, height: 4 },
                                    shadowOpacity: 0.3,
                                    shadowRadius: 8,
                                    elevation: 5
                                }}
                            >
                                <BrainCircuit size={20} color="white" />
                                <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 16 }}>Start Quiz on this Word</Text>
                            </TouchableOpacity>
                        </View>
                    )}

                </ScrollView>
            </View>
        )
    };

    // NEW: Delete Custom Tool Function
    const handleDeleteCustomTool = async (toolId: string) => {
        Alert.alert(
            "Delete Custom Role",
            "Are you sure you want to delete this custom role?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Delete",
                    style: "destructive",
                    onPress: async () => {
                        const newTools = customTools.filter((t: any) => t.id !== toolId);
                        setCustomTools(newTools);
                        await AsyncStorage.setItem('customTools', JSON.stringify(newTools));

                        // If the deleted tool was selected, reset selection
                        if (selectedScenario?.id === toolId) {
                            setSelectedScenario(SCHOOL_TOOLS[0]); // Default to Writer
                        }
                    }
                }
            ]
        );
    };

    const renderSetupScreen = () => {
        const fixedInputTools = ["ml_tutor", "teacher", "ai_for_everyone", "tech_guide", "ai_usage", "prompt_engineer", "grammar_guide", "writer", "idiom_guide", "editorial_writer", "greetings_gen"];
        // UPDATED: Added selectedScenario?.isCustom to force fixed input mode for custom roles
        const isFixedInputMode = fixedInputTools.includes(selectedScenario?.id) || selectedScenario?.isCustom;
        const expandedInputTools = ["journal_buddy", "summarizer"];
        const isExpandedInputMode = expandedInputTools.includes(selectedScenario?.id);

        // NEW: Special Render for Help & Guide Character
        if (selectedScenario?.id === 'help_guide_char') {
            return (
                <View style={{ flex: 1, backgroundColor: theme.bg }}>

                    <ScrollView contentContainerStyle={{ paddingHorizontal: 20, paddingBottom: 40 }}>
                        {/* ReaderApp Advertisement Card - Elite Version */}
                        <View style={{ marginBottom: 20, marginTop: 10 }}>
                            <LinearGradient
                                colors={['#4f46e5', '#9333ea']}
                                start={{ x: 0, y: 0 }}
                                end={{ x: 1, y: 1 }}
                                style={[styles.adContainer, {
                                    borderColor: theme.border,
                                    marginBottom: 0,
                                    borderBottomLeftRadius: 0,
                                    borderBottomRightRadius: 0,
                                    borderBottomWidth: 0,
                                    justifyContent: 'center',
                                    alignItems: 'center'
                                }]}
                            >
                                <Heart size={120} color="white" style={{ position: 'absolute', right: -20, top: -20, opacity: 0.1 }} />
                                <Star
                                    size={60}
                                    color="white"
                                    style={{ position: 'absolute', left: -20, bottom: -20, opacity: 0.1 }}
                                />

                                <View style={{ alignItems: 'center', zIndex: 1 }}>
                                    <View style={{
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        marginBottom: 8,
                                        backgroundColor: 'rgba(0,0,0,0.3)', // Darker glass for contrast
                                        borderWidth: 1,
                                        borderColor: '#FFD700', // Gold Border
                                        paddingHorizontal: 12,
                                        paddingVertical: 4,
                                        borderRadius: 20,
                                        shadowColor: '#FFD700',
                                        shadowOffset: { width: 0, height: 0 },
                                        shadowOpacity: 0.5,
                                        shadowRadius: 10,
                                        elevation: 5 // Android Glow
                                    }}>
                                        <Trophy size={14} color="#FFD700" fill="#FFD700" style={{ marginRight: 6 }} />
                                        <Text style={{ color: '#FFD700', fontWeight: 'bold', fontSize: 12, textTransform: 'uppercase', letterSpacing: 1.5 }}>ELITE</Text>
                                    </View>
                                    <Text style={styles.adTitle}>ReaderApp</Text>
                                    <Text style={styles.adSubtitle}>Built with â¤ï¸ by Mukesh Yadav</Text>
                                </View>
                            </LinearGradient>

                            <View style={{
                                backgroundColor: theme.uiBg,
                                padding: 20,
                                borderBottomLeftRadius: 16,
                                borderBottomRightRadius: 16,
                                borderWidth: 1,
                                borderColor: theme.border,
                                borderTopWidth: 0
                            }}>
                                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
                                    <Sparkles size={18} color="#eab308" style={{ marginRight: 8 }} fill="#eab308" />
                                    <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Supercharge Your Learning</Text>
                                </View>

                                <Text style={{ fontSize: 14, color: theme.secondary, lineHeight: 24, marginBottom: 20 }}>
                                    â€¢ Generate unlimited stories & articles{'\n'}
                                    â€¢ Learn languages with instant translation{'\n'}
                                    â€¢ Master subjects with AI quizzes{'\n'}
                                    â€¢ Listen on the go with Offline Audio
                                </Text>

                                <TouchableOpacity
                                    onPress={() => Linking.openURL('https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp')}
                                    style={{
                                        backgroundColor: primaryColor,
                                        paddingVertical: 12,
                                        borderRadius: 12,
                                        alignItems: 'center',
                                        flexDirection: 'row',
                                        justifyContent: 'center',
                                        gap: 8,
                                        shadowColor: primaryColor,
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.2,
                                        shadowRadius: 4,
                                        elevation: 3
                                    }}
                                >
                                    <Star size={16} color="white" fill="white" />
                                    <Text style={{ color: 'white', fontWeight: 'bold' }}>Rate Us 5 Stars</Text>
                                </TouchableOpacity>
                            </View>
                        </View>

                        {/* Header */}
                        <View style={{ marginBottom: 20 }}>
                            <Text style={{ fontSize: 22, fontWeight: 'bold', color: theme.text, marginBottom: 5 }}>Help Center</Text>
                            <Text style={{ color: theme.secondary, fontSize: 14 }}>Guides, tutorials, and tips to master the app.</Text>
                        </View>

                        {/* Video Tutorials Card */}
                        <TouchableOpacity
                            onPress={() => Linking.openURL('https://youtube.com/playlist?list=PLkvR3Ns_82-MGvrTdHU4tDTB-olmB1DJt&si=xaZoa7sAh17g5TT0')}
                            style={{
                                flexDirection: 'row',
                                alignItems: 'center',
                                padding: 20,
                                backgroundColor: theme.uiBg,
                                borderRadius: 16,
                                borderWidth: 1,
                                borderColor: theme.border,
                                marginBottom: 25,
                                shadowColor: "#ef4444",
                                shadowOffset: { width: 0, height: 4 },
                                shadowOpacity: 0.1,
                                shadowRadius: 8,
                                elevation: 3
                            }}
                        >
                            <View style={{ width: 48, height: 48, borderRadius: 24, backgroundColor: '#fee2e2', alignItems: 'center', justifyContent: 'center', marginRight: 15 }}>
                                <Youtube size={24} color="#ef4444" fill="#ef4444" />
                            </View>
                            <View style={{ flex: 1 }}>
                                <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text, marginBottom: 4 }}>Video Tutorials</Text>
                                <Text style={{ fontSize: 13, color: theme.secondary }}>Watch step-by-step guides on YouTube</Text>
                            </View>
                            <ExternalLink size={20} color={theme.secondary} />
                        </TouchableOpacity>

                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 12, textTransform: 'uppercase', marginBottom: 15, letterSpacing: 1 }}>APP FEATURE GUIDES</Text>

                        <View style={{ gap: 12 }}>
                            {[
                                {
                                    title: "Flashcards 101",
                                    icon: Layers,
                                    desc: "Create & Study Decks",
                                    content: "# ðŸ—‚ï¸ Flashcards 101\n\nMaster your memory with ease.\n\n### How to Create:\n1. **Vision**: Take a picture of your notes/textbook and ask 'Make flashcards'.\n2. **Quiz Mode**: Select 'Flashcards' target instead of 'Quiz'.\n3. **From History**: Tap any session in Recent Activity to resume studying.\n\n### Study Features:\n- **Tap to Flip**: Reveal the answer.\n- **Swipe**: Next/Previous card.\n- **Progress Tracking**: See which card you're on (e.g., 3/10).\n- **Rich Text**: Supports **bold**, math ($x^2$), and headers.\n- **Resume Anytime**: Your progress is automatically saved."
                                },
                                {
                                    title: "Getting Started",
                                    icon: Cpu,
                                    desc: "API Key & Setup",
                                    content: "# ðŸš€ Getting Started\n\nTo unlock the full power of AI features like Chat, Vision, and Quizzes, you need a Google Gemini API Key.\n\n### How to set up:\n1. Go to **Settings** in this app (Gear icon).\n2. Tap the button 'Get Free Gemini API Key'.\n3. Sign in with your Google account.\n4. Create a new key and copy the string starting with 'AIza...'.\n5. Paste it into the box in Settings.\n\n**Why?** Your key allows the app to communicate with Google's AI servers directly. It is stored securely on your device."
                                },
                                {
                                    title: "Library Manager",
                                    icon: Library,
                                    desc: "Manage saved content",
                                    content: "# ðŸ“‚ Library Manager\n\nYour central hub for all saved content.\n\n### Tabs:\n- **Journals**: Your generated stories, articles, and chats.\n- **Vocabulary**: Saved words with expandable dictionary view.\n- **Questions**: Saved quiz questions.\n\n### Personal Dictionary Features:\n- **Preview Word**: First word always visible as a preview card.\n- **Expand/Collapse**: Tap the button to view all saved words.\n- **Independent Scrolling**: Dictionary scrolls separately from other content.\n- **Pagination**: Loads 25 words at a time for smooth performance.\n\n### How to Delete:\n- **Long-press** any item (journals, vocabulary, questions, or recent activity) to reveal the Delete option.\n- **Reset**: To clear everything at once, go to **Settings** > Storage > Reset Library."
                                },
                                {
                                    title: "Open External Files",
                                    icon: Files,
                                    desc: "Open .txt/.json from device",
                                    content: "# ðŸ“‚ Open External Files\n\nSeamlessly open files from your device directly into ReaderApp.\n\n### Supported Files:\n- **.txt**: Plain text files.\n- **.json**: App backups, Dictionaries, or data bundles.\n\n### How to use:\n1. Go to your phone's **File Manager** or **Files** app.\n2. Tap on a supported file.\n3. Choose **ReaderApp** in the \"Open with\" menu.\n\n### Automatic Detection:\n- **Notes**: Text files become new Notes.\n- **Backups**: The app detects library/dictionary structure and asks to import."
                                },
                                {
                                    title: "Offline Audio",
                                    icon: DownloadCloud,
                                    desc: "Listen anywhere",
                                    content: "# ðŸŽ§ Offline Audio\n\nListen to high-quality AI narration without an internet connection.\n\n### How it works:\n1. Ensure **Online TTS** is enabled in **Settings**.\n2. In Reader Mode, simply tap the **Speaker Icon** to play.\n3. The app will automatically download the high-quality voice in the background.\n\n### ðŸ“¤ Custom Audio Upload:\nYou can now upload your own audio files (MP3, WAV) for any chapter or note! Tap the **Audio Upload** button in Reader Mode to add your custom recordings. Your uploaded audio will play instead of the AI voice for that session.\n\n**Note**: The first time you play a long story, it may take **3-4 minutes** to generate and download the full audio. Once downloaded, it is saved to your Library and plays instantly offline!"
                                }
                            ].map((tip, idx) => (
                                <TouchableOpacity
                                    key={idx}
                                    onPress={() => openTipInReader(tip.title, tip.content, 'setup')}
                                    style={{
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        padding: 16,
                                        backgroundColor: theme.uiBg,
                                        borderRadius: 16,
                                        borderWidth: 1,
                                        borderColor: theme.border
                                    }}
                                >
                                    <View style={{ width: 40, height: 40, borderRadius: 12, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center', marginRight: 15 }}>
                                        <tip.icon size={20} color={primaryColor} />
                                    </View>
                                    <View style={{ flex: 1 }}>
                                        <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 15, marginBottom: 2 }}>{tip.title}</Text>
                                        <Text style={{ color: theme.secondary, fontSize: 12 }}>{tip.desc}</Text>
                                    </View>
                                    <ArrowRight size={18} color={theme.secondary} />
                                </TouchableOpacity>
                            ))}
                        </View>

                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 12, textTransform: 'uppercase', marginBottom: 15, marginTop: 30, letterSpacing: 1 }}>CHARACTERS & TOOLS</Text>

                        <View style={{ gap: 12 }}>
                            {[
                                {
                                    title: "Creative Tools",
                                    icon: Coffee,
                                    content: "# ðŸŽ¨ Creative Tools\n\n**Vision**: \nSimply take a photo of anything to get information. Perfect for identifying objects, reading text, or getting help with visual problems.\n\n**Story Mode**: \nWrite and read interactive stories. You can choose different genres and themes."
                                },
                                {
                                    title: "Study Helpers",
                                    icon: GraduationCap,
                                    content: "# ðŸŽ“ Study Helpers\n\n**Flashcards**: \nCreate decks from photos or topics. Swipe to study, tap to flip, and track your progress.\n\n**Quiz Mode**: \nTest your knowledge on any topic. AI generates questions and grades your answers.\n\n**Personal Dictionary**: \nSave words with definitions and examples. Now supports **Dictionary Drive Import** (download dictionaries via Google Drive links in Settings).\n\n**Custom Audio for Chapters**: \nUpload your own audio files (MP3/WAV) to any session! Your custom recording will replace the AI voice for that specific chapter.\n\n**Recent Activity**: \nQuickly access sessions.\n\n**Personal Assistant & Notes**: \nGet study help, summaries, and keep your notes organized in one place."
                                }
                            ].map((tip, idx) => (
                                <TouchableOpacity
                                    key={idx}
                                    onPress={() => openTipInReader(tip.title, tip.content, 'setup')}
                                    style={{
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        padding: 16,
                                        backgroundColor: theme.uiBg,
                                        borderRadius: 16,
                                        borderWidth: 1,
                                        borderColor: theme.border
                                    }}
                                >
                                    <View style={{ width: 40, height: 40, borderRadius: 12, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center', marginRight: 15 }}>
                                        <tip.icon size={20} color={primaryColor} />
                                    </View>
                                    <View style={{ flex: 1 }}>
                                        <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 15 }}>{tip.title}</Text>
                                    </View>
                                    <ArrowRight size={18} color={theme.secondary} />
                                </TouchableOpacity>
                            ))}
                        </View>
                    </ScrollView>
                </View>
            );
        }

        // NEW: Optimized Landscape Layout for Setup
        if (isLandscape && selectedScenario?.id !== 'examiner') {
            return (
                <View style={{ flex: 1, backgroundColor: theme.bg, flexDirection: 'row' }}>
                    {/* LEFT: Input Area (Expanded for better typing) */}
                    <View style={{ flex: 1, padding: 20, borderRightWidth: 1, borderRightColor: theme.border }}>
                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase', letterSpacing: 0.5 }}>INPUT</Text>
                        <View style={{ flex: 1, marginBottom: 0 }}>
                            <TextInput
                                style={[styles.textArea, {
                                    flex: 1,
                                    color: theme.text,
                                    borderColor: theme.border,
                                    backgroundColor: theme.inputBg,
                                    marginBottom: 0,
                                    fontSize: 16,
                                    textAlignVertical: 'top',
                                    paddingTop: 14,
                                    height: undefined // Fill container
                                }]}
                                placeholder={selectedScenario?.placeholder}
                                placeholderTextColor={theme.secondary}
                                value={schoolConfig.input}
                                onChangeText={(text) => setSchoolConfig({ ...schoolConfig, input: text })}
                                multiline
                            />
                            {renderMicButton('setup_input', { position: 'absolute', bottom: 10, right: 10, backgroundColor: theme.uiBg })}
                        </View>
                    </View>

                    {/* RIGHT: Tools & Actions */}
                    <View style={{ flex: 1, backgroundColor: theme.uiBg }}>
                        {/* Tool Selector */}
                        <View style={{ height: 80, borderBottomWidth: 1, borderColor: theme.border, backgroundColor: theme.bg }}>
                            <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ paddingHorizontal: 10, alignItems: 'center' }}>
                                {[...customTools, ...SCHOOL_TOOLS.filter((t: any) => !t.hidden && !['visual_learner', 'examiner', 'journal_buddy', 'summarizer'].includes(t.id))].map((tool: any) => {
                                    const isSelected = selectedScenario?.id === tool.id;
                                    const IconComponent = tool.isCustom ? (ICON_MAP[tool.iconName] || Bot) : tool.Icon;
                                    return (
                                        <TouchableOpacity
                                            key={tool.id}
                                            onPress={() => {
                                                setSelectedScenario(tool);
                                                setTeacherMode('lesson');
                                                const defLength = tool.id === 'examiner' ? "" : "Medium";
                                                const targetSubject = tool.id === 'examiner' ? lastQuizSubject : "General";
                                                setSchoolConfig({ input: "", length: defLength, complexity: "Intermediate", subject: targetSubject });
                                            }}
                                            style={{ alignItems: 'center', marginHorizontal: 12, opacity: isSelected ? 1 : 0.5 }}
                                        >
                                            <View style={{
                                                width: 40, height: 40,
                                                borderRadius: 12,
                                                backgroundColor: isSelected ? primaryColor : theme.buttonBg,
                                                alignItems: 'center', justifyContent: 'center',
                                                marginBottom: 6,
                                                borderWidth: 1,
                                                borderColor: isSelected ? 'transparent' : theme.border
                                            }}>
                                                <IconComponent size={20} color={isSelected ? 'white' : (theme.toolColor && theme.id !== 'sepia' ? tool.color[1] : theme.text)} />
                                            </View>
                                            <Text style={{ fontSize: 9, fontWeight: isSelected ? 'bold' : '500', color: theme.text }}>{tool.title}</Text>
                                        </TouchableOpacity>
                                    );
                                })}
                            </ScrollView>
                        </View>

                        <ScrollView contentContainerStyle={{ padding: 20 }}>
                            {/* NEW: Greetings Mode Selector in Landscape */}
                            {selectedScenario?.id === 'greetings_gen' && (
                                <View style={{ marginBottom: 15 }}>
                                    <View style={{ flexDirection: 'row', backgroundColor: theme.buttonBg, padding: 4, borderRadius: 12 }}>
                                        <TouchableOpacity
                                            onPress={() => setGreetingsMode('greeting')}
                                            style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: greetingsMode === 'greeting' ? theme.bg : 'transparent', shadowOpacity: greetingsMode === 'greeting' ? 0.1 : 0 }}
                                        >
                                            <Text style={{ fontWeight: 'bold', color: greetingsMode === 'greeting' ? theme.text : theme.secondary, fontSize: 11 }}>Greetings</Text>
                                        </TouchableOpacity>
                                        <TouchableOpacity
                                            onPress={() => setGreetingsMode('quote')}
                                            style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: greetingsMode === 'quote' ? theme.bg : 'transparent', shadowOpacity: greetingsMode === 'quote' ? 0.1 : 0 }}
                                        >
                                            <Text style={{ fontWeight: 'bold', color: greetingsMode === 'quote' ? theme.text : theme.secondary, fontSize: 11 }}>Quotes</Text>
                                        </TouchableOpacity>
                                        <TouchableOpacity
                                            onPress={() => setGreetingsMode('shayari')}
                                            style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: greetingsMode === 'shayari' ? theme.bg : 'transparent', shadowOpacity: greetingsMode === 'shayari' ? 0.1 : 0 }}
                                        >
                                            <Text style={{ fontWeight: 'bold', color: greetingsMode === 'shayari' ? theme.text : theme.secondary, fontSize: 11 }}>Shayari</Text>
                                        </TouchableOpacity>
                                    </View>
                                </View>
                            )}

                            {(uiData.toolPrompts[selectedScenario?.id] || selectedScenario?.id === 'greetings_gen' || selectedScenario?.isCustom || customToolPrompts[selectedScenario?.id]) && (
                                <View>
                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase', letterSpacing: 0.5 }}>QUICK IDEAS</Text>
                                    <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10 }}>

                                        {/* NEW: Vision Button in Landscape */}
                                        {(selectedScenario?.id === 'writer' || selectedScenario?.id === 'health_guide' || selectedScenario?.id === 'greetings_gen' || selectedScenario?.id === 'work_organizer' || selectedScenario?.id === 'editorial_writer' || selectedScenario?.id === 'teacher' || selectedScenario?.isCustom) && (
                                            <TouchableOpacity
                                                onPress={() => {
                                                    let mode = 'writer';
                                                    if (selectedScenario?.isCustom) mode = 'custom';
                                                    if (selectedScenario?.id === 'health_guide') mode = 'doctor';
                                                    if (selectedScenario?.id === 'greetings_gen') mode = 'greetings_gen';
                                                    if (selectedScenario?.id === 'work_organizer') mode = 'work_organizer';
                                                    if (selectedScenario?.id === 'editorial_writer') mode = 'editorial';
                                                    if (selectedScenario?.id === 'teacher') mode = 'teacher';

                                                    setImagePickerMode(mode);
                                                    setShowImageSourceModal(true);
                                                }}
                                                style={{
                                                    width: '48%',
                                                    backgroundColor: theme.buttonBg,
                                                    paddingVertical: 10,
                                                    paddingHorizontal: 4,
                                                    borderRadius: 12,
                                                    borderWidth: 1,
                                                    borderColor: theme.border,
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    flexDirection: 'row',
                                                    gap: 6
                                                }}
                                            >
                                                <Camera size={14} color={primaryColor} />
                                                <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }}>Vision</Text>
                                            </TouchableOpacity>
                                        )}

                                        {/* Standard Prompts with Special Logic for Greetings */}
                                        {(() => {
                                            let prompts = uiData.toolPrompts[selectedScenario?.id];

                                            // Special Handling for Greetings based on Sub-Mode
                                            if (selectedScenario?.id === 'greetings_gen') {
                                                const genPrompts = (uiData.toolPrompts as any)['greetings_gen'];
                                                if (genPrompts && !Array.isArray(genPrompts) && typeof genPrompts === 'object') {
                                                    prompts = (genPrompts as any)[greetingsMode] || [];
                                                } else {
                                                    prompts = [];
                                                }
                                            }

                                            // Standard Prompts
                                            // Fallback for missing prompts
                                            return ((prompts as any) || []).map((item: any, idx: number) => (
                                                <TouchableOpacity
                                                    key={`std-${idx}`}
                                                    onPress={() => setSchoolConfig({ ...schoolConfig, input: item.prompt })}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 10,
                                                        borderRadius: 12,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center'
                                                    }}
                                                >
                                                    <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }} numberOfLines={1}>{item.label}</Text>
                                                </TouchableOpacity>
                                            ));
                                        })()}

                                        {/* Custom Prompts (Roles) */}
                                        {selectedScenario?.quickPrompts?.map((item: any, idx: number) => (
                                            <TouchableOpacity
                                                key={`cust-role-${idx}`}
                                                onPress={() => setSchoolConfig({ ...schoolConfig, input: item.prompt })}
                                                onLongPress={() => handleDeleteCustomPrompt(item.label)}
                                                delayLongPress={500}
                                                style={{
                                                    width: '48%',
                                                    backgroundColor: theme.buttonBg,
                                                    paddingVertical: 10,
                                                    borderRadius: 12,
                                                    borderWidth: 1,
                                                    borderColor: theme.border,
                                                    alignItems: 'center'
                                                }}
                                            >
                                                <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }} numberOfLines={1}>{item.label}</Text>
                                            </TouchableOpacity>
                                        ))}

                                        {/* Custom Prompts (Standard Tools) */}
                                        {customToolPrompts[selectedScenario?.id]?.map((item: any, idx: number) => (
                                            <TouchableOpacity
                                                key={`cust-tool-${idx}`}
                                                onPress={() => setSchoolConfig({ ...schoolConfig, input: item.prompt })}
                                                onLongPress={() => handleDeleteCustomPrompt(item.label)}
                                                delayLongPress={500}
                                                style={{
                                                    width: '48%',
                                                    backgroundColor: theme.buttonBg,
                                                    paddingVertical: 10,
                                                    borderRadius: 12,
                                                    borderWidth: 1,
                                                    borderColor: theme.border,
                                                    alignItems: 'center'
                                                }}
                                            >
                                                <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }} numberOfLines={1}>{item.label}</Text>
                                            </TouchableOpacity>
                                        ))}

                                        {/* Add Button for ALL Roles (Custom & Standard) */}
                                        <TouchableOpacity
                                            onPress={() => {
                                                setNewPromptData({ label: "", prompt: "" });
                                                setShowPromptCreator(true);
                                            }}
                                            style={{
                                                width: '48%',
                                                backgroundColor: theme.buttonBg,
                                                paddingVertical: 10,
                                                borderRadius: 12,
                                                borderWidth: 1,
                                                borderColor: theme.border,
                                                borderStyle: 'dashed',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                flexDirection: 'row',
                                                gap: 6
                                            }}
                                        >
                                            <Plus size={14} color={theme.secondary} />
                                            <Text style={{ color: theme.secondary, fontSize: 12, fontWeight: '600' }}>Add New</Text>
                                        </TouchableOpacity>
                                    </View>
                                </View>
                            )}
                        </ScrollView>

                        <View style={{ padding: 20, borderTopWidth: 1, borderTopColor: theme.border, backgroundColor: theme.bg }}>
                            <TouchableOpacity
                                onPress={handleStartScenario}
                                style={{
                                    backgroundColor: primaryColor,
                                    paddingVertical: 16,
                                    borderRadius: 16,
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    flexDirection: 'row',
                                    gap: 8
                                }}
                            >
                                <Sparkles size={20} color="white" />
                                <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 16 }}>{selectedScenario?.actionLabel || "Start"}</Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                </View>
            );
        }

        return (
            <View style={{ flex: 1, backgroundColor: theme.bg }}>
                {selectedScenario?.id !== 'examiner' && (
                    <View style={{ height: 90, borderBottomWidth: 1, borderColor: theme.border, backgroundColor: theme.uiBg }}>
                        <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ paddingHorizontal: 10, alignItems: 'center' }}>
                            {/* COMBINED LIST: Custom Tools First + Standard Tools */}
                            {[...customTools, ...SCHOOL_TOOLS.filter((t: any) => !t.hidden && !['visual_learner', 'examiner', 'journal_buddy', 'summarizer'].includes(t.id))].map((tool: any) => {
                                const isSelected = selectedScenario?.id === tool.id;
                                // Determine Icon: Use map for custom strings, or direct component for standard
                                const IconComponent = tool.isCustom ? (ICON_MAP[tool.iconName] || Bot) : tool.Icon;

                                return (
                                    <TouchableOpacity
                                        key={tool.id}
                                        onPress={() => {
                                            setSelectedScenario(tool);
                                            setTeacherMode('lesson'); // Reset to default Lesson mode
                                            // Default length empty for examiner (implies 10), Medium for others
                                            const defLength = tool.id === 'examiner' ? "" : "Medium";
                                            // CHANGED: Use remembered subject for examiner, else default to General
                                            const targetSubject = tool.id === 'examiner' ? lastQuizSubject : "General";
                                            // UPDATED: Reset isLanguageLearning to false on tool switch
                                            setSchoolConfig({ input: "", length: defLength, complexity: "Intermediate", subject: targetSubject, isLanguageLearning: false });
                                        }}
                                        onLongPress={() => {
                                            if (tool.isCustom) {
                                                handleDeleteCustomTool(tool.id);
                                            }
                                        }}
                                        delayLongPress={500}
                                        style={{ alignItems: 'center', marginHorizontal: 12, opacity: isSelected ? 1 : 0.5 }}
                                    >
                                        <View style={{
                                            width: 44, height: 44,
                                            borderRadius: 12,
                                            backgroundColor: isSelected ? primaryColor : theme.buttonBg,
                                            alignItems: 'center', justifyContent: 'center',
                                            marginBottom: 6,
                                            borderWidth: 1,
                                            borderColor: isSelected ? 'transparent' : theme.border
                                        }}>
                                            <IconComponent
                                                size={22}
                                                color={isSelected ? 'white' : (theme.toolColor && theme.id !== 'sepia' ? tool.color[1] : theme.text)}
                                            />
                                        </View>
                                        <Text style={{ fontSize: 10, fontWeight: isSelected ? 'bold' : '500', color: theme.text }}>{tool.title}</Text>
                                    </TouchableOpacity>
                                );
                            })}
                        </ScrollView>
                    </View>
                )}

                <KeyboardAvoidingView
                    behavior={Platform.OS === "ios" ? "padding" : "height"}
                    style={{ flex: 1 }}
                    keyboardVerticalOffset={Platform.OS === 'ios' ? 140 : 0}
                >
                    {isFixedInputMode ? (
                        <View style={{ flex: 1 }}>
                            <View style={{ paddingHorizontal: 20, paddingTop: 20, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: theme.border, backgroundColor: theme.bg, zIndex: 10 }}>
                                {(['teacher', 'ai_for_everyone', 'grammar_guide', 'idiom_guide', 'ml_tutor', 'prompt_engineer', 'tech_guide', 'ai_usage', 'writer'].includes(selectedScenario?.id) || selectedScenario?.isCustom) && (
                                    <View style={{ flexDirection: 'row', backgroundColor: theme.buttonBg, padding: 4, borderRadius: 16, marginBottom: 15 }}>
                                        <TouchableOpacity
                                            onPress={() => setTeacherMode('lesson')}
                                            style={{
                                                flex: 1,
                                                paddingVertical: 8,
                                                alignItems: 'center',
                                                borderRadius: 14,
                                                backgroundColor: teacherMode === 'lesson' ? theme.bg : 'transparent',
                                                shadowColor: "#000",
                                                shadowOffset: { width: 0, height: 1 },
                                                shadowOpacity: teacherMode === 'lesson' ? 0.1 : 0,
                                                shadowRadius: 2,
                                                elevation: teacherMode === 'lesson' ? 2 : 0,
                                            }}
                                        >
                                            <Book size={16} color={teacherMode === 'lesson' ? primaryColor : theme.secondary} style={{ marginBottom: 2 }} />
                                            <Text style={{ fontWeight: 'bold', color: teacherMode === 'lesson' ? theme.text : theme.secondary, fontSize: 12 }}>
                                                {selectedScenario?.id === 'writer' ? 'Write' : 'Lesson'}
                                            </Text>
                                        </TouchableOpacity>
                                        <TouchableOpacity
                                            onPress={() => setTeacherMode('discussion')}
                                            style={{
                                                flex: 1,
                                                paddingVertical: 8,
                                                alignItems: 'center',
                                                borderRadius: 14,
                                                backgroundColor: teacherMode === 'discussion' ? theme.bg : 'transparent',
                                                shadowColor: "#000",
                                                shadowOffset: { width: 0, height: 1 },
                                                shadowOpacity: teacherMode === 'discussion' ? 0.1 : 0,
                                                shadowRadius: 2,
                                                elevation: teacherMode === 'discussion' ? 2 : 0,
                                            }}
                                        >
                                            <MessageSquare size={16} color={teacherMode === 'discussion' ? primaryColor : theme.secondary} style={{ marginBottom: 2 }} />
                                            <Text style={{ fontWeight: 'bold', color: teacherMode === 'discussion' ? theme.text : theme.secondary, fontSize: 12 }}>
                                                {selectedScenario?.id === 'writer' ? 'Coach' : 'Discussion'}
                                            </Text>
                                        </TouchableOpacity>
                                    </View>
                                )}
                                <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase', letterSpacing: 0.5 }}>INPUT</Text>
                                <View>
                                    <TextInput
                                        style={[styles.textArea, {
                                            color: theme.text,
                                            borderColor: theme.border,
                                            backgroundColor: theme.inputBg,
                                            marginBottom: 0,
                                            fontSize: 16,
                                            textAlignVertical: 'top',
                                            paddingTop: 14,
                                            height: 150 // Fixed height for input in this mode
                                        }]}
                                        placeholder={selectedScenario?.placeholder}
                                        placeholderTextColor={theme.secondary}
                                        value={schoolConfig.input}
                                        onChangeText={(text) => setSchoolConfig({ ...schoolConfig, input: text })}
                                        multiline
                                    />
                                    {renderMicButton('setup_input', { position: 'absolute', bottom: 10, right: 10, backgroundColor: theme.uiBg })}
                                </View>
                            </View>
                            <ScrollView
                                contentContainerStyle={{ padding: 20, paddingBottom: 20 }}
                                keyboardShouldPersistTaps="handled"
                                showsVerticalScrollIndicator={false}
                            >
                                {/* NEW: Greetings Mode Selector */}
                                {selectedScenario?.id === 'greetings_gen' && (
                                    <View style={{ marginBottom: 15 }}>
                                        <View style={{ flexDirection: 'row', backgroundColor: theme.buttonBg, padding: 4, borderRadius: 12 }}>
                                            <TouchableOpacity
                                                onPress={() => setGreetingsMode('greeting')}
                                                style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: greetingsMode === 'greeting' ? theme.bg : 'transparent', shadowOpacity: greetingsMode === 'greeting' ? 0.1 : 0 }}
                                            >
                                                <Text style={{ fontWeight: 'bold', color: greetingsMode === 'greeting' ? theme.text : theme.secondary, fontSize: 12 }}>Greetings</Text>
                                            </TouchableOpacity>
                                            <TouchableOpacity
                                                onPress={() => setGreetingsMode('quote')}
                                                style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: greetingsMode === 'quote' ? theme.bg : 'transparent', shadowOpacity: greetingsMode === 'quote' ? 0.1 : 0 }}
                                            >
                                                <Text style={{ fontWeight: 'bold', color: greetingsMode === 'quote' ? theme.text : theme.secondary, fontSize: 12 }}>Quotes</Text>
                                            </TouchableOpacity>
                                            <TouchableOpacity
                                                onPress={() => setGreetingsMode('shayari')}
                                                style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: greetingsMode === 'shayari' ? theme.bg : 'transparent', shadowOpacity: greetingsMode === 'shayari' ? 0.1 : 0 }}
                                            >
                                                <Text style={{ fontWeight: 'bold', color: greetingsMode === 'shayari' ? theme.text : theme.secondary, fontSize: 12 }}>Shayari</Text>
                                            </TouchableOpacity>
                                        </View>
                                    </View>
                                )}

                                {/* UPDATED: Use uiData for Quick Prompts to support translation */}
                                {(uiData.toolPrompts[selectedScenario?.id] || selectedScenario?.id === 'greetings_gen' || selectedScenario?.id === 'ai_tutor' || ['teacher', 'ai_for_everyone', 'grammar_guide', 'idiom_guide', 'ml_tutor', 'prompt_engineer', 'tech_guide', 'ai_usage'].includes(selectedScenario?.id) || selectedScenario?.isCustom || customToolPrompts[selectedScenario?.id]) && (
                                    <View style={{ marginTop: 5, marginBottom: 10 }}>
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase', letterSpacing: 0.5 }}>QUICK IDEAS</Text>
                                        <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10 }}>

                                            {/* NEW: Vision Button for Writer, Doctor, Greetings, AI Tutor, Tutor Characters AND Custom Roles */}
                                            {(selectedScenario?.id === 'writer' || selectedScenario?.id === 'health_guide' || selectedScenario?.id === 'greetings_gen' || selectedScenario?.id === 'work_organizer' || selectedScenario?.id === 'editorial_writer' || selectedScenario?.id === 'teacher' || selectedScenario?.id === 'ai_tutor' || ['ai_for_everyone', 'grammar_guide', 'idiom_guide', 'ml_tutor', 'prompt_engineer', 'tech_guide', 'ai_usage'].includes(selectedScenario?.id) || selectedScenario?.isCustom) && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        let mode = 'writer';
                                                        if (selectedScenario?.isCustom) mode = 'custom';
                                                        if (selectedScenario?.id === 'health_guide') mode = 'doctor';
                                                        if (selectedScenario?.id === 'greetings_gen') mode = 'greetings_gen';
                                                        if (selectedScenario?.id === 'work_organizer') mode = 'work_organizer';
                                                        if (selectedScenario?.id === 'editorial_writer') mode = 'editorial';
                                                        if (selectedScenario?.id === 'teacher') mode = 'teacher';
                                                        if (selectedScenario?.id === 'editorial_writer') mode = 'editorial';
                                                        if (selectedScenario?.id === 'teacher') mode = 'teacher';
                                                        if (selectedScenario?.id === 'ai_tutor') mode = 'custom';
                                                        if (['ai_for_everyone', 'grammar_guide', 'idiom_guide', 'ml_tutor', 'prompt_engineer', 'tech_guide', 'ai_usage'].includes(selectedScenario?.id)) mode = 'custom';

                                                        setImagePickerMode(mode);
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Vision</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* Standard Prompts with Special Logic for Greetings using uiData */}
                                            {(() => {
                                                let prompts = uiData.toolPrompts[selectedScenario?.id];

                                                // Special Handling for Greetings based on Sub-Mode
                                                if (selectedScenario?.id === 'greetings_gen') {
                                                    const genPrompts = (uiData.toolPrompts as any)['greetings_gen'];
                                                    prompts = (genPrompts as any) ? (genPrompts as any)[greetingsMode] : [];
                                                }

                                                // NEW: Dynamic Assistant Prompts Override
                                                // If the user has set a profession, we prioritize dynamic prompts
                                                // If dynamic prompts are loading (user has profession but state is null), we show NOTHING or valid cached prompts
                                                // But crucially, we try to avoid showing the 'default' generic prompts if the user is a specific professional
                                                if (selectedScenario?.id === 'ai_tutor') {
                                                    if (dynamicAssistantPrompts) {
                                                        prompts = dynamicAssistantPrompts;
                                                    } else if ((displaySettings as any).userProfession) {
                                                        // If user has a profession but we haven't loaded them yet, better to show nothing or a loading placeholder
                                                        // rather than generic student prompts that might be confusing.
                                                        // For now, let's show an empty list to indicate "loading" implicitly, or nothing.
                                                        prompts = [];
                                                    }
                                                }

                                                return (prompts as any)?.map((item: any, idx: number) => (
                                                    <TouchableOpacity
                                                        key={`std-${idx}`}
                                                        onPress={() => setSchoolConfig({ ...schoolConfig, input: item.prompt })}
                                                        style={{
                                                            width: '48%',
                                                            backgroundColor: theme.buttonBg,
                                                            paddingVertical: 12,
                                                            paddingHorizontal: 4,
                                                            borderRadius: 16,
                                                            borderWidth: 1,
                                                            borderColor: theme.border,
                                                            alignItems: 'center',
                                                            justifyContent: 'center'
                                                        }}
                                                    >
                                                        <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600', textAlign: 'center' }} numberOfLines={1}>{item.label}</Text>
                                                    </TouchableOpacity>
                                                ));
                                            })()}

                                            {/* Custom Prompts (Roles) */}
                                            {selectedScenario?.quickPrompts?.map((item: any, idx: number) => (
                                                <TouchableOpacity
                                                    key={`cust-role-${idx}`}
                                                    onPress={() => setSchoolConfig({ ...schoolConfig, input: item.prompt })}
                                                    onLongPress={() => handleDeleteCustomPrompt(item.label)}
                                                    delayLongPress={500}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center'
                                                    }}
                                                >
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600', textAlign: 'center' }} numberOfLines={1}>{item.label}</Text>
                                                </TouchableOpacity>
                                            ))}

                                            {/* Custom Prompts (Standard Tools) */}
                                            {customToolPrompts[selectedScenario?.id]?.map((item: any, idx: number) => (
                                                <TouchableOpacity
                                                    key={`cust-tool-${idx}`}
                                                    onPress={() => setSchoolConfig({ ...schoolConfig, input: item.prompt })}
                                                    onLongPress={() => handleDeleteCustomPrompt(item.label)}
                                                    delayLongPress={500}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center'
                                                    }}
                                                >
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600', textAlign: 'center' }} numberOfLines={1}>{item.label}</Text>
                                                </TouchableOpacity>
                                            ))}

                                            {/* Add Button for ALL Roles (Custom & Standard) */}
                                            <TouchableOpacity
                                                onPress={() => {
                                                    setNewPromptData({ label: "", prompt: "" });
                                                    setShowPromptCreator(true);
                                                }}
                                                style={{
                                                    width: '48%',
                                                    backgroundColor: theme.buttonBg,
                                                    paddingVertical: 12,
                                                    paddingHorizontal: 4,
                                                    borderRadius: 16,
                                                    borderWidth: 1,
                                                    borderColor: theme.border,
                                                    borderStyle: 'dashed',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    flexDirection: 'row',
                                                    gap: 6
                                                }}
                                            >
                                                <Plus size={16} color={theme.secondary} />
                                                <Text style={{ color: theme.secondary, fontSize: 13, fontWeight: '600' }}>Add New</Text>
                                            </TouchableOpacity>
                                        </View>
                                    </View>
                                )}
                            </ScrollView>

                            <View style={{ padding: 20, borderTopWidth: 1, borderTopColor: theme.border, backgroundColor: theme.bg }}>
                                <TouchableOpacity
                                    onPress={handleStartScenario}
                                    style={{
                                        backgroundColor: primaryColor,
                                        paddingVertical: 16,
                                        borderRadius: 16,
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        flexDirection: 'row',
                                        gap: 8,
                                        shadowColor: primaryColor,
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.3,
                                        shadowRadius: 8,
                                        elevation: 4
                                    }}
                                >
                                    <Sparkles size={20} color="white" />
                                    <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 16 }}>{selectedScenario?.actionLabel || "Start"}</Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    ) : isExpandedInputMode ? (
                        <View style={{ flex: 1, padding: 20 }}>
                            <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase', letterSpacing: 0.5 }}>INPUT</Text>
                            <View style={{ flex: 1, marginBottom: 15 }}>
                                <TextInput
                                    style={[styles.textArea, {
                                        flex: 1,
                                        color: theme.text,
                                        borderColor: theme.border,
                                        backgroundColor: theme.inputBg,
                                        marginBottom: 0,
                                        fontSize: 16,
                                        textAlignVertical: 'top',
                                        paddingTop: 14,
                                        height: undefined,
                                        textAlign: 'left'
                                    }]}
                                    placeholder={selectedScenario?.placeholder}
                                    placeholderTextColor={theme.secondary}
                                    value={schoolConfig.input}
                                    onChangeText={(text) => setSchoolConfig({ ...schoolConfig, input: text })}
                                    multiline
                                />
                                {renderMicButton('setup_input', { position: 'absolute', bottom: 10, right: 10, backgroundColor: theme.uiBg })}
                            </View>
                            <TouchableOpacity
                                onPress={handleStartScenario}
                                style={{
                                    backgroundColor: primaryColor,
                                    paddingVertical: 16,
                                    borderRadius: 16,
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    flexDirection: 'row',
                                    gap: 8,
                                    shadowColor: primaryColor,
                                    shadowOffset: { width: 0, height: 4 },
                                    shadowOpacity: 0.3,
                                    shadowRadius: 8,
                                    elevation: 4
                                }}
                            >
                                <Sparkles size={20} color="white" />
                                <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 16 }}>{selectedScenario?.actionLabel || "Start"}</Text>
                            </TouchableOpacity>
                        </View>
                    ) : (
                        <View style={{ flex: 1 }}>
                            <ScrollView
                                contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                keyboardShouldPersistTaps="handled"
                                showsVerticalScrollIndicator={false}
                            >

                                {selectedScenario?.id === 'ai_tutor' && (
                                    <View style={{ marginBottom: 25 }}>
                                        {/* 1. SEGMENTED TOGGLE (Unified Switch) */}


                                        {/* 2. INPUT AREA (Moved Above Ideas) */}
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase', letterSpacing: 0.5 }}>INPUT</Text>
                                        <View style={{ marginBottom: 20 }}>
                                            <TextInput
                                                style={[styles.textArea, {
                                                    color: theme.text,
                                                    borderColor: theme.border,
                                                    backgroundColor: theme.inputBg,
                                                    marginBottom: 0,
                                                    fontSize: 16,
                                                    textAlignVertical: 'top',
                                                    paddingTop: 14,
                                                    minHeight: 150
                                                }]}
                                                placeholder={selectedScenario?.placeholder}
                                                placeholderTextColor={theme.secondary}
                                                value={schoolConfig.input}
                                                onChangeText={(text) => setSchoolConfig({ ...schoolConfig, input: text })}
                                                multiline
                                            />
                                            {renderMicButton('setup_input', { position: 'absolute', bottom: 10, right: 10, backgroundColor: theme.uiBg })}
                                        </View>

                                        {/* 3. VISION & QUICK ACTIONS */}
                                        {/* 3. VISION & IDEAS HEADER */}
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 12, textTransform: 'uppercase', letterSpacing: 0.5 }}>VISION & IDEAS</Text>

                                        {/* IMAGE PREVIEW ROW - Placed above controls */}
                                        {visionDraft.uris?.length > 0 && (
                                            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={{ marginBottom: 15 }}>
                                                {visionDraft.uris.map((uri: string, idx: number) => (
                                                    <View key={idx} style={{ marginRight: 10, position: 'relative' }}>
                                                        <Image source={{ uri }} style={{ width: 60, height: 60, borderRadius: 8 }} />
                                                        <TouchableOpacity
                                                            onPress={() => setVisionDraft((prev: any) => ({ ...prev, uris: prev.uris.filter((_: any, i: number) => i !== idx) }))}
                                                            style={{ position: 'absolute', top: -5, right: -5, backgroundColor: 'red', borderRadius: 10, width: 20, height: 20, alignItems: 'center', justifyContent: 'center' }}
                                                        >
                                                            <X size={12} color="white" />
                                                        </TouchableOpacity>
                                                    </View>
                                                ))}
                                            </ScrollView>
                                        )}

                                        {/* COMBINED GRID: Vision Button + Quick Ideas */}
                                        <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-between', rowGap: 10 }}>

                                            {/* 1. VISION BUTTON (First Item in Grid) */}
                                            <TouchableOpacity
                                                onPress={() => {
                                                    setImagePickerMode('vision');
                                                    setShowImageSourceModal(true);
                                                }}
                                                style={{
                                                    width: '48%', // 2-Column Grid
                                                    flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: 8,
                                                    backgroundColor: theme.buttonBg,
                                                    paddingVertical: 12, paddingHorizontal: 8,
                                                    borderRadius: 12, borderWidth: 1, borderColor: theme.border
                                                }}
                                            >
                                                <Camera size={16} color={primaryColor} />
                                                <Text style={{ fontSize: 12, fontWeight: '600', color: theme.text }}>
                                                    {visionDraft.uris?.length > 0 ? `${visionDraft.uris.length} Added` : "Add Image"}
                                                </Text>
                                            </TouchableOpacity>

                                            {/* 2. QUICK IDEA CHIPS */}
                                            {/* 2. DYNAMIC QUICK IDEA CHIPS */}
                                            {dynamicAssistantPrompts?.map((item: any, idx: number) => (
                                                <TouchableOpacity
                                                    key={idx}
                                                    onPress={() => setSchoolConfig({ ...schoolConfig, input: item.prompt })}
                                                    style={{
                                                        width: '48%', // 2-Column Grid
                                                        backgroundColor: theme.uiBg,
                                                        paddingVertical: 12, paddingHorizontal: 8,
                                                        borderRadius: 12,
                                                        borderWidth: 1, borderColor: theme.border,
                                                        alignItems: 'center', justifyContent: 'center'
                                                    }}
                                                >
                                                    <Text style={{ fontSize: 12, color: theme.text, textAlign: 'center' }} numberOfLines={2}>{item.label}</Text>
                                                </TouchableOpacity>
                                            ))}
                                        </View>
                                    </View>
                                )}

                                {selectedScenario?.id === 'examiner' && (
                                    <View style={{ marginBottom: 20 }}>
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase', letterSpacing: 0.5 }}>QUIZ MODE</Text>
                                        <View style={{ flexDirection: 'row', gap: 8 }}>
                                            {/* 1. PRACTICE */}
                                            <TouchableOpacity
                                                onPress={() => { setIsExamMode(false); setIsFlashcardMode(false); }}
                                                style={{
                                                    flex: 1,
                                                    backgroundColor: (!isExamMode && !isFlashcardMode) ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.inputBg,
                                                    borderColor: (!isExamMode && !isFlashcardMode) ? primaryColor : theme.border,
                                                    borderWidth: 2,
                                                    borderRadius: 12,
                                                    padding: 10,
                                                    alignItems: 'center',
                                                    justifyContent: 'center'
                                                }}
                                            >
                                                <CheckCircle size={18} color={(!isExamMode && !isFlashcardMode) ? primaryColor : theme.secondary} style={{ marginBottom: 4 }} />
                                                <Text style={{ fontSize: 11, fontWeight: 'bold', color: (!isExamMode && !isFlashcardMode) ? primaryColor : theme.secondary }}>Practice</Text>
                                                <Text style={{ fontSize: 8, color: theme.secondary, marginTop: 2, textAlign: 'center', lineHeight: 10 }} numberOfLines={2}>Instant Feedback</Text>
                                            </TouchableOpacity>

                                            {/* 2. EXAM */}
                                            <TouchableOpacity
                                                onPress={() => { setIsExamMode(true); setIsFlashcardMode(false); }}
                                                style={{
                                                    flex: 1,
                                                    backgroundColor: isExamMode ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.inputBg,
                                                    borderColor: isExamMode ? primaryColor : theme.border,
                                                    borderWidth: 2,
                                                    borderRadius: 12,
                                                    padding: 10,
                                                    alignItems: 'center',
                                                    justifyContent: 'center'
                                                }}
                                            >
                                                <Trophy size={18} color={isExamMode ? primaryColor : theme.secondary} style={{ marginBottom: 4 }} />
                                                <Text style={{ fontSize: 11, fontWeight: 'bold', color: isExamMode ? primaryColor : theme.secondary }}>Exam</Text>
                                                <Text style={{ fontSize: 8, color: theme.secondary, marginTop: 2, textAlign: 'center', lineHeight: 10 }} numberOfLines={2}>Results at End</Text>
                                            </TouchableOpacity>

                                            {/* 3. FLASHCARDS */}
                                            <TouchableOpacity
                                                onPress={() => { setIsFlashcardMode(true); setIsExamMode(false); }}
                                                style={{
                                                    flex: 1,
                                                    backgroundColor: isFlashcardMode ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.inputBg,
                                                    borderColor: isFlashcardMode ? primaryColor : theme.border,
                                                    borderWidth: 2,
                                                    borderRadius: 12,
                                                    padding: 10,
                                                    alignItems: 'center',
                                                    justifyContent: 'center'
                                                }}
                                            >
                                                <Layers size={18} color={isFlashcardMode ? primaryColor : theme.secondary} style={{ marginBottom: 4 }} />
                                                <Text style={{ fontSize: 11, fontWeight: 'bold', color: isFlashcardMode ? primaryColor : theme.secondary }}>Cards</Text>
                                                <Text style={{ fontSize: 8, color: theme.secondary, marginTop: 2, textAlign: 'center', lineHeight: 10 }} numberOfLines={2}>Study Mode</Text>
                                            </TouchableOpacity>
                                        </View>
                                    </View>
                                )}

                                {selectedScenario?.id === 'examiner' && (
                                    <View style={{ marginBottom: 20 }}>
                                        {/* NEW: Horizontal Questions Input Layout */}
                                        <View style={{ flexDirection: 'row', gap: 10, alignItems: 'center' }}>
                                            <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, textTransform: 'uppercase', letterSpacing: 0.5, minWidth: 140 }}>QUESTIONS (MAX 200)</Text>
                                            <TextInput
                                                style={[styles.input, {
                                                    backgroundColor: theme.inputBg,
                                                    color: theme.text,
                                                    borderColor: theme.border,
                                                    marginBottom: 0,
                                                    height: 50,
                                                    paddingVertical: 0,
                                                    flex: 1
                                                }]}
                                                placeholder="Default: 10"
                                                placeholderTextColor={theme.secondary}
                                                keyboardType="number-pad"
                                                value={schoolConfig.length}
                                                onChangeText={(text) => {
                                                    const numeric = text.replace(/[^0-9]/g, '');
                                                    saveSchoolConfig({ length: numeric });
                                                }}
                                            />
                                        </View>
                                    </View>
                                )}

                                {selectedScenario?.id !== 'ai_tutor' && (
                                    <>
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase', letterSpacing: 0.5 }}>INPUT</Text>

                                        {/* NEW: Unified Search-Bar-Style Input for Quiz */}
                                        <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 10 }]}>
                                            <TextInput
                                                style={[styles.searchInput, { color: theme.text, marginLeft: 10 }]}
                                                placeholder={selectedScenario?.placeholder || "Enter topic..."}
                                                placeholderTextColor={theme.secondary}
                                                value={schoolConfig.input}
                                                onChangeText={(text) => setSchoolConfig({ ...schoolConfig, input: text })}
                                                multiline={true}
                                            />

                                            {/* Microphone Button */}
                                            <TouchableOpacity
                                                onPress={() => handleVoiceToggle('setup_input')}
                                                style={{
                                                    width: 38,
                                                    height: 38,
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    marginRight: 4
                                                }}
                                            >
                                                {isTranscribing && voiceTarget === 'setup_input' ? (
                                                    <ActivityIndicator size="small" color={theme.text} />
                                                ) : (
                                                    <Animated.View style={{ opacity: voiceTarget === 'setup_input' ? recordingOpacity : 1 }}>
                                                        <Mic size={20} color={(isRecording && voiceTarget === 'setup_input') ? primaryColor : theme.text} />
                                                    </Animated.View>
                                                )}
                                            </TouchableOpacity>

                                            {/* Vision Button (for quiz only) */}
                                            {selectedScenario?.id === 'examiner' && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('quiz');
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: 38,
                                                        height: 38,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        marginRight: 4
                                                    }}
                                                >
                                                    <Camera size={20} color={theme.text} />
                                                </TouchableOpacity>
                                            )}

                                            {/* Action Button (Start Quiz / Start) */}
                                            <TouchableOpacity
                                                onPress={handleStartScenario}
                                                style={{
                                                    width: 38,
                                                    height: 38,
                                                    alignItems: 'center',
                                                    justifyContent: 'center'
                                                }}
                                            >
                                                {schoolConfig.input.trim().length > 0 ? (
                                                    <ArrowRight size={20} color={primaryColor} />
                                                ) : (
                                                    <Sparkles size={20} color={theme.text} />
                                                )}
                                            </TouchableOpacity>
                                        </View>
                                    </>
                                )}

                                {selectedScenario?.id === 'examiner' && (
                                    <View style={{ marginTop: 5, marginBottom: 10 }}>
                                        {/* NEW: Language Learning Toggle */}
                                        <TouchableOpacity
                                            onPress={() => saveSchoolConfig({ isLanguageLearning: !schoolConfig.isLanguageLearning })}
                                            activeOpacity={0.8}
                                            style={{
                                                flexDirection: 'row',
                                                alignItems: 'center',
                                                backgroundColor: schoolConfig.isLanguageLearning ? (theme.id === 'day' ? '#dcfce7' : 'rgba(34, 197, 94, 0.15)') : theme.inputBg,
                                                padding: 12,
                                                borderRadius: 12,
                                                borderWidth: 1,
                                                borderColor: schoolConfig.isLanguageLearning ? '#22c55e' : theme.border,
                                                marginBottom: 20
                                            }}
                                        >
                                            <View style={{
                                                width: 20, height: 20, borderRadius: 10,
                                                borderWidth: 1.5,
                                                borderColor: schoolConfig.isLanguageLearning ? '#22c55e' : theme.secondary,
                                                backgroundColor: schoolConfig.isLanguageLearning ? '#22c55e' : 'transparent',
                                                alignItems: 'center', justifyContent: 'center',
                                                marginRight: 12
                                            }}>
                                                {schoolConfig.isLanguageLearning && <Check size={12} color="white" strokeWidth={3} />}
                                            </View>
                                            <View style={{ flex: 1 }}>
                                                <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 14 }}>Language Learning Quiz</Text>
                                                <Text style={{ color: theme.secondary, fontSize: 11, marginTop: 2 }}>
                                                    Generate in target language & prevent translation
                                                </Text>
                                            </View>
                                            <Languages size={20} color={schoolConfig.isLanguageLearning ? '#15803d' : theme.secondary} />
                                        </TouchableOpacity>

                                        <EditableSelectionList
                                            label="SUBJECT"
                                            items={availableSubjects}
                                            selectedItem={schoolConfig.subject}
                                            onSelect={(val: string) => {
                                                // CHANGED: Update state and persist selection
                                                saveSchoolConfig({ subject: val });
                                                setLastQuizSubject(val);
                                                AsyncStorage.setItem('lastQuizSubject', val);
                                            }}
                                            onAdd={addSubject}
                                            onDelete={removeSubject}
                                            theme={theme}
                                            placeholder="New Subject"
                                        />
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase', letterSpacing: 0.5 }}>QUICK TOPICS: {schoolConfig.subject?.toUpperCase() || "GENERAL"}</Text>
                                        <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10 }}>
                                            {(() => {
                                                // CHECK CUSTOM PROMPTS FIRST, THEN FALLBACK TO UI DATA (Translated Presets)
                                                const prompts = customSubjectPrompts[schoolConfig.subject] || uiData.subjectPrompts[schoolConfig.subject] || uiData.subjectPrompts["General"];
                                                const sortedPrompts = [...prompts].sort((a, b) => a.label.localeCompare(b.label));

                                                return (
                                                    <>
                                                        {sortedPrompts.map((item: any, idx: number) => (
                                                            <TouchableOpacity
                                                                key={idx}
                                                                onPress={() => saveSchoolConfig({ input: item.prompt })}

                                                                onLongPress={() => handleDeleteQuizTopic(item.label)}
                                                                delayLongPress={500}
                                                                style={{
                                                                    width: '48%',
                                                                    backgroundColor: theme.buttonBg,
                                                                    paddingVertical: 12,
                                                                    paddingHorizontal: 4,
                                                                    borderRadius: 16,
                                                                    borderWidth: 1,
                                                                    borderColor: theme.border,
                                                                    alignItems: 'center',
                                                                    justifyContent: 'center'
                                                                }}
                                                            >
                                                                <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600', textAlign: 'center' }} numberOfLines={1}>{item.label}</Text>
                                                            </TouchableOpacity>
                                                        ))}

                                                        <TouchableOpacity
                                                            onPress={() => {
                                                                setNewPromptData({ label: "", prompt: "" });
                                                                setShowPromptCreator(true);
                                                            }}
                                                            style={{
                                                                width: '48%',
                                                                backgroundColor: theme.buttonBg,
                                                                paddingVertical: 12,
                                                                paddingHorizontal: 4,
                                                                borderRadius: 16,
                                                                borderWidth: 1,
                                                                borderColor: theme.border,
                                                                borderStyle: 'dashed',
                                                                alignItems: 'center',
                                                                justifyContent: 'center',
                                                                flexDirection: 'row',
                                                                gap: 6
                                                            }}
                                                        >
                                                            <Plus size={16} color={theme.secondary} />
                                                            <Text style={{ color: theme.secondary, fontSize: 13, fontWeight: '600' }}>Add New</Text>
                                                        </TouchableOpacity>
                                                    </>
                                                );
                                            })()}
                                        </View>
                                    </View>
                                )}

                                {/* Show Quick Prompts for all tools that have them defined, excluding specific ones if needed */}
                                {(uiData.toolPrompts[selectedScenario?.id] || customToolPrompts[selectedScenario?.id]) && (
                                    <View style={{ marginTop: 5, marginBottom: 10 }}>
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase', letterSpacing: 0.5 }}>QUICK IDEAS</Text>
                                        <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10 }}>

                                            {/* NEW: Vision Button for My Doctor */}
                                            {(selectedScenario?.id === 'health_guide') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('doctor');
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Vision</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Math Solver */}
                                            {(selectedScenario?.id === 'math_solver') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('math');
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Scan Problem</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Email Pro */}
                                            {(selectedScenario?.id === 'email_pro') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('email_pro');
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Scan & Draft</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Greetings */}
                                            {(selectedScenario?.id === 'greetings_gen') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('greetings_gen');
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Vision</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Word Help */}
                                            {(selectedScenario?.id === 'word_help') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('word_help');
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Scan Text</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Organizer */}
                                            {(selectedScenario?.id === 'work_organizer') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('work_organizer');
                                                        setVisionDraft({ uris: [], prompt: "" }); // Reset draft
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Scan Docs</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Editorial */}
                                            {(selectedScenario?.id === 'editorial_writer') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('editorial');
                                                        setVisionDraft({ uris: [], prompt: "" });
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Scan Article</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Writer */}
                                            {(selectedScenario?.id === 'writer') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('writer');
                                                        setVisionDraft({ uris: [], prompt: "" });
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Scan Prompt</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Story */}
                                            {(selectedScenario?.id === 'story_generator') && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('story');
                                                        setVisionDraft({ uris: [], prompt: "" });
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Visual Prompt</Text>
                                                </TouchableOpacity>
                                            )}

                                            {/* NEW: Vision Button for Custom Roles */}
                                            {(selectedScenario?.isCustom) && (
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        setImagePickerMode('custom');
                                                        setVisionDraft({ uris: [], prompt: "" });
                                                        setShowImageSourceModal(true);
                                                    }}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexDirection: 'row',
                                                        gap: 6
                                                    }}
                                                >
                                                    <Camera size={16} color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Vision</Text>
                                                </TouchableOpacity>
                                            )}

                                            {(() => {
                                                // MODIFIED: Exclude default tool prompts for ai_tutor
                                                let prompts = [];

                                                if (selectedScenario?.id !== 'ai_tutor') {
                                                    prompts = (uiData as any).toolPrompts[selectedScenario?.id] || [];
                                                }

                                                // NEW: Dynamic Assistant Prompts Override
                                                const assistant = customTools.find((t: any) => t.id === selectedScenario?.id);
                                                if (assistant && assistant.quickPrompts && assistant.quickPrompts.length > 0) {
                                                    prompts = assistant.quickPrompts;
                                                }

                                                return ((prompts as any) || []).map((item: any, idx: number) => (
                                                    <TouchableOpacity
                                                        key={`std-${idx}`}
                                                        onPress={() => saveSchoolConfig({ input: item.prompt })}

                                                        style={{
                                                            width: '48%',
                                                            backgroundColor: theme.buttonBg,
                                                            paddingVertical: 12,
                                                            paddingHorizontal: 4,
                                                            borderRadius: 16,
                                                            borderWidth: 1,
                                                            borderColor: theme.border,
                                                            alignItems: 'center',
                                                            justifyContent: 'center'
                                                        }}
                                                    >
                                                        <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600', textAlign: 'center' }} numberOfLines={1}>{item.label}</Text>
                                                    </TouchableOpacity>
                                                ));
                                            })()}

                                            {/* Custom Prompts (Standard Tools) */}
                                            {customToolPrompts[selectedScenario?.id]?.map((item: any, idx: number) => (
                                                <TouchableOpacity
                                                    key={`cust-tool-${idx}`}
                                                    onPress={() => saveSchoolConfig({ input: item.prompt })}

                                                    onLongPress={() => handleDeleteCustomPrompt(item.label)}
                                                    delayLongPress={500}
                                                    style={{
                                                        width: '48%',
                                                        backgroundColor: theme.buttonBg,
                                                        paddingVertical: 12,
                                                        paddingHorizontal: 4,
                                                        borderRadius: 16,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center'
                                                    }}
                                                >
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600', textAlign: 'center' }} numberOfLines={1}>{item.label}</Text>
                                                </TouchableOpacity>
                                            ))}

                                            {/* Add Button */}
                                            <TouchableOpacity
                                                onPress={() => {
                                                    setNewPromptData({ label: "", prompt: "" });
                                                    setShowPromptCreator(true);
                                                }}
                                                style={{
                                                    width: '48%',
                                                    backgroundColor: theme.buttonBg,
                                                    paddingVertical: 12,
                                                    paddingHorizontal: 4,
                                                    borderRadius: 16,
                                                    borderWidth: 1,
                                                    borderColor: theme.border,
                                                    borderStyle: 'dashed',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    flexDirection: 'row',
                                                    gap: 6
                                                }}
                                            >
                                                <Plus size={16} color={theme.secondary} />
                                                <Text style={{ color: theme.secondary, fontSize: 13, fontWeight: '600' }}>Add New</Text>
                                            </TouchableOpacity>
                                        </View>
                                    </View>
                                )}
                            </ScrollView>
                        </View>
                    )}
                </KeyboardAvoidingView>

                {!isExpandedInputMode && !isFixedInputMode && selectedScenario?.id !== 'examiner' && (
                    <DraggableFAB
                        onPress={handleStartScenario}
                        label={selectedScenario?.actionLabel || "Start"}
                        theme={theme}
                        primaryColor={primaryColor}
                        initialPosition={fabPosition}
                        onPositionChange={setFabPosition}
                    />
                )}
            </View>
        );
    };

    const renderSettingsScreen = () => {
        // Calculate Usage Stats
        // UPDATED: Correctly track Dictionary History (Recent Searches) usage
        const dictHistoryUsed = recentSearches.length;
        const dictLimit = displaySettings.dictionaryLimit || 10000;
        const dictHistoryFree = Math.max(0, dictLimit - dictHistoryUsed);

        // Separate counts for Journals vs Notes
        const allSessions = Object.values(chatSessions);
        const journalsCount = (allSessions as any[]).filter((s: any) => s.toolId !== 'quick_notes').length;
        const notesCount = (allSessions as any[]).filter((s: any) => s.toolId === 'quick_notes').length;

        const wordCount = savedWords.length;
        const questionCount = savedQuestions.length;

        // Variable limit for Journals
        const libLimit = displaySettings.libraryLimit || 2000;

        // Fixed limits for Words and Questions
        const wordLimit = 100; // UPDATED: Match the 100 limit used in toggleSaveWord
        const questionLimit = 200;

        // Calculate Free Space for Library Categories
        const freeSessions = Math.max(0, libLimit - journalsCount);
        const freeWords = Math.max(0, wordLimit - wordCount);
        const freeQs = Math.max(0, questionLimit - questionCount);

        // NEW: Calculate estimated notes capacity based on free disk space
        // Using 5KB (5120 bytes) as a conservative average note size
        const AVG_NOTE_SIZE = 5120;
        const estimatedNoteCapacity = Math.floor(storageStats.free / AVG_NOTE_SIZE);

        // Helper to format numbers like 1000 -> 1K
        const formatK = (v: number) => {
            if (v >= 1000) return `${+(v / 1000).toFixed(1)}K Limit`;
            return `${v} Limit`;
        };

        return (
            <ScrollView style={{ padding: 20 }}>

                {/* NEW: USER PROFILE SETTINGS */}
                <View style={[styles.settingsCard, { backgroundColor: theme.bg, borderColor: theme.border, overflow: 'hidden' }]}>
                    <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 15, paddingHorizontal: 5 }}>
                        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                            <User size={20} color={primaryColor} style={{ marginRight: 10 }} />
                            <Text style={{ fontSize: 14, fontWeight: '800', color: theme.secondary, letterSpacing: 1.5, textTransform: 'uppercase' }}>
                                {displaySettings.userName ? `${displaySettings.userName}` : "USER PROFILE"}
                            </Text>
                        </View>
                        {displaySettings.smartBio && !isEditingProfile && (
                            <TouchableOpacity
                                onPress={() => setIsEditingProfile(true)}
                                style={{ padding: 5 }}
                                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                            >
                                <PenLine size={18} color={primaryColor} />
                            </TouchableOpacity>
                        )}
                    </View>
                    <View style={{ height: 1, backgroundColor: theme.border, marginBottom: 20 }} />

                    {!isEditingProfile && displaySettings.smartBio ? (
                        <LinearGradient
                            colors={[theme.bg, theme.buttonBg]}
                            start={{ x: 0, y: 0 }}
                            end={{ x: 1, y: 1 }}
                            style={{
                                borderRadius: 12,
                                padding: 18,
                                borderWidth: 1,
                                borderColor: theme.border,
                                position: 'relative'
                            }}
                        >
                            <Quote
                                size={24}
                                color={primaryColor}
                                style={{ opacity: 0.15, position: 'absolute', top: 10, left: 10 }}
                            />
                            <Text style={{
                                fontSize: 15,
                                color: theme.text,
                                lineHeight: 24,
                                fontWeight: '500',
                                textAlign: 'justify', // Applied Justify Alignment
                                paddingHorizontal: 5,
                                letterSpacing: 0.3
                            }}>
                                {displaySettings.smartBio}
                            </Text>
                            <Quote
                                size={24}
                                color={primaryColor}
                                style={{
                                    opacity: 0.15,
                                    position: 'absolute',
                                    bottom: 10,
                                    right: 10,
                                    transform: [{ rotate: '180deg' }]
                                }}
                            />

                            <View style={{ marginTop: 15, borderTopWidth: 1, borderTopColor: theme.border, paddingTop: 10 }}>
                                <Text style={{ fontSize: 11, color: theme.secondary, textAlign: 'center', opacity: 0.8, fontStyle: 'italic' }}>
                                    AI-Tailored Profile Summary
                                </Text>
                            </View>
                        </LinearGradient>
                    ) : (
                        <View>
                            <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 8, textTransform: 'uppercase' }}>Your Name</Text>
                            <TextInput
                                style={[styles.input, {
                                    backgroundColor: displaySettings.nameLocked ? theme.buttonBg : theme.inputBg, // Visually indicate lock
                                    color: displaySettings.nameLocked ? theme.secondary : theme.text, // Visually indicate lock
                                    borderColor: theme.border,
                                    marginBottom: 15,
                                    opacity: displaySettings.nameLocked ? 0.7 : 1
                                }]}
                                placeholder="e.g. Mukesh" // UPDATED: Placeholder
                                placeholderTextColor={theme.secondary}
                                value={displaySettings.userName}
                                editable={!displaySettings.nameLocked} // Prevent editing if locked
                                onChangeText={(t) => saveSettings({ userName: t })}
                                onBlur={() => {
                                    // Trigger warning when switching away (e.g., to Profession tab) if name is set but not yet locked
                                    if (displaySettings.userName.trim().length > 0 && !displaySettings.nameLocked) {
                                        Alert.alert(
                                            "Lock Name?",
                                            "Once you set your name, it cannot be edited until you uninstall the application. Confirm?",
                                            [
                                                { text: "Edit", style: "cancel" },
                                                { text: "Confirm", onPress: () => saveSettings({ nameLocked: true }) }
                                            ]
                                        );
                                    }
                                }}
                            />

                            <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 8, textTransform: 'uppercase' }}>Profession / Role</Text>
                            <TextInput
                                style={[styles.input, { backgroundColor: theme.inputBg, color: theme.text, borderColor: theme.border, marginBottom: 15 }]}
                                placeholder="e.g. Student, Engineer, Artist"
                                placeholderTextColor={theme.secondary}
                                // MODIFIED: Use local state to prevent thrashing
                                defaultValue={displaySettings.userProfession}
                                onEndEditing={(e) => saveSettings({ userProfession: e.nativeEvent.text })}
                            />

                            <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 8, textTransform: 'uppercase' }}>Main Goal</Text>
                            <TextInput
                                style={[styles.input, { backgroundColor: theme.inputBg, color: theme.text, borderColor: theme.border, marginBottom: 15 }]}
                                placeholder="e.g. Learn Spanish"
                                placeholderTextColor={theme.secondary}
                                value={displaySettings.userGoal}
                                onChangeText={(val) => saveSettings({ userGoal: val })}
                            />

                            <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 8, textTransform: 'uppercase' }}>How should AI answer you?</Text>
                            <TextInput
                                style={[styles.input, { backgroundColor: theme.inputBg, color: theme.text, borderColor: theme.border, marginBottom: 15, minHeight: 80, textAlignVertical: 'top' }]}
                                placeholder="e.g. Simple terms, professional tone, use analogies, be concise..."
                                placeholderTextColor={theme.secondary}
                                multiline={true}
                                value={displaySettings.userBio}
                                onChangeText={(val) => saveSettings({ userBio: val })}
                            />

                            <TouchableOpacity
                                onPress={async () => {
                                    setIsEditingProfile(false);
                                    await generateSmartBio(null, true);
                                }}
                                disabled={isGeneratingBio}
                                style={{
                                    backgroundColor: theme.buttonBg,
                                    padding: 12,
                                    borderRadius: 8,
                                    borderWidth: 1,
                                    borderColor: theme.border,
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: 8
                                }}
                            >
                                {isGeneratingBio ? (
                                    <ActivityIndicator size="small" color={primaryColor} />
                                ) : (
                                    <>
                                        <Wand2 size={16} color={primaryColor} />
                                        <Text style={{ color: primaryColor, fontWeight: 'bold' }}>Update Smart Bio</Text>
                                    </>
                                )}
                            </TouchableOpacity>
                        </View>
                    )}
                </View>

                {/* 1. CLOUD API SETTINGS */}
                <View style={[styles.settingsCard, { backgroundColor: theme.bg, borderColor: theme.border }]}>
                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 15 }}>
                        <Cpu size={20} color={primaryColor} style={{ marginRight: 10 }} />
                        <Text style={{ fontSize: 14, fontWeight: '700', color: theme.secondary, letterSpacing: 1 }}>CLOUD API SETTINGS</Text>
                    </View>
                    <View style={{ height: 1, backgroundColor: theme.border, marginBottom: 20 }} />

                    {/* Provider Dropdown */}
                    <View style={{ marginBottom: 15 }}>
                        <DropdownInput
                            label="Select AI Provider"
                            value={displaySettings.llmProvider === 'groq' ? 'Groq' : 'Google Gemini'}
                            options={['Google Gemini', 'Groq']}
                            onSelect={(val: string) => {
                                const newProv = val === 'Groq' ? 'groq' : 'gemini';
                                saveSettings({ llmProvider: newProv });
                                setApiConnectionStatus('idle');
                            }}
                            theme={theme}
                        />
                    </View>

                    <TouchableOpacity
                        onPress={() => {
                            if (displaySettings.llmProvider === 'groq') Linking.openURL('https://console.groq.com/keys');
                            else Linking.openURL('https://aistudio.google.com/app/apikey');
                        }}
                        style={{
                            flexDirection: 'row',
                            alignItems: 'center',
                            justifyContent: 'space-between',
                            padding: 15,
                            borderWidth: 1,
                            borderColor: theme.border,
                            borderRadius: 8,
                            marginBottom: 20,
                            backgroundColor: theme.bg
                        }}
                    >
                        <Text style={{ color: primaryColor, fontWeight: 'bold', fontSize: 15 }}>
                            {displaySettings.llmProvider === 'groq' ? 'Get Free Groq API Key' : 'Get Free Gemini API Key'}
                        </Text>
                        <ExternalLink size={16} color={primaryColor} />
                    </TouchableOpacity>

                    <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 10, textTransform: 'uppercase' }}>
                        Your {displaySettings.llmProvider === 'groq' ? 'Groq' : 'Gemini'} API Key
                    </Text>

                    <View style={{ flexDirection: 'row', gap: 10, marginBottom: 20 }}>
                        <TextInput
                            style={{
                                flex: 1,
                                padding: 12,
                                borderRadius: 8,
                                borderWidth: 1,
                                borderColor: apiConnectionStatus === 'success' ? '#22c55e' : (apiConnectionStatus === 'failed' ? '#ef4444' : ((displaySettings.llmProvider === 'groq' ? displaySettings.groqApiKey : customApiKey) ? theme.border : '#ef4444')),
                                backgroundColor: theme.inputBg,
                                color: theme.text,
                                fontSize: 16,
                            }}
                            placeholder="Paste API Key..."
                            placeholderTextColor={theme.secondary}
                            value={displaySettings.llmProvider === 'groq' ? (displaySettings.groqApiKey || "") : customApiKey}
                            onChangeText={async (txt) => {
                                if (displaySettings.llmProvider === 'groq') {
                                    saveSettings({ groqApiKey: txt });
                                } else {
                                    setCustomApiKey(txt);
                                    await AsyncStorage.setItem('apiKey', txt);
                                }
                                setApiConnectionStatus('idle');
                            }}
                            secureTextEntry
                        />

                        <TouchableOpacity
                            onPress={handleTestConnection}
                            style={{
                                width: 50,
                                alignItems: 'center',
                                justifyContent: 'center',
                                backgroundColor: theme.buttonBg,
                                borderRadius: 8,
                                borderWidth: 1,
                                borderColor: theme.border,
                            }}
                        >
                            {apiConnectionStatus === 'testing' ? (
                                <ActivityIndicator size="small" color={primaryColor} />
                            ) : (
                                <Save
                                    size={22}
                                    color={(displaySettings.llmProvider === 'groq' ? displaySettings.groqApiKey : (customApiKey || apiKey)) ? (isRateLimited ? '#ef4444' : '#22c55e') : '#b0bec5'}
                                    strokeWidth={2.5}
                                />
                            )}
                        </TouchableOpacity>
                    </View>

                    {/* NEW: AI INTELLIGENCE SETTINGS MOVED HERE */}
                    <View style={{ height: 1, backgroundColor: theme.border, marginBottom: 20 }} />

                    <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 15, textTransform: 'uppercase' }}>
                        AI Capabilities
                    </Text>

                    {/* Model Priority */}
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
                        <View style={{ flex: 1, marginRight: 10 }}>
                            <Text style={{ fontSize: 15, fontWeight: 'bold', color: theme.text, marginBottom: 4 }}>Model Priority</Text>
                            <Text style={{ fontSize: 12, color: theme.secondary }}>
                                {displaySettings.modelPriority === 'quality' ? 'Best responses (Slower)' : 'Fastest responses (Lower quality)'}
                            </Text>
                        </View>

                        <View style={{
                            flexDirection: 'row',
                            backgroundColor: theme.buttonBg,
                            borderRadius: 14,
                            padding: 4,
                            borderWidth: 1,
                            borderColor: theme.border
                        }}>
                            <TouchableOpacity
                                onPress={() => saveSettings({ modelPriority: 'quality' })}
                                style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    paddingHorizontal: 12,
                                    paddingVertical: 8,
                                    borderRadius: 10,
                                    backgroundColor: displaySettings.modelPriority === 'quality' ? '#8b5cf6' : 'transparent', // Purple for Quality
                                    shadowColor: "#000",
                                    shadowOffset: { width: 0, height: 1 },
                                    shadowOpacity: displaySettings.modelPriority === 'quality' ? 0.2 : 0,
                                    shadowRadius: 2,
                                    elevation: displaySettings.modelPriority === 'quality' ? 2 : 0
                                }}
                            >
                                <Sparkles size={14} color={displaySettings.modelPriority === 'quality' ? 'white' : theme.secondary} style={{ marginRight: 6 }} />
                                <Text style={{
                                    fontSize: 12,
                                    fontWeight: 'bold',
                                    color: displaySettings.modelPriority === 'quality' ? 'white' : theme.secondary
                                }}>Quality</Text>
                            </TouchableOpacity>

                            <TouchableOpacity
                                onPress={() => saveSettings({ modelPriority: 'speed' })}
                                style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    paddingHorizontal: 12,
                                    paddingVertical: 8,
                                    borderRadius: 10,
                                    backgroundColor: displaySettings.modelPriority === 'speed' ? '#22c55e' : 'transparent', // Green for Speed
                                    shadowColor: "#000",
                                    shadowOffset: { width: 0, height: 1 },
                                    shadowOpacity: displaySettings.modelPriority === 'speed' ? 0.2 : 0,
                                    shadowRadius: 2,
                                    elevation: displaySettings.modelPriority === 'speed' ? 2 : 0
                                }}
                            >
                                <Zap size={14} color={displaySettings.modelPriority === 'speed' ? 'white' : theme.secondary} style={{ marginRight: 6 }} />
                                <Text style={{
                                    fontSize: 12,
                                    fontWeight: 'bold',
                                    color: displaySettings.modelPriority === 'speed' ? 'white' : theme.secondary
                                }}>Speed</Text>
                            </TouchableOpacity>
                        </View>
                    </View>

                    {/* Groq-specific: Model Priority + Model Selector */}
                    {displaySettings.llmProvider === 'groq' && (
                        <>
                            {/* Groq Model Priority */}
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
                                <View style={{ flex: 1, marginRight: 10 }}>
                                    <Text style={{ fontSize: 15, fontWeight: 'bold', color: theme.text, marginBottom: 4 }}>Groq Model Priority</Text>
                                    <Text style={{ fontSize: 12, color: theme.secondary }}>
                                        {(displaySettings.groqModelPriority || 'quality') === 'quality' ? 'llama-3.3-70b (Best quality)' : 'llama-3.1-8b (Fastest)'}
                                    </Text>
                                </View>
                                <View style={{
                                    flexDirection: 'row',
                                    backgroundColor: theme.buttonBg,
                                    borderRadius: 14,
                                    padding: 4,
                                    borderWidth: 1,
                                    borderColor: theme.border
                                }}>
                                    <TouchableOpacity
                                        onPress={() => saveSettings({ groqModelPriority: 'quality' })}
                                        style={{
                                            flexDirection: 'row',
                                            alignItems: 'center',
                                            paddingHorizontal: 12,
                                            paddingVertical: 8,
                                            borderRadius: 10,
                                            backgroundColor: (displaySettings.groqModelPriority || 'quality') === 'quality' ? '#8b5cf6' : 'transparent',
                                            elevation: (displaySettings.groqModelPriority || 'quality') === 'quality' ? 2 : 0
                                        }}
                                    >
                                        <Sparkles size={14} color={(displaySettings.groqModelPriority || 'quality') === 'quality' ? 'white' : theme.secondary} style={{ marginRight: 6 }} />
                                        <Text style={{ fontSize: 12, fontWeight: 'bold', color: (displaySettings.groqModelPriority || 'quality') === 'quality' ? 'white' : theme.secondary }}>Quality</Text>
                                    </TouchableOpacity>
                                    <TouchableOpacity
                                        onPress={() => saveSettings({ groqModelPriority: 'speed' })}
                                        style={{
                                            flexDirection: 'row',
                                            alignItems: 'center',
                                            paddingHorizontal: 12,
                                            paddingVertical: 8,
                                            borderRadius: 10,
                                            backgroundColor: displaySettings.groqModelPriority === 'speed' ? '#22c55e' : 'transparent',
                                            elevation: displaySettings.groqModelPriority === 'speed' ? 2 : 0
                                        }}
                                    >
                                        <Zap size={14} color={displaySettings.groqModelPriority === 'speed' ? 'white' : theme.secondary} style={{ marginRight: 6 }} />
                                        <Text style={{ fontSize: 12, fontWeight: 'bold', color: displaySettings.groqModelPriority === 'speed' ? 'white' : theme.secondary }}>Speed</Text>
                                    </TouchableOpacity>
                                </View>
                            </View>

                            {/* Groq Model Selector */}
                            <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 10, textTransform: 'uppercase' }}>Groq Model</Text>
                            <View style={{ flexDirection: 'row', gap: 10, marginBottom: 20 }}>
                                <TouchableOpacity
                                    onPress={() => setShowGroqModelSelector(true)}
                                    style={{
                                        flex: 1, flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between',
                                        padding: 12, borderRadius: 8, borderWidth: 1,
                                        borderColor: theme.border, backgroundColor: theme.inputBg
                                    }}
                                >
                                    <Text style={{ color: displaySettings.groqCustomModel ? theme.text : theme.secondary, fontSize: 14 }} numberOfLines={1}>
                                        {displaySettings.groqCustomModel || 'Auto (use priority preset)'}
                                    </Text>
                                    <ChevronDown size={18} color={theme.secondary} />
                                </TouchableOpacity>
                                {displaySettings.groqCustomModel ? (
                                    <TouchableOpacity
                                        onPress={() => saveSettings({ groqCustomModel: '' })}
                                        style={{ padding: 12, borderRadius: 8, borderWidth: 1, borderColor: theme.border, backgroundColor: theme.buttonBg, justifyContent: 'center' }}
                                    >
                                        <Text style={{ color: '#ef4444', fontSize: 13, fontWeight: 'bold' }}>Clear</Text>
                                    </TouchableOpacity>
                                ) : null}
                            </View>

                            <Modal visible={showGroqModelSelector} transparent animationType="fade" onRequestClose={() => setShowGroqModelSelector(false)}>
                                <TouchableOpacity
                                    style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', padding: 20 }}
                                    activeOpacity={1}
                                    onPress={() => setShowGroqModelSelector(false)}
                                >
                                    <View style={{ backgroundColor: theme.bg, borderRadius: 16, padding: 10, elevation: 5, maxHeight: 400 }}>
                                        <Text style={{ textAlign: 'center', fontWeight: 'bold', color: theme.secondary, marginBottom: 10, marginTop: 5, textTransform: 'uppercase', fontSize: 12 }}>Select Groq Model</Text>
                                        <ScrollView>
                                            {[...GROQ_MODELS, ...(displaySettings.savedGroqCustomModels || [])].map((model: string, i: number, arr: string[]) => (
                                                <TouchableOpacity
                                                    key={model}
                                                    onPress={() => { saveSettings({ groqCustomModel: model }); setShowGroqModelSelector(false); }}
                                                    onLongPress={() => {
                                                        if (!GROQ_MODELS.includes(model)) {
                                                            Alert.alert("Delete Model", `Remove "${model}"?`, [
                                                                { text: "Cancel", style: "cancel" },
                                                                {
                                                                    text: "Delete", style: "destructive", onPress: () => {
                                                                        const newSaved = (displaySettings.savedGroqCustomModels || []).filter((m: string) => m !== model);
                                                                        const newCurrent = displaySettings.groqCustomModel === model ? '' : displaySettings.groqCustomModel;
                                                                        saveSettings({ savedGroqCustomModels: newSaved, groqCustomModel: newCurrent });
                                                                    }
                                                                }
                                                            ]);
                                                        }
                                                    }}
                                                    delayLongPress={500}
                                                    style={{ padding: 15, borderBottomWidth: i === arr.length - 1 ? 0 : 1, borderBottomColor: theme.border, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}
                                                >
                                                    <View>
                                                        <Text style={{ color: theme.text, fontSize: 14, fontWeight: displaySettings.groqCustomModel === model ? 'bold' : '400' }}>{model}</Text>
                                                        {model === 'llama-3.3-70b-versatile' && <Text style={{ fontSize: 10, color: '#8b5cf6', marginTop: 2 }}>â­ Quality preset</Text>}
                                                        {model === 'llama-3.1-8b-instant' && <Text style={{ fontSize: 10, color: '#22c55e', marginTop: 2 }}>âš¡ Speed preset</Text>}
                                                        {!GROQ_MODELS.includes(model) && <Text style={{ fontSize: 10, color: theme.secondary, marginTop: 2 }}>Custom (Long press to delete)</Text>}
                                                    </View>
                                                    {displaySettings.groqCustomModel === model && <Check size={16} color="#2563eb" />}
                                                </TouchableOpacity>
                                            ))}
                                        </ScrollView>
                                    </View>
                                </TouchableOpacity>
                            </Modal>
                        </>
                    )}

                    {/* Online TTS */}
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
                        <View style={{ flex: 1, marginRight: 10 }}>
                            <Text style={{ fontSize: 15, fontWeight: 'bold', color: theme.text, marginBottom: 4 }}>Online TTS</Text>
                            <Text style={{ fontSize: 12, color: theme.secondary }}>High quality AI narrator</Text>
                        </View>
                        <TouchableOpacity
                            activeOpacity={0.8}
                            onPress={() => saveSettings({ onlineTtsEnabled: !displaySettings.onlineTtsEnabled })}
                            style={{
                                width: 60,
                                height: 32,
                                backgroundColor: displaySettings.onlineTtsEnabled ? '#22c55e' : theme.buttonBg,
                                borderRadius: 16, // Round/Pill shape
                                borderWidth: 1,
                                borderColor: displaySettings.onlineTtsEnabled ? '#22c55e' : theme.border,
                                flexDirection: 'row',
                                alignItems: 'center',
                                paddingHorizontal: 4,
                                justifyContent: displaySettings.onlineTtsEnabled ? 'flex-end' : 'flex-start'
                            }}
                        >
                            {displaySettings.onlineTtsEnabled && (
                                <Text style={{ color: 'white', fontSize: 10, fontWeight: 'bold', marginRight: 6 }}>ON</Text>
                            )}
                            <View style={{
                                width: 24,
                                height: 24,
                                borderRadius: 12, // Circular thumb
                                backgroundColor: 'white',
                                shadowColor: "#000",
                                shadowOffset: { width: 0, height: 1 },
                                shadowOpacity: 0.2,
                                shadowRadius: 1,
                                elevation: 2
                            }} />
                            {!displaySettings.onlineTtsEnabled && (
                                <Text style={{ color: theme.secondary, fontSize: 10, fontWeight: 'bold', marginLeft: 6 }}>OFF</Text>
                            )}
                        </TouchableOpacity>
                    </View>

                    {/* AI Images */}
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                        <View style={{ flex: 1, marginRight: 10 }}>
                            <Text style={{ fontSize: 15, fontWeight: 'bold', color: theme.text, marginBottom: 4 }}>AI Images</Text>
                            <Text style={{ fontSize: 12, color: theme.secondary }}>Generate visual diagrams</Text>
                        </View>
                        <TouchableOpacity
                            activeOpacity={0.8}
                            onPress={() => saveSettings({ imageGenerationEnabled: !displaySettings.imageGenerationEnabled })}
                            style={{
                                width: 60,
                                height: 32,
                                backgroundColor: displaySettings.imageGenerationEnabled ? '#22c55e' : theme.buttonBg,
                                borderRadius: 16, // Round/Pill shape
                                borderWidth: 1,
                                borderColor: displaySettings.imageGenerationEnabled ? '#22c55e' : theme.border,
                                flexDirection: 'row',
                                alignItems: 'center',
                                paddingHorizontal: 4,
                                justifyContent: displaySettings.imageGenerationEnabled ? 'flex-end' : 'flex-start'
                            }}
                        >
                            {displaySettings.imageGenerationEnabled && (
                                <Text style={{ color: 'white', fontSize: 10, fontWeight: 'bold', marginRight: 6 }}>ON</Text>
                            )}
                            <View style={{
                                width: 24,
                                height: 24,
                                borderRadius: 12, // Circular thumb
                                backgroundColor: 'white',
                                shadowColor: "#000",
                                shadowOffset: { width: 0, height: 1 },
                                shadowOpacity: 0.2,
                                shadowRadius: 1,
                                elevation: 2
                            }} />
                            {!displaySettings.imageGenerationEnabled && (
                                <Text style={{ color: theme.secondary, fontSize: 10, fontWeight: 'bold', marginLeft: 6 }}>OFF</Text>
                            )}
                        </TouchableOpacity>
                    </View>

                    {/* NEW: Custom Text Model Input with Active Model Display */}
                    <View style={{ marginTop: 20 }}>
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-end', marginBottom: 4 }}>
                            <Text style={{ fontSize: 15, fontWeight: 'bold', color: theme.text }}>Custom Text Model</Text>
                            <View style={{ maxWidth: '50%', alignItems: 'flex-end' }}>
                                <Text style={{ fontSize: 9, color: theme.secondary, marginBottom: 1, fontWeight: '600' }}>CURRENTLY ACTIVE</Text>
                                <Text style={{ fontSize: 10, color: displaySettings.modelPriority === 'speed' ? '#22c55e' : '#8b5cf6', fontWeight: 'bold' }} numberOfLines={1}>
                                    {activeModelId || (displaySettings.customTextModel ? displaySettings.customTextModel : (displaySettings.modelPriority === 'speed' ? "gemini-2.5-flash-lite" : "gemini-2.5-flash-preview-09-2025"))}
                                </Text>
                            </View>
                        </View>
                        <Text style={{ fontSize: 12, color: theme.secondary, marginBottom: 10 }}>
                            Optional: Enter a specific model ID (e.g. gemini-2.5-pro). This will override the default priority.
                        </Text>

                        <View style={{ flexDirection: 'row', gap: 10, marginBottom: 10 }}>
                            <TextInput
                                style={{
                                    flex: 1,
                                    padding: 12,
                                    borderRadius: 12,
                                    borderWidth: 1,
                                    borderColor: theme.border,
                                    backgroundColor: theme.inputBg,
                                    color: theme.text,
                                    fontSize: 14,
                                    height: 50
                                }}
                                placeholder="e.g. gemini-2.5-flash-preview-09-2025"
                                placeholderTextColor={theme.secondary}
                                value={displaySettings.customTextModel}
                                onChangeText={(txt) => saveSettings({ customTextModel: txt })}
                                autoCapitalize="none"
                                autoCorrect={false}
                            />

                            <TouchableOpacity
                                onPress={() => setShowModelSelector(true)}
                                style={{
                                    width: 50,
                                    height: 50,
                                    backgroundColor: theme.buttonBg,
                                    borderRadius: 12,
                                    borderWidth: 1,
                                    borderColor: theme.border,
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}
                            >
                                <ChevronDown size={24} color={theme.text} />
                            </TouchableOpacity>
                        </View>

                        <Modal visible={showModelSelector} transparent animationType="fade" onRequestClose={() => setShowModelSelector(false)}>
                            <TouchableOpacity
                                style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', padding: 20 }}
                                activeOpacity={1}
                                onPress={() => setShowModelSelector(false)}
                            >
                                <View style={{ backgroundColor: theme.bg, borderRadius: 16, padding: 10, shadowColor: "#000", shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.25, shadowRadius: 3.84, elevation: 5, maxHeight: 400 }}>
                                    <Text style={{ textAlign: 'center', fontWeight: 'bold', color: theme.secondary, marginBottom: 10, marginTop: 5, textTransform: 'uppercase', fontSize: 12 }}>Quick Select Model</Text>
                                    <ScrollView>
                                        {[...TEXT_MODELS, ...(displaySettings.savedCustomModels || [])].map((model: string, i: number, arr: string[]) => (
                                            <TouchableOpacity
                                                key={model}
                                                onPress={() => { saveSettings({ customTextModel: model }); setShowModelSelector(false); }}
                                                onLongPress={() => {
                                                    if (!TEXT_MODELS.includes(model)) {
                                                        Alert.alert(
                                                            "Delete Model",
                                                            `Remove "${model}" from your list?`,
                                                            [
                                                                { text: "Cancel", style: "cancel" },
                                                                {
                                                                    text: "Delete",
                                                                    style: "destructive",
                                                                    onPress: () => {
                                                                        const newSaved = (displaySettings.savedCustomModels || []).filter((m: string) => m !== model);
                                                                        // If currently selected, clear selection
                                                                        const newCurrent = displaySettings.customTextModel === model ? "" : displaySettings.customTextModel;
                                                                        saveSettings({ savedCustomModels: newSaved, customTextModel: newCurrent });
                                                                    }
                                                                }
                                                            ]
                                                        );
                                                    }
                                                }}
                                                delayLongPress={500}
                                                style={{
                                                    padding: 15,
                                                    borderBottomWidth: i === arr.length - 1 ? 0 : 1,
                                                    borderBottomColor: theme.border,
                                                    flexDirection: 'row',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}
                                            >
                                                <View>
                                                    <Text style={{ color: theme.text, fontSize: 14, fontWeight: displaySettings.customTextModel === model ? 'bold' : '400' }}>{model}</Text>
                                                    {/* Visual indicator for custom vs default models */}
                                                    {!TEXT_MODELS.includes(model) && (
                                                        <Text style={{ fontSize: 10, color: theme.secondary, marginTop: 2 }}>Custom Added (Long press to delete)</Text>
                                                    )}
                                                </View>
                                                {displaySettings.customTextModel === model && <Check size={16} color="#2563eb" />}
                                            </TouchableOpacity>
                                        ))}
                                    </ScrollView>
                                </View>
                            </TouchableOpacity>
                        </Modal>

                        {/* NEW: Check Availability Button */}
                        <TouchableOpacity
                            onPress={handleCheckModelAvailability}
                            disabled={isCheckingModel}
                            style={{
                                marginTop: 10,
                                backgroundColor: theme.buttonBg,
                                paddingVertical: 12,
                                borderRadius: 12,
                                alignItems: 'center',
                                borderWidth: 1,
                                borderColor: theme.border,
                                flexDirection: 'row',
                                justifyContent: 'center',
                                gap: 8,
                                opacity: isCheckingModel ? 0.7 : 1
                            }}
                        >
                            {isCheckingModel ? (
                                <ActivityIndicator size="small" color={theme.text} />
                            ) : (
                                <CheckCircle size={16} color={theme.text} />
                            )}
                            <Text style={{ fontSize: 13, fontWeight: '600', color: theme.text }}>
                                {isCheckingModel ? "Verifying..." : "Check Availability"}
                            </Text>
                        </TouchableOpacity>
                    </View>

                    <View style={{ height: 1, backgroundColor: theme.border, marginVertical: 20 }} />

                    <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 15, textTransform: 'uppercase' }}>
                        Language & Audio
                    </Text>

                    <EditableSelectionList
                        label="PRIMARY LANGUAGE"
                        items={displaySettings.availableLanguages}
                        selectedItem={displaySettings.language}
                        onSelect={(lang: string) => saveSettings({ language: lang })}
                        onAdd={addLanguage}
                        onDelete={removeLanguage}
                        theme={theme}
                        placeholder="Add language..."
                        maxItems={2}
                        fillSpace={true}
                    />




                    {/* NEW: Offline TTS Language/Voice Selector */}
                    {(() => {
                        // Filter voices based on user's CURRENTLY SELECTED primary language
                        // If user selects "Hindi", show ONLY Hindi voices (even if English is also available)
                        const targetLang = (displaySettings.language || "English").toLowerCase();

                        const filteredVoices = availableVoices.length > 0 ? availableVoices.filter((v) => {
                            // 1. Always include currently selected voice (so it doesn't disappear if language is changed)
                            if (displaySettings.offlineVoice && v.identifier === displaySettings.offlineVoice) return true;

                            // 2. Check if voice label matches the PRIMARY language
                            // e.g. "Hindi (India)" contains "hindi"
                            const matchesLang = v.label.toLowerCase().includes(targetLang);
                            if (!matchesLang) return false;

                            // 3. Exclude network voices (keep only downloaded/local)
                            // Common pattern for Google TTS: "...-network" vs "...-local"
                            if (v.identifier && v.identifier.toLowerCase().includes("network")) return false;

                            return true;
                        }) : [];

                        // Fallback: If filter returns nothing (e.g. no voices for primary lang), show all
                        const voicesToShow = filteredVoices.length > 0 ? filteredVoices : availableVoices;

                        return (
                            <LanguageSelector
                                items={voicesToShow.length > 0
                                    ? voicesToShow.map((v) => ({ code: v.identifier || "", label: v.label }))
                                    : [{ code: "en-GB", label: "English (UK)" }]}
                                selectedItem={displaySettings.offlineVoice}
                                onSelect={(identifier: string) => {
                                    const voice = availableVoices.find(v => v.identifier === identifier);

                                    saveSettings({
                                        offlineVoice: identifier,
                                        offlineTtsLanguage: voice ? voice.code : "en-GB"
                                    });

                                    // NEW: Play preview on selection
                                    Speech.stop();
                                    if (voice) {
                                        const sampleText = `Hello, this is ${voice.label || 'your voice'}.`;
                                        Speech.speak(sampleText, {
                                            voice: identifier,
                                            rate: displaySettings.ttsRate || 1.0,
                                        });
                                    }
                                }}
                                theme={theme}
                            />
                        );
                    })()}




                    <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 15, textTransform: 'uppercase' }}>
                        Online TTS Narrators
                    </Text>
                    <EditableSelectionList
                        label="FEMALE NARRATORS"
                        items={FEMALE_VOICES}
                        selectedItem={displaySettings.voice}
                        onSelect={(v: string) => {
                            saveSettings({ voice: v });
                            playVoicePreview(v); // Trigger preview on select
                        }}
                        theme={theme}
                    />

                    <EditableSelectionList
                        label="MALE NARRATORS"
                        items={MALE_VOICES}
                        selectedItem={displaySettings.voice}
                        onSelect={(v: string) => {
                            saveSettings({ voice: v });
                            playVoicePreview(v); // Trigger preview on select
                        }}
                        theme={theme}
                    />

                    <CleanSlider
                        label="READING SPEED"
                        value={displaySettings.ttsRate}
                        min={0.5} max={2.0}
                        onValueChange={(val: number) => saveSettings({ ttsRate: val })}
                        formatValue={(v: number) => `${v.toFixed(1)}x`}
                        theme={theme}
                    />

                    {/* NEW: Prevent Sleep Toggle */}
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginTop: 10 }}>
                        <View style={{ flex: 1, marginRight: 10 }}>
                            <Text style={{ fontSize: 15, fontWeight: 'bold', color: theme.text, marginBottom: 4 }}>Prevent Sleep</Text>
                            <Text style={{ fontSize: 12, color: theme.secondary }}>Keep screen on while listening</Text>
                        </View>
                        <TouchableOpacity
                            activeOpacity={0.8}
                            onPress={() => saveSettings({ preventSleep: !displaySettings.preventSleep })}
                            style={{
                                width: 60,
                                height: 32,
                                backgroundColor: displaySettings.preventSleep ? '#22c55e' : theme.buttonBg,
                                borderRadius: 16,
                                borderWidth: 1,
                                borderColor: displaySettings.preventSleep ? '#22c55e' : theme.border,
                                flexDirection: 'row',
                                alignItems: 'center',
                                paddingHorizontal: 4,
                                justifyContent: displaySettings.preventSleep ? 'flex-end' : 'flex-start'
                            }}
                        >
                            {displaySettings.preventSleep && (
                                <Text style={{ color: 'white', fontSize: 10, fontWeight: 'bold', marginRight: 6 }}>ON</Text>
                            )}
                            <View style={{
                                width: 24,
                                height: 24,
                                borderRadius: 12,
                                backgroundColor: 'white',
                                shadowColor: "#000",
                                shadowOffset: { width: 0, height: 1 },
                                shadowOpacity: 0.2,
                                shadowRadius: 1,
                                elevation: 2
                            }} />
                            {!displaySettings.preventSleep && (
                                <Text style={{ color: theme.secondary, fontSize: 10, fontWeight: 'bold', marginLeft: 6 }}>OFF</Text>
                            )}
                        </TouchableOpacity>
                    </View>

                </View>

                {/* 2. STORAGE & DATA */}
                <View style={[styles.settingsCard, { backgroundColor: theme.bg, borderColor: theme.border, overflow: 'hidden' }]}>
                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 15 }}>
                        <HardDrive size={20} color={theme.text} style={{ marginRight: 10 }} />
                        <Text style={{ fontSize: 14, fontWeight: '700', color: theme.secondary, letterSpacing: 1 }}>STORAGE & DATA</Text>
                    </View>

                    <View style={{ backgroundColor: theme.uiBg, borderRadius: 12, padding: 15, marginBottom: 20 }}>
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 10 }}>
                            <Text style={{ color: theme.text, fontWeight: '600', fontSize: 13 }}>System Status</Text>
                            <Text style={{ color: primaryColor, fontWeight: 'bold', fontSize: 13 }}>Healthy</Text>
                        </View>

                        {/* NEW: Detailed Storage Stats */}
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 6 }}>
                            <Text style={{ color: theme.secondary, fontSize: 12 }}>Text Data</Text>
                            <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }}>
                                {(storageStats.used / 1024).toFixed(0)} KB
                            </Text>
                        </View>

                        {/* NEW: Audio Size Row */}
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 6 }}>
                            <Text style={{ color: theme.secondary, fontSize: 12 }}>Audio Downloads</Text>
                            <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }}>
                                {(storageStats.audio / 1024 / 1024).toFixed(1)} MB
                            </Text>
                        </View>

                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 12 }}>
                            <Text style={{ color: theme.secondary, fontSize: 12 }}>Device Free Space</Text>
                            <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }}>
                                {(storageStats.free / 1024 / 1024).toFixed(0)} MB
                            </Text>
                        </View>

                        <View style={{ height: 1, backgroundColor: theme.border, marginBottom: 12 }} />

                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                            <View style={{ width: 32, height: 32, borderRadius: 16, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                                <StickyNote size={16} color={primaryColor} />
                            </View>
                            <View>
                                <Text style={{ color: theme.text, fontWeight: 'bold', fontSize: 13 }}>
                                    ~{estimatedNoteCapacity.toLocaleString()} Notes Capacity
                                </Text>
                                <Text style={{ color: theme.secondary, fontSize: 10 }}>
                                    Estimated based on available storage
                                </Text>
                            </View>
                        </View>
                    </View>



                    {/* NEW: Full Data Backup Actions */}
                    <View style={{ marginBottom: 20 }}>
                        <Text style={{ fontSize: 12, fontWeight: '700', color: theme.secondary, marginBottom: 8, textTransform: 'uppercase' }}>FULL DATA BACKUP (LIBRARY + NOTES+ DICTIONARY)</Text>
                        <View style={{ flexDirection: 'row', gap: 10 }}>
                            <TouchableOpacity
                                onPress={handleExportAllData}
                                style={{ flex: 1, backgroundColor: isDay ? '#f0f9ff' : 'rgba(14, 165, 233, 0.1)', padding: 12, borderRadius: 12, alignItems: 'center', flexDirection: 'row', justifyContent: 'center', gap: 6, borderWidth: 1, borderColor: isDay ? '#bae6fd' : 'rgba(14, 165, 233, 0.3)' }}
                            >
                                <Upload size={16} color={isDay ? '#0284c7' : '#38bdf8'} />
                                <Text style={{ color: isDay ? '#0284c7' : '#38bdf8', fontWeight: '600', fontSize: 13 }}>Backup All Data</Text>
                            </TouchableOpacity>

                            <TouchableOpacity
                                onPress={handleImportAllData}
                                style={{ flex: 1, backgroundColor: isDay ? '#f0f9ff' : 'rgba(14, 165, 233, 0.1)', padding: 12, borderRadius: 12, alignItems: 'center', flexDirection: 'row', justifyContent: 'center', gap: 6, borderWidth: 1, borderColor: isDay ? '#bae6fd' : 'rgba(14, 165, 233, 0.3)' }}
                            >
                                <FileDown size={16} color={isDay ? '#0284c7' : '#38bdf8'} />
                                <Text style={{ color: isDay ? '#0284c7' : '#38bdf8', fontWeight: '600', fontSize: 13 }}>Restore Data</Text>
                            </TouchableOpacity>
                        </View>
                    </View>

                    {/* NEW: Data Limits Section */}
                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 15 }}>
                        <HardDrive size={20} color={theme.text} style={{ marginRight: 10 }} />
                        <Text style={{ fontSize: 14, fontWeight: '700', color: theme.secondary, letterSpacing: 1 }}>DATA LIMITS</Text>
                    </View>

                    <IntSlider
                        label="Dictionary History"
                        usageText={`Used: ${dictHistoryUsed} â€¢ Free: ${dictHistoryFree}`}
                        value={displaySettings.dictionaryLimit}
                        min={1000} max={10000}
                        step={500}
                        onValueChange={(val) => saveSettings({ dictionaryLimit: val })}
                        theme={theme}
                        formatValue={formatK}
                    />

                    <IntSlider
                        label="Library Limit (Journals)"
                        usageText={`Used: ${journalsCount} Jrnls â€¢ ${notesCount} Notes (Unlimited)\nFree: ${freeSessions} Jrnls â€¢ ${freeWords} Words â€¢ ${freeQs} Qs`}
                        value={displaySettings.libraryLimit}
                        min={50} max={2000}
                        step={50}
                        onValueChange={(val) => saveSettings({ libraryLimit: val })}
                        theme={theme}
                        formatValue={formatK}
                    />

                    <View style={{ height: 1, backgroundColor: theme.border, marginBottom: 20 }} />

                    <TouchableOpacity
                        onPress={handleResetLibrary}
                        style={{
                            backgroundColor: theme.buttonBg,
                            borderColor: '#ef4444',
                            borderWidth: 1,
                            borderRadius: 12,
                            paddingVertical: 14,
                            alignItems: 'center',
                            flexDirection: 'row',
                            justifyContent: 'center',
                            gap: 8,
                            shadowColor: "#ef4444",
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: 0.05,
                            shadowRadius: 3,
                            elevation: 1
                        }}
                    >
                        <RefreshCcw size={18} color="#ef4444" />
                        <Text style={{ color: "#ef4444", fontWeight: 'bold', fontSize: 14 }}>Reset All Data</Text>
                    </TouchableOpacity>
                </View>

                {/* 4. INTEGRATED SUPPORT & DEVELOPER */}
                <View style={[styles.settingsCard, { backgroundColor: theme.bg, borderColor: theme.border, overflow: 'hidden', padding: 0 }]}>
                    <LinearGradient
                        colors={isDay ? ['#f8f9fa', '#e9ecef'] : [theme.uiBg, theme.inputBg]}
                        style={{ paddingVertical: 30, paddingHorizontal: 20, alignItems: 'center' }}
                    >
                        <View style={{
                            paddingHorizontal: 24,
                            paddingVertical: 12,
                            borderRadius: 18,
                            backgroundColor: primaryColor,
                            alignItems: 'center',
                            justifyContent: 'center',
                            marginBottom: 15,
                            shadowColor: primaryColor,
                            shadowOffset: { width: 0, height: 8 },
                            shadowOpacity: 0.3,
                            shadowRadius: 12,
                            elevation: 10,
                            transform: [{ rotate: '-3deg' }]
                        }}>
                            <Text style={{
                                fontSize: 32,
                                fontWeight: '900',
                                color: 'white',
                                fontFamily: Platform.OS === 'ios' ? 'Georgia' : 'serif',
                                includeFontPadding: false,
                                marginBottom: Platform.OS === 'android' ? 4 : 0
                            }}>Reader</Text>
                            <View style={{
                                position: 'absolute',
                                top: 0, left: 0, right: 0, bottom: 0,
                                borderRadius: 18,
                                borderWidth: 2,
                                borderColor: 'rgba(255,255,255,0.2)'
                            }} />
                        </View>

                        <Text style={{ fontSize: 11, fontWeight: '800', color: theme.secondary, letterSpacing: 2, marginBottom: 6, textTransform: 'uppercase', textAlign: 'center' }}>Developed and Designed By</Text>
                        <Text style={{ fontSize: 24, fontWeight: 'bold', color: theme.text, fontFamily: Platform.OS === 'ios' ? 'Georgia' : 'serif', marginBottom: 4 }}>Mukesh Yadav</Text>
                        <Text style={{ fontSize: 13, color: theme.secondary, marginBottom: 25, fontStyle: 'italic' }}>Building AI for everyone.</Text>

                        {/* Actions Container */}
                        <View style={{ width: '100%', gap: 12 }}>
                            {/* YouTube Button */}
                            {/* Reader App Guide Button (Replaces YouTube) */}
                            <TouchableOpacity
                                onPress={() => {
                                    setSelectedScenario(APP_GUIDE_TOOL);
                                    setAppMode('setup');
                                    setActiveTab('library');
                                }}
                                activeOpacity={0.9}
                                style={{
                                    flexDirection: 'row',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    backgroundColor: '#f59e0b', // Orange to match App Guide theme
                                    paddingVertical: 14,
                                    borderRadius: 16,
                                    shadowColor: "#f59e0b",
                                    shadowOffset: { width: 0, height: 4 },
                                    shadowOpacity: 0.3,
                                    shadowRadius: 6,
                                    elevation: 4
                                }}
                            >
                                <HelpCircle size={20} color="white" style={{ marginRight: 8 }} />
                                <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 15 }}>Reader App Guide</Text>
                            </TouchableOpacity>

                            <View style={{ flexDirection: 'row', gap: 12 }}>
                                {/* Rate Button */}
                                <TouchableOpacity
                                    onPress={() => Linking.openURL('https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp')}
                                    style={{
                                        flex: 1,
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        paddingVertical: 14,
                                        backgroundColor: theme.bg,
                                        borderRadius: 16,
                                        borderWidth: 1,
                                        borderColor: theme.border,
                                        shadowColor: "#000",
                                        shadowOffset: { width: 0, height: 2 },
                                        shadowOpacity: 0.05,
                                        shadowRadius: 3,
                                        elevation: 2
                                    }}
                                >
                                    <Star size={20} color={primaryColor} fill={primaryColor} style={{ marginRight: 8 }} />
                                    <Text style={{ color: theme.text, fontWeight: 'bold', fontSize: 15 }}>Rate & Feedback</Text>
                                </TouchableOpacity>

                                {/* Share Application Button */}
                                <TouchableOpacity
                                    onPress={handleShareApp}
                                    style={{
                                        flex: 1,
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        paddingVertical: 14,
                                        backgroundColor: theme.bg,
                                        borderRadius: 16,
                                        borderWidth: 1,
                                        borderColor: theme.border,
                                        shadowColor: "#000",
                                        shadowOffset: { width: 0, height: 2 },
                                        shadowOpacity: 0.05,
                                        shadowRadius: 3,
                                        elevation: 2
                                    }}
                                >
                                    <Share2 size={20} color={primaryColor} style={{ marginRight: 8 }} />
                                    <Text style={{ color: theme.text, fontWeight: 'bold', fontSize: 15 }}>Share App</Text>
                                </TouchableOpacity>
                            </View>
                        </View>

                        <Text style={{ textAlign: 'center', marginTop: 20, color: theme.secondary, fontSize: 11, fontStyle: 'italic', lineHeight: 16, opacity: 0.8 }}>
                            Your 5-star rating motivates me to keep building new features!
                        </Text>
                    </LinearGradient>
                </View >

                <View style={{ height: 40 }} />
            </ScrollView >
        );
    };

    // NEW: Global Mini Player Component
    const renderMiniPlayer = () => {
        // Show player if TTS is active AND:
        // 1. We are NOT in Reader mode (browsing library/home)
        // 2. OR We ARE in Reader mode, but reading a DIFFERENT chapter than what is playing
        const showPlayer = ttsStatus !== 'stopped' && (appMode !== 'reader' || playingMeta?.id !== readingSession?.id);

        if (!showPlayer) return null;

        // Use the stored metadata for title, falling back to "Audio" if missing
        const title = playingMeta?.title || "Audio Playing";

        return (
            <TouchableOpacity
                onPress={() => {
                    // If we have the session stored, try to open it. 
                    // If it's the current one (shouldn't happen due to logic above), just stay.
                    if (playingMeta?.id) {
                        if (chatSessions[playingMeta.id]) {
                            loadHistorySession(chatSessions[playingMeta.id]);
                        } else if (playingMeta.id.startsWith('orphan_')) {
                            // FIX: Handle reopening of orphan audio files (deleted chapters)
                            // Reconstruct a temporary session so the reader can display the ad/controls
                            const tempSession = {
                                id: playingMeta.id,
                                title: playingMeta.title || "Audio Recording",
                                messages: [{ role: 'ai', content: "" }], // Content cleared to show only banner
                                toolId: 'orphan_audio',
                                timestamp: new Date().toISOString(),
                                hasAudio: true
                            };
                            setReadingSession(tempSession);
                            setAppMode('reader');
                        }
                    }
                }}
                activeOpacity={0.9}
                style={{
                    position: 'absolute',
                    bottom: (appMode === 'idle' ? 60 : 0), // Adjust position above Footer in idle mode
                    left: 0,
                    right: 0,
                    backgroundColor: theme.uiBg,
                    borderTopWidth: 1,
                    borderTopColor: theme.border,
                    flexDirection: 'row',
                    alignItems: 'center',
                    paddingHorizontal: 15,
                    paddingVertical: 10,
                    zIndex: 100,
                    shadowColor: "#000",
                    shadowOffset: { width: 0, height: -2 },
                    shadowOpacity: 0.1,
                    shadowRadius: 4,
                    elevation: 5
                }}
            >
                {/* Playing Indicator/Icon */}
                <View style={{ width: 40, height: 40, borderRadius: 8, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center', marginRight: 12 }}>
                    <Volume2 size={20} color={primaryColor} />
                </View>

                {/* Info */}
                <View style={{ flex: 1, marginRight: 10 }}>
                    <Text style={{ fontSize: 13, fontWeight: 'bold', color: theme.text }} numberOfLines={1}>
                        {title}
                    </Text>
                    <Text style={{ fontSize: 11, color: theme.secondary }}>
                        {ttsStatus === 'playing' ? "Playing..." : "Paused"}
                    </Text>
                </View>

                {/* Controls */}
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 15 }}>
                    {/* Note: Pause/Resume works via global speak/stopTTS refs, but precise seeking requires being in the specific reader session */}
                    <TouchableOpacity onPress={async () => {
                        // NEW: Handle Custom Audio Pause/Resume
                        if (playingMeta?.id && customAudioUrisState[playingMeta.id] && customAudioPlayerRef.current) {
                            if (ttsStatus === 'playing') {
                                customAudioPlayerRef.current.pause();
                                setTtsStatus('paused');
                            } else {
                                customAudioPlayerRef.current.play();
                                setTtsStatus('playing');
                            }
                            return;
                        }

                        if (ttsStatus === 'playing') {
                            // Pause current (Generic pause logic in speak handles this if active)
                            if (currentSound.current) {
                                currentSound.current.pause();
                                speechState.current.isPaused = true;
                                setTtsStatus('paused');
                            } else {
                                stopTTS(); // Offline mode difficult to pause without text context, so stop.
                            }
                        } else {
                            // Resume
                            if (currentSound.current) {
                                currentSound.current.play();
                                speechState.current.isPaused = false;
                                setTtsStatus('playing');
                            }
                        }
                    }}>
                        {ttsStatus === 'playing' ? (
                            <Pause size={24} color={theme.text} />
                        ) : (
                            <PlayCircle size={24} color={theme.text} />
                        )}
                    </TouchableOpacity>

                    <TouchableOpacity onPress={() => stopTTS()}>
                        <X size={24} color={theme.text} />
                    </TouchableOpacity>
                </View>
            </TouchableOpacity>
        );
    };

    // OPTIMIZATION: Memoized Callbacks for Library Items
    const onLibraryItemPress = useCallback((session: any) => {
        handleLibraryPress(session);
    }, [handleLibraryPress]);

    const onLibraryItemLongPress = useCallback((id: string) => {
        handleLibraryLongPress(id);
    }, [handleLibraryLongPress]);

    const onLibraryGroupToggle = useCallback((id: string) => {
        setExpandedJournalGroups((prev: any) => ({ ...prev, [id]: !prev[id] }));
    }, []);

    const onLibraryStoryGroupToggle = useCallback((id: string) => {
        setExpandedStoryGroups((prev: any) => ({ ...prev, [id]: !prev[id] }));
    }, []);

    const onLibraryGroupSelect = useCallback((ids: string[]) => {
        handleGroupSelection(ids);
    }, [handleGroupSelection]);

    const onLibraryGroupLongPress = useCallback((ids: string[]) => {
        if (!isLibrarySelectionMode) {
            setIsLibrarySelectionMode(true);
            setSelectedLibraryIds(ids);
        } else {
            handleGroupSelection(ids);
        }
    }, [isLibrarySelectionMode, handleGroupSelection]);

    const onLibraryChildPress = useCallback((subSession: any) => {
        handleLibraryPress(subSession);
    }, [handleLibraryPress]);

    const onLibraryChildLongPress = useCallback((id: string) => {
        handleLibraryLongPress(id);
    }, [handleLibraryLongPress]);

    // Render Functions
    const renderLibraryItem = useCallback(({ item }: { item: any }) => {
        if (item.isGroup) {
            return (
                <LibraryGroupItem
                    session={item}
                    theme={theme}
                    isSelectionMode={isLibrarySelectionMode}
                    selectedLibraryIds={selectedLibraryIds}
                    isExpanded={!!expandedJournalGroups[item.id]}
                    isLandscape={isLandscape}
                    primaryColor={primaryColor}
                    onToggleExpand={onLibraryGroupToggle}
                    onGroupSelect={onLibraryGroupSelect}
                    onChildPress={onLibraryChildPress}
                    onChildLongPress={onLibraryChildLongPress}
                    onGroupLongPress={onLibraryGroupLongPress}
                    styles={styles}
                />
            );
        }
        return (
            <LibrarySessionItem
                session={item}
                theme={theme}
                isSelected={selectedLibraryIds.includes(item.id)}
                isSelectionMode={isLibrarySelectionMode}
                isLandscape={isLandscape}
                primaryColor={primaryColor}
                onPress={onLibraryItemPress}
                onLongPress={onLibraryItemLongPress}
                styles={styles}
            />
        );
    }, [theme, isLibrarySelectionMode, selectedLibraryIds, expandedJournalGroups, isLandscape, primaryColor, onLibraryGroupToggle, onLibraryGroupSelect, onLibraryChildPress, onLibraryChildLongPress, onLibraryGroupLongPress, onLibraryItemPress, onLibraryItemLongPress, styles]);

    const renderStoryItem = useCallback(({ item }: { item: any }) => {
        if (item.isGroup) {
            return (
                <LibraryGroupItem
                    session={item}
                    theme={theme}
                    isSelectionMode={isLibrarySelectionMode}
                    selectedLibraryIds={selectedLibraryIds}
                    isExpanded={!!expandedStoryGroups[item.id]}
                    isLandscape={isLandscape}
                    primaryColor={primaryColor}
                    onToggleExpand={onLibraryStoryGroupToggle}
                    onGroupSelect={onLibraryGroupSelect}
                    onChildPress={onLibraryChildPress}
                    onChildLongPress={onLibraryChildLongPress}
                    onGroupLongPress={onLibraryGroupLongPress}
                    styles={styles}
                    isStoriesTab={true}
                />
            );
        }
        return (
            <LibrarySessionItem
                session={item}
                theme={theme}
                isSelected={selectedLibraryIds.includes(item.id)}
                isSelectionMode={isLibrarySelectionMode}
                isLandscape={isLandscape}
                primaryColor={primaryColor}
                onPress={onLibraryItemPress}
                onLongPress={onLibraryItemLongPress}
                styles={styles}
            />
        );
    }, [theme, isLibrarySelectionMode, selectedLibraryIds, expandedStoryGroups, isLandscape, primaryColor, onLibraryStoryGroupToggle, onLibraryGroupSelect, onLibraryChildPress, onLibraryChildLongPress, onLibraryGroupLongPress, onLibraryItemPress, onLibraryItemLongPress, styles]);

    // NEW: Unified Search Bar (AI + Library)
    const renderHomeSearchBar = () => (
        <View style={{ zIndex: 100, width: '100%', marginBottom: 15 }}>
            <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 0 }]}>
                {/* UNIFIED SEARCH: Toggle Button Removed. Logic defaults to AI, but shows suggestions for Library. */}

                <TextInput
                    style={[styles.searchInput, { color: theme.text, marginLeft: 10 }]} // Added marginLeft since button is gone
                    // FIXED: Unified Placeholder
                    placeholder="Search library or ask AI..."
                    placeholderTextColor={theme.secondary}
                    value={quickSearchQuery}
                    onChangeText={setQuickSearchQuery}
                    multiline={true}
                />


                <TouchableOpacity
                    onPress={() => handleVoiceToggle('search')}
                    style={{
                        width: 38,
                        height: 38,
                        alignItems: 'center',
                        justifyContent: 'center',
                        marginRight: 4
                    }}
                >
                    {isTranscribing && voiceTarget === 'search' ? (
                        <ActivityIndicator size="small" color={theme.text} />
                    ) : (
                        <Animated.View style={{ opacity: voiceTarget === 'search' ? recordingOpacity : 1 }}>
                            <Mic size={20} color={(isRecording && voiceTarget === 'search') ? primaryColor : theme.text} />
                        </Animated.View>
                    )}
                </TouchableOpacity>

                {/* NEW: Vision Camera Button */}
                <TouchableOpacity
                    onPress={() => {
                        setImagePickerMode('vision');
                        setVisionDraft({ uris: [], prompt: "" });
                        setShowImageSourceModal(true);
                    }}
                    style={{
                        width: 38,
                        height: 38,
                        alignItems: 'center',
                        justifyContent: 'center',
                        marginRight: 4
                    }}
                >
                    <Camera size={20} color={theme.text} />
                </TouchableOpacity>

                <TouchableOpacity onPress={() => handleQuickSearch()} style={{
                    width: 38,
                    height: 38,
                    alignItems: 'center',
                    justifyContent: 'center'
                }}>
                    {quickSearchQuery.trim().length > 0 ? (<ArrowRight size={20} color={primaryColor} />) : (<Search size={20} color={theme.text} />)}
                </TouchableOpacity>
            </View>




            {/* NEW: Autocomplete Suggestions Dropdown for Home Search (Now shows whenever query matches, regardless of mode) */}
            {
                quickSearchQuery.trim().length > 0 && librarySuggestions.length > 0 && (
                    <View style={{
                        position: 'absolute',
                        top: 55, // Just below search bar
                        left: 0,
                        right: 0,
                        backgroundColor: theme.uiBg,
                        borderRadius: 12,
                        borderWidth: 1,
                        borderColor: theme.border,
                        zIndex: 100,
                        shadowColor: "#000",
                        shadowOffset: { width: 0, height: 4 },
                        shadowOpacity: 0.1,
                        shadowRadius: 5,
                        elevation: 5
                    }}>
                        {librarySuggestions.map((session: any, idx: number) => (
                            <TouchableOpacity
                                key={idx}
                                onPress={() => {
                                    setQuickSearchQuery("");
                                    Keyboard.dismiss();
                                    loadHistorySession(session);
                                }}
                                style={{
                                    padding: 15,
                                    borderBottomWidth: idx === librarySuggestions.length - 1 ? 0 : 1,
                                    borderBottomColor: theme.border,
                                    flexDirection: 'row',
                                    alignItems: 'center'
                                }}
                            >
                                <BookOpen size={14} color={theme.secondary} style={{ marginRight: 10 }} />
                                <Text style={{ color: theme.text, fontSize: 16 }} numberOfLines={1}>{session.title}</Text>
                            </TouchableOpacity>
                        ))}
                    </View>
                )
            }
        </View >
    );

    const renderDictionarySearchBar = ({ marginBottom = 15 }: { marginBottom?: number } = {}) => (
        <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: marginBottom, height: 50, borderRadius: 12 }]}>
            <TextInput
                style={[styles.searchInput, { color: theme.text, fontSize: 16, marginLeft: 10 }]}
                placeholder="Type a word..."
                placeholderTextColor={theme.secondary}
                value={dictionaryInput}
                onChangeText={setDictionaryInput}
                onSubmitEditing={() => {
                    if (dictionaryInput.trim()) handleDictionaryTabSearch(dictionaryInput.trim());
                }}
                autoCapitalize="none"
                returnKeyType="search"
            />

            <TouchableOpacity
                onPress={() => handleVoiceToggle('dictionary')}
                style={{
                    width: 38,
                    height: 38,
                    alignItems: 'center',
                    justifyContent: 'center',
                    marginRight: 4
                }}
            >
                {isTranscribing && voiceTarget === 'dictionary' ? (
                    <ActivityIndicator size="small" color={theme.text} />
                ) : (
                    <Animated.View style={{ opacity: voiceTarget === 'dictionary' ? recordingOpacity : 1 }}>
                        <Mic size={20} color={(isRecording && voiceTarget === 'dictionary') ? '#ef4444' : theme.text} />
                    </Animated.View>
                )}
            </TouchableOpacity>

            <TouchableOpacity
                onPress={() => {
                    setImagePickerMode('dictionary_vision');
                    setVisionDraft({ uris: [], prompt: "" });
                    setShowImageSourceModal(true);
                }}
                style={{
                    width: 38,
                    height: 38,
                    alignItems: 'center',
                    justifyContent: 'center',
                    marginRight: 4
                }}
            >
                <Camera size={20} color={theme.text} />
            </TouchableOpacity>

            <TouchableOpacity
                onPress={() => {
                    if (dictionaryInput.trim()) handleDictionaryTabSearch(dictionaryInput.trim());
                }}
                style={{
                    width: 38,
                    height: 38,
                    alignItems: 'center',
                    justifyContent: 'center'
                }}
            >
                {dictionaryInput.trim().length > 0 ? (
                    <ArrowRight size={20} color={primaryColor} />
                ) : (
                    <Search size={20} color={theme.text} />
                )}
            </TouchableOpacity>
        </View>
    );

    // Define headerBg for the main return scope to ensure SafeAreaView picks it up correctly
    let headerBg = isDay ? theme.primary : theme.uiBg;

    // NEW: Adjust header background and status bar style when header is hidden in Reader Mode
    let activeStatusBarStyle = theme.statusBarStyle || "light-content";

    // UPDATED: Hide header in Landscape Reader Mode as well to move controls to sidebar
    if (appMode === 'reader' && (isLandscape || !isReaderSearchExpanded || readingSession?.toolId === 'orphan_audio')) {
        headerBg = theme.bg; // Blend with content background
        // If blending with a light background (Day/Sepia/etc), force dark text for status bar visibility
        if (theme.id === 'day' || theme.id === 'sepia' || theme.id === 'yellow' || theme.id === 'lavender' || theme.id === 'pink' || theme.id === 'ocean' || theme.id === 'forest' || theme.id === 'slate') {
            activeStatusBarStyle = "dark-content";
        } else {
            activeStatusBarStyle = "light-content"; // Keep light text for dark themes
        }
    }

    return (
        <SafeAreaProvider>
            <SafeAreaView style={{ flex: 0, backgroundColor: headerBg }} edges={['top', 'left', 'right']} />
            <SafeAreaView style={[styles.container, { backgroundColor: theme.bg }]} edges={['left', 'right', 'bottom']}>
                <StatusBar
                    barStyle={activeStatusBarStyle}
                />
                <View style={{ flex: 1, backgroundColor: theme.bg }}>
                    {appMode !== 'flashcards' && renderHeader()}



                    <View style={{ flex: 1 }}>
                        {isLoadingHistory && (
                            <View style={[StyleSheet.absoluteFill, { backgroundColor: theme.bg, justifyContent: 'center', alignItems: 'center', zIndex: 1000 }]}>
                                <ActivityIndicator size="large" color={primaryColor} />
                                <Text style={{ marginTop: 20, fontSize: 16, fontWeight: 'bold', color: theme.secondary }}>Opening...</Text>
                            </View>
                        )}

                        {appMode === 'idle' && (
                            <>
                                {activeTab === 'home' ? (
                                    <View style={{ flex: 1 }}>
                                        {/* PERSISTENT HEADER: Greeting + Search Bar (ONLY IN PORTRAIT) */}
                                        {!isLandscape && (
                                            <View style={{
                                                paddingHorizontal: 20,
                                                paddingTop: 15,
                                                paddingBottom: 15,
                                                backgroundColor: theme.bg,
                                                zIndex: 10,
                                                // Subtle divider for separation
                                                borderBottomWidth: 1,
                                                borderBottomColor: theme.id === 'day' ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.05)'
                                            }}>
                                                <View style={[styles.welcomeSection, { marginTop: 0, marginBottom: 15 }]}>
                                                    <Text style={[styles.welcomeTitle, { color: theme.text }]}>Hello, Friend!</Text>
                                                    <Text style={[styles.welcomeSub, { color: theme.secondary }]}>
                                                        What shall we learn in{' '}
                                                        <Text
                                                            onPress={cycleGlobalLanguage}
                                                            style={{ color: primaryColor, fontWeight: 'bold', textDecorationLine: 'underline' }}>
                                                            {displaySettings.language}
                                                        </Text>
                                                        {' '}today?
                                                    </Text>
                                                </View>

                                                {renderHomeSearchBar()}
                                            </View>
                                        )}

                                        <KeyboardAvoidingView
                                            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                                            style={{ flex: 1 }}
                                            keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
                                        >
                                            <ScrollView contentContainerStyle={[styles.scrollContent, { flexGrow: 1, paddingBottom: 100 }]} keyboardShouldPersistTaps="handled">

                                                {/* SCROLLABLE SEARCH BAR (ONLY IN LANDSCAPE) */}
                                                {isLandscape && (
                                                    <View style={{ marginTop: 20, marginBottom: 10, zIndex: 100 }}>
                                                        {renderHomeSearchBar()}
                                                    </View>
                                                )}

                                                {/* UPDATED: Check displaySettings.showPersonalDictionary */}
                                                {displaySettings.showPersonalDictionary && recentSearches.length > 0 && (() => {
                                                    // Handle load more on scroll
                                                    const handleLoadMore = () => {
                                                        if (visibleWordCount < recentSearches.length) {
                                                            setVisibleWordCount((prev: number) => Math.min(prev + 25, 200, recentSearches.length));
                                                        }
                                                    };

                                                    const visibleWords = isDictionaryExpanded
                                                        ? recentSearches.slice(1, visibleWordCount) // Skip first word (shown as preview)
                                                        : [];

                                                    // Get first word for preview
                                                    const firstWord = recentSearches[0];
                                                    const firstDisplayWord = typeof firstWord === 'string' ? firstWord : firstWord.word;
                                                    const firstData = typeof firstWord === 'object' ? firstWord.data : null;
                                                    const firstDisplayDef = firstData?.simple?.definition || firstData?.definition || "Tap to define";
                                                    const firstDisplayPart = firstData?.partOfSpeech;

                                                    return (
                                                        <View style={{ marginBottom: 25, marginTop: 10 }}>
                                                            {/* Header with Word Count and Expand Button */}
                                                            <View style={{
                                                                flexDirection: 'row',
                                                                alignItems: 'center',
                                                                justifyContent: 'space-between',
                                                                marginBottom: 10,
                                                                paddingHorizontal: 4
                                                            }}>
                                                                <Text style={{
                                                                    color: theme.secondary,
                                                                    fontWeight: '700',
                                                                    fontSize: 12,
                                                                    textTransform: 'uppercase'
                                                                }}>
                                                                    Recent Words Flashcards (200)
                                                                </Text>
                                                                <TouchableOpacity
                                                                    onPress={() => setIsDictionaryExpanded(!isDictionaryExpanded)}
                                                                    style={{
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center',
                                                                        gap: 6,
                                                                        paddingVertical: 6,
                                                                        paddingHorizontal: 12,
                                                                        backgroundColor: theme.buttonBg,
                                                                        borderRadius: 12,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border
                                                                    }}
                                                                >
                                                                    <Text style={{
                                                                        fontSize: 12,
                                                                        fontWeight: '600',
                                                                        color: theme.text
                                                                    }}>
                                                                        {isDictionaryExpanded ? 'Collapse' : 'Expand'}
                                                                    </Text>
                                                                    {isDictionaryExpanded ? (
                                                                        <ChevronUp size={16} color={theme.text} />
                                                                    ) : (
                                                                        <ChevronDown size={16} color={theme.text} />
                                                                    )}
                                                                </TouchableOpacity>
                                                            </View>

                                                            {/* First Word Preview (Always Visible) */}
                                                            <TouchableOpacity
                                                                onPress={() => {
                                                                    // Start Flashcards with dynamic count from schoolConfig.length
                                                                    let count = 10;
                                                                    const configLength = parseInt(schoolConfig.length);
                                                                    if (!isNaN(configLength) && configLength > 0) {
                                                                        count = configLength;
                                                                    } else {
                                                                        if (schoolConfig.length === 'Short') count = 5;
                                                                        if (schoolConfig.length === 'Medium') count = 10;
                                                                        if (schoolConfig.length === 'Large') count = 25;
                                                                    }
                                                                    const subset = recentSearches.slice(0, count);
                                                                    const flashcardItems = subset.map((si: any) => {
                                                                        if (typeof si === 'string') return { word: si, definition: 'Tap to see details' };
                                                                        const d = si.data || {};
                                                                        return {
                                                                            ...d,
                                                                            id: d.id,
                                                                            word: d.word || si.word,
                                                                            definition: d.definition || d.simple?.definition || "No definition available",
                                                                            examples: d.examples || d.simple?.examples || []
                                                                        };
                                                                    });

                                                                    setFlashcardSession({
                                                                        items: flashcardItems,
                                                                        currentIndex: 0,
                                                                        flipped: false,
                                                                        type: 'word'
                                                                    });
                                                                    setAppMode('flashcards');
                                                                }}
                                                                onLongPress={() => deleteRecentSearch(firstDisplayWord)}
                                                                style={{
                                                                    flexDirection: 'row',
                                                                    alignItems: 'center',
                                                                    padding: 16,
                                                                    backgroundColor: theme.uiBg,
                                                                    borderRadius: 20,
                                                                    borderWidth: 1,
                                                                    borderColor: theme.border,
                                                                    shadowColor: "#000",
                                                                    shadowOffset: { width: 0, height: 2 },
                                                                    shadowOpacity: 0.05,
                                                                    shadowRadius: 4,
                                                                    elevation: 2,
                                                                    marginBottom: isDictionaryExpanded ? 10 : 0
                                                                }}
                                                            >
                                                                <View style={{ width: 48, height: 48, borderRadius: 14, backgroundColor: theme.id === 'day' ? '#eff6ff' : theme.buttonBg, alignItems: 'center', justifyContent: 'center', marginRight: 16 }}>
                                                                    <BookOpen size={24} color={primaryColor} />
                                                                </View>

                                                                <View style={{ flex: 1 }}>
                                                                    <View style={{ flexDirection: 'row', alignItems: 'baseline', gap: 6 }}>
                                                                        <Text style={{ fontSize: 17, fontWeight: '700', color: theme.text }} numberOfLines={1}>
                                                                            {firstDisplayWord}
                                                                        </Text>
                                                                        {firstDisplayPart && (
                                                                            <Text style={{ fontSize: 12, fontWeight: '600', color: theme.secondary, fontStyle: 'italic' }}>
                                                                                {firstDisplayPart}
                                                                            </Text>
                                                                        )}
                                                                    </View>
                                                                    <Text style={{ fontSize: 13, color: theme.secondary, marginTop: 2 }} numberOfLines={1}>
                                                                        {firstDisplayDef}
                                                                    </Text>
                                                                </View>

                                                                <ChevronRight size={20} color={theme.secondary} opacity={0.5} />
                                                            </TouchableOpacity>

                                                            {/* Expanded Vertical List (Independent Scrolling) */}
                                                            {isDictionaryExpanded && (
                                                                <ScrollView
                                                                    style={{ maxHeight: 600 }}
                                                                    nestedScrollEnabled={true}
                                                                    onScroll={({ nativeEvent }) => {
                                                                        const { layoutMeasurement, contentOffset, contentSize } = nativeEvent;
                                                                        const isCloseToBottom = layoutMeasurement.height + contentOffset.y >= contentSize.height - 50;
                                                                        if (isCloseToBottom) {
                                                                            handleLoadMore();
                                                                        }
                                                                    }}
                                                                    scrollEventThrottle={400}
                                                                    showsVerticalScrollIndicator={true}
                                                                >
                                                                    <View style={{ gap: 10 }}>
                                                                        {visibleWords.map((item: any, index: number) => {
                                                                            const displayWord = typeof item === 'string' ? item : item.word;

                                                                            // Extract Simple/Beginner content
                                                                            const data = typeof item === 'object' ? item.data : null;
                                                                            const displayDef = data?.simple?.definition || data?.definition || "Tap to define";
                                                                            const displayExamples = data?.simple?.examples?.slice(0, 2) || [];
                                                                            const displayPart = data?.partOfSpeech;

                                                                            return (
                                                                                <TouchableOpacity
                                                                                    key={index}
                                                                                    onPress={() => {
                                                                                        // Start Flashcards from this word with dynamic count
                                                                                        let count = 10;
                                                                                        const configLength = parseInt(schoolConfig.length);
                                                                                        if (!isNaN(configLength) && configLength > 0) {
                                                                                            count = configLength;
                                                                                        } else {
                                                                                            if (schoolConfig.length === 'Short') count = 5;
                                                                                            if (schoolConfig.length === 'Medium') count = 10;
                                                                                            if (schoolConfig.length === 'Large') count = 25;
                                                                                        }
                                                                                        const actualIndex = index + 1;
                                                                                        const subset = recentSearches.slice(actualIndex, actualIndex + count);
                                                                                        const flashcardItems = subset.map((si: any) => {
                                                                                            if (typeof si === 'string') return { word: si, definition: 'Tap to see details' };
                                                                                            const d = si.data || {};
                                                                                            return {
                                                                                                ...d,
                                                                                                id: d.id,
                                                                                                word: d.word || si.word,
                                                                                                definition: d.definition || d.simple?.definition || "No definition available",
                                                                                                examples: d.examples || d.simple?.examples || []
                                                                                            };
                                                                                        });

                                                                                        setFlashcardSession({
                                                                                            items: flashcardItems,
                                                                                            currentIndex: 0,
                                                                                            flipped: false,
                                                                                            type: 'word'
                                                                                        });
                                                                                        setAppMode('flashcards');
                                                                                    }}
                                                                                    onLongPress={() => deleteRecentSearch(displayWord)}
                                                                                    style={{
                                                                                        flexDirection: 'row',
                                                                                        alignItems: 'center',
                                                                                        padding: 16,
                                                                                        backgroundColor: theme.uiBg,
                                                                                        borderRadius: 20,
                                                                                        borderWidth: 1,
                                                                                        borderColor: theme.border,
                                                                                        shadowColor: "#000",
                                                                                        shadowOffset: { width: 0, height: 2 },
                                                                                        shadowOpacity: 0.05,
                                                                                        shadowRadius: 4,
                                                                                        elevation: 2
                                                                                    }}
                                                                                >
                                                                                    <View style={{ width: 48, height: 48, borderRadius: 14, backgroundColor: theme.id === 'day' ? '#eff6ff' : theme.buttonBg, alignItems: 'center', justifyContent: 'center', marginRight: 16 }}>
                                                                                        <BookOpen size={24} color={primaryColor} />
                                                                                    </View>

                                                                                    <View style={{ flex: 1 }}>
                                                                                        <View style={{ flexDirection: 'row', alignItems: 'baseline', gap: 6 }}>
                                                                                            <Text style={{ fontSize: 17, fontWeight: '700', color: theme.text }} numberOfLines={1}>
                                                                                                {displayWord}
                                                                                            </Text>
                                                                                            {displayPart && (
                                                                                                <Text style={{ fontSize: 12, fontWeight: '600', color: theme.secondary, fontStyle: 'italic' }}>
                                                                                                    {displayPart}
                                                                                                </Text>
                                                                                            )}
                                                                                        </View>
                                                                                        <Text style={{ fontSize: 13, color: theme.secondary, marginTop: 2 }} numberOfLines={1}>
                                                                                            {displayDef}
                                                                                        </Text>
                                                                                    </View>

                                                                                    <ChevronRight size={20} color={theme.secondary} opacity={0.5} />
                                                                                </TouchableOpacity>
                                                                            );
                                                                        })}

                                                                        {/* Load More Indicator */}
                                                                        {visibleWordCount < Math.min(recentSearches.length, 200) && (
                                                                            <View style={{ padding: 20, alignItems: 'center' }}>
                                                                                <Text style={{ color: theme.secondary, fontSize: 12 }}>
                                                                                    Scroll down and up to load more... ({visibleWordCount}/200)
                                                                                </Text>
                                                                            </View>
                                                                        )}
                                                                    </View>
                                                                </ScrollView>
                                                            )}
                                                        </View>
                                                    );
                                                })()}

                                                {/* NEW: Vertical Recent Activity List (High Priority) */}
                                                {(() => {
                                                    // 1. Aggregate Recent Items (Sessions: AI, Quiz, Story, Notes)
                                                    const recentSessions = Object.values(chatSessions || {})
                                                        .sort((a: any, b: any) => {
                                                            const timeA = new Date(a.lastOpened || a.timestamp).getTime();
                                                            const timeB = new Date(b.lastOpened || b.timestamp).getTime();
                                                            return timeB - timeA;
                                                        })
                                                        .slice(0, 20); // Show Top 20

                                                    if (recentSessions.length === 0) return null;

                                                    return (
                                                        <View style={{ marginBottom: 25, paddingHorizontal: 4 }}>
                                                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10, paddingHorizontal: 4 }}>
                                                                <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 12, textTransform: 'uppercase' }}>
                                                                    Recent Activity
                                                                </Text>
                                                                <TouchableOpacity onPress={() => setActiveTab('library')}>
                                                                    <Text style={{ color: primaryColor, fontSize: 13, fontWeight: '600' }}>See All</Text>
                                                                </TouchableOpacity>
                                                            </View>

                                                            <View style={{ gap: 12 }}>
                                                                {recentSessions.map((item: any) => {
                                                                    // Determine Icon & Color based on Tool ID
                                                                    let Icon = MessageSquare;
                                                                    let color = theme.primary;
                                                                    let label = "Session";
                                                                    let subLabel = new Date(item.timestamp).toLocaleDateString();

                                                                    if (item.toolId === 'ai_tutor') {
                                                                        Icon = GraduationCap;
                                                                        color = "#8b5cf6"; // Purple
                                                                        label = "Personal Assistant";
                                                                    } else if (item.toolId === 'quiz_mode' || item.toolId === 'examiner') {
                                                                        Icon = HelpCircle;
                                                                        color = "#10b981"; // Emerald
                                                                        label = "Quiz";
                                                                    } else if (item.toolId === 'flashcards') {
                                                                        Icon = Layers;
                                                                        color = "#f59e0b"; // Amber
                                                                        label = "Flashcards";
                                                                    } else if (item.toolId === 'story_writer') {
                                                                        Icon = BookOpen;
                                                                        color = "#ec4899"; // Pink
                                                                        label = "Story";
                                                                    } else if (item.toolId === 'quick_notes') {
                                                                        Icon = StickyNote;
                                                                        color = "#eab308"; // Yellow
                                                                        label = "Note";
                                                                    } else if (item.toolId === 'visual_learner') {
                                                                        Icon = Camera;
                                                                        color = "#06b6d4"; // Cyan
                                                                        label = "Vision";
                                                                    } else if (item.toolId === 'writer') {
                                                                        Icon = FileText;
                                                                        color = "#6366f1"; // Indigo
                                                                        label = "Document";
                                                                    } else if (item.toolId === 'audio_player') {
                                                                        Icon = Headphones;
                                                                        color = "#f43f5e"; // Rose
                                                                        label = "Audio";
                                                                    }

                                                                    return (
                                                                        <TouchableOpacity
                                                                            key={item.id}
                                                                            onPress={() => loadHistorySession(item)}
                                                                            onLongPress={() => handleDeleteRecentActivity(item)}
                                                                            style={{
                                                                                flexDirection: 'row',
                                                                                alignItems: 'center',
                                                                                padding: 16,
                                                                                backgroundColor: theme.uiBg,
                                                                                borderRadius: 20,
                                                                                borderWidth: 1,
                                                                                borderColor: theme.border,
                                                                                gap: 16,
                                                                                shadowColor: "#000",
                                                                                shadowOffset: { width: 0, height: 2 },
                                                                                shadowOpacity: 0.05,
                                                                                shadowRadius: 4,
                                                                                elevation: 2
                                                                            }}
                                                                        >
                                                                            <View style={{
                                                                                width: 48, height: 48,
                                                                                borderRadius: 14,
                                                                                backgroundColor: theme.id === 'day' ? `${color}15` : theme.buttonBg, // Light tint if day
                                                                                alignItems: 'center', justifyContent: 'center'
                                                                            }}>
                                                                                <Icon size={24} color={color} />
                                                                            </View>

                                                                            <View style={{ flex: 1 }}>
                                                                                <Text style={{ fontSize: 16, fontWeight: '600', color: theme.text, marginBottom: 4 }} numberOfLines={1}>
                                                                                    {item.title || "Untitled"}
                                                                                </Text>
                                                                                <Text style={{ fontSize: 13, color: theme.secondary }}>
                                                                                    {label} â€¢ {(() => {
                                                                                        const refTime = item.lastOpened || item.timestamp;
                                                                                        const diff = new Date().getTime() - new Date(refTime).getTime();
                                                                                        const seconds = Math.floor(diff / 1000);
                                                                                        if (seconds < 60) return `${Math.max(0, seconds)}s ago`;
                                                                                        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                                                                                        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                                                                                        return `${Math.floor(seconds / 86400)}d ago`;
                                                                                    })()}
                                                                                </Text>
                                                                            </View>

                                                                            <ChevronRight size={20} color={theme.secondary} opacity={0.5} />
                                                                        </TouchableOpacity>
                                                                    );
                                                                })}
                                                            </View>
                                                        </View>
                                                    );
                                                })()}

                                                <View style={{ flex: 1 }} />

                                                <View>
                                                    <View>
                                                        {(() => {
                                                            // 1. Get All Available Tools & Sort by MRU
                                                            const allTools = getAllTools();
                                                            const toolsSource = allTools.filter((t: any) => !t.hidden && t.id !== 'examiner' && t.id !== 'ai_tutor' && t.id !== 'visual_learner');

                                                            toolsSource.sort((a: any, b: any) => {
                                                                const indexA = lastUsedTools.indexOf(a.id);
                                                                const indexB = lastUsedTools.indexOf(b.id);
                                                                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                                                                if (indexA !== -1) return -1;
                                                                if (indexB !== -1) return 1;
                                                                return 0; // Default order
                                                            });

                                                            // 2. Prepare Items List (New Role LAST)
                                                            const allItems = [
                                                                ...toolsSource.map((t: any) => ({ id: t.id, type: 'tool', data: t }))
                                                            ];

                                                            // Check if image exists on disk to avoid re-download/re-generation
                                                            const checkImageExists = async (uri: string) => {
                                                                if (!uri) return false;
                                                            }; // Closing checkImageExists here
                                                            // 3. Shared Tool Press Handler
                                                            const onToolPress = (tool: any) => {
                                                                // Update MRU
                                                                setLastUsedTools((prev: any) => {
                                                                    const newOrder = [tool.id, ...prev.filter((id: string) => id !== tool.id)];
                                                                    return newOrder.slice(0, 50);
                                                                });

                                                                // Original Action
                                                                if (tool.id === 'visual_learner') {
                                                                    setImagePickerMode('vision');
                                                                    setVisionDraft({ uris: [], prompt: "" });
                                                                    setShowImageSourceModal(true);
                                                                } else {
                                                                    setSelectedScenario(tool);
                                                                    const defLength = tool.id === 'examiner' ? "" : "Medium";
                                                                    const targetSubject = tool.id === 'examiner' ? lastQuizSubject : "General";
                                                                    saveSchoolConfig({ input: "", length: defLength, complexity: "Intermediate", subject: targetSubject });
                                                                    setAppMode('setup');
                                                                }
                                                            };

                                                            // --- STATE 1: COLLAPSED VERTICAL LIST ---
                                                            return (
                                                                <View style={{ marginBottom: 10 }}>
                                                                    <ScrollView
                                                                        style={{ maxHeight: 380 }} // Increased height slightly
                                                                        nestedScrollEnabled={true}
                                                                        showsVerticalScrollIndicator={false} // Hide scrollbar for cleaner look
                                                                        contentContainerStyle={{ gap: 12, paddingHorizontal: 4, paddingBottom: 4 }} // Added padding for shadows
                                                                    >
                                                                        {allItems.map((item: any, index: number) => {
                                                                            if (item.type === 'new_role') {
                                                                                return (
                                                                                    <TouchableOpacity
                                                                                        key="new_role"
                                                                                        onPress={handleNewRolePress}
                                                                                        style={{
                                                                                            flexDirection: 'row',
                                                                                            alignItems: 'center',
                                                                                            padding: 16, // Increased padding
                                                                                            backgroundColor: theme.buttonBg,
                                                                                            borderRadius: 20, // More rounded
                                                                                            borderWidth: 1,
                                                                                            borderColor: theme.border,
                                                                                            gap: 16,
                                                                                            // Premium Shadow
                                                                                            shadowColor: "#000",
                                                                                            shadowOffset: { width: 0, height: 2 },
                                                                                            shadowOpacity: 0.05,
                                                                                            shadowRadius: 4,
                                                                                            elevation: 2
                                                                                        }}
                                                                                    >
                                                                                        <View style={{ width: 48, height: 48, borderRadius: 14, backgroundColor: theme.id === 'sepia' ? '#fffefb' : primaryColor, alignItems: 'center', justifyContent: 'center', borderWidth: theme.id === 'sepia' ? 1 : 0, borderColor: '#e3dccf' }}>
                                                                                            <Plus size={24} color={theme.id === 'sepia' ? theme.secondary : "white"} />
                                                                                        </View>
                                                                                        <View style={{ flex: 1 }}>
                                                                                            <Text style={{ fontSize: 17, fontWeight: '700', color: theme.text, marginBottom: 2 }}>New Role</Text>
                                                                                            <Text style={{ fontSize: 13, color: theme.secondary }}>Create a custom AI character</Text>
                                                                                        </View>
                                                                                        <ChevronRight size={20} color={theme.secondary} opacity={0.5} />
                                                                                    </TouchableOpacity>
                                                                                );
                                                                            } else {
                                                                                const tool = item.data;
                                                                                const IconComponent = tool.isCustom ? (ICON_MAP[tool.iconName] || Bot) : tool.Icon;
                                                                                return (
                                                                                    <TouchableOpacity
                                                                                        key={tool.id}
                                                                                        onPress={() => onToolPress(tool)}
                                                                                        onLongPress={() => handleRoleLongPress(tool)}
                                                                                        style={{
                                                                                            flexDirection: 'row',
                                                                                            alignItems: 'center',
                                                                                            padding: 16, // Increased padding
                                                                                            backgroundColor: theme.uiBg,
                                                                                            borderRadius: 20, // More rounded
                                                                                            borderWidth: 1,
                                                                                            borderColor: theme.border,
                                                                                            gap: 16,
                                                                                            // Premium Shadow
                                                                                            shadowColor: "#000",
                                                                                            shadowOffset: { width: 0, height: 2 },
                                                                                            shadowOpacity: 0.05,
                                                                                            shadowRadius: 4,
                                                                                            elevation: 2
                                                                                        }}
                                                                                    >
                                                                                        <LinearGradient colors={theme.toolColor || tool.color} style={{ width: 48, height: 48, borderRadius: 14, alignItems: 'center', justifyContent: 'center' }}>
                                                                                            <IconComponent size={24} color={!theme.toolColor ? "white" : tool.color[1]} />
                                                                                        </LinearGradient>
                                                                                        <View style={{ flex: 1 }}>
                                                                                            <Text style={{ fontSize: 17, fontWeight: '600', color: theme.text, marginBottom: 2 }}>{tool.title}</Text>
                                                                                            <Text style={{ fontSize: 13, color: theme.secondary }} numberOfLines={1}>{tool.role}</Text>
                                                                                        </View>
                                                                                        <ChevronRight size={20} color={theme.secondary} opacity={0.5} />
                                                                                    </TouchableOpacity>
                                                                                );
                                                                            }
                                                                        })}
                                                                    </ScrollView>
                                                                </View>
                                                            );
                                                        })()}
                                                    </View>

                                                    {/* REMOVED: Help & Guide Section from Home (Moved to 'help_guide_char' Tool) */}
                                                </View>
                                            </ScrollView>
                                        </KeyboardAvoidingView>
                                    </View>
                                ) : activeTab === 'library' ? (
                                    <View style={{ flex: 1 }}>
                                        <View style={{ borderBottomWidth: 1, borderBottomColor: theme.border }}>
                                            <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ padding: 15, gap: 12 }}>
                                                {[
                                                    { id: 'chats', label: 'Assistant', icon: NotebookPen },
                                                    { id: 'stories', label: 'Studio', icon: BookOpenText },
                                                    { id: 'audio', label: 'Audio', icon: Headphones },
                                                    { id: 'questions', label: 'Test', icon: MonitorCheck },
                                                ].map((tab: any) => {
                                                    const isActive = libraryTab === tab.id;
                                                    return (
                                                        <TouchableOpacity
                                                            key={tab.id}
                                                            onPress={() => setLibraryTab(tab.id)}
                                                            style={{
                                                                paddingVertical: 12,
                                                                paddingHorizontal: 20,
                                                                borderRadius: 12,
                                                                backgroundColor: isActive ? primaryColor : theme.uiBg,
                                                                borderWidth: 1,
                                                                borderColor: isActive ? primaryColor : theme.border,
                                                                alignItems: 'center',
                                                                justifyContent: 'center',
                                                                gap: 6,
                                                                minWidth: 85,
                                                                shadowColor: "#000",
                                                                shadowOffset: { width: 0, height: 2 },
                                                                shadowOpacity: isActive ? 0.2 : 0.05,
                                                                shadowRadius: 3,
                                                                elevation: isActive ? 3 : 1
                                                            }}
                                                        >
                                                            <tab.icon size={20} color={isActive ? 'white' : theme.text} />
                                                            <Text style={{ color: isActive ? 'white' : theme.text, fontWeight: 'bold', fontSize: 13 }}>{tab.label}</Text>
                                                        </TouchableOpacity>
                                                    );
                                                })}
                                            </ScrollView>
                                        </View>

                                        {/* NEW: Library Search Bar OR Selection Header */}
                                        <View style={{ paddingHorizontal: 20, paddingTop: 15, paddingBottom: 5 }}>
                                            {isLibrarySelectionMode ? (
                                                <View style={{
                                                    backgroundColor: primaryColor,
                                                    borderRadius: 16,
                                                    marginBottom: 10,
                                                    padding: 10,
                                                    flexDirection: 'row',
                                                    alignItems: 'center',
                                                    justifyContent: 'space-between',
                                                    shadowColor: primaryColor,
                                                    shadowOffset: { width: 0, height: 4 },
                                                    shadowOpacity: 0.3,
                                                    shadowRadius: 5,
                                                    elevation: 5
                                                }}>
                                                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12, paddingLeft: 10, flex: 1 }}>
                                                        <TouchableOpacity onPress={() => { setIsLibrarySelectionMode(false); setSelectedLibraryIds([]); }}>
                                                            <X size={20} color="white" />
                                                        </TouchableOpacity>
                                                        <View style={{ flex: 1 }}>
                                                            <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 16 }} numberOfLines={1}>
                                                                {selectedLibraryIds.length} Selected
                                                            </Text>
                                                            <TouchableOpacity onPress={handleToggleSelectAllLibrary}>
                                                                <Text style={{ color: 'rgba(255,255,255,0.8)', fontSize: 11, fontWeight: 'bold', textDecorationLine: 'underline', marginTop: 2 }}>
                                                                    {(selectedLibraryIds.length === filteredLibraryItems.length && filteredLibraryItems.length > 0) ? "Deselect All" : "Select All"}
                                                                </Text>
                                                            </TouchableOpacity>
                                                        </View>
                                                    </View>

                                                    <View style={{ flexDirection: 'row', gap: 8 }}>
                                                        {/* Standard Actions (Active Mode) */}
                                                        <TouchableOpacity
                                                            onPress={handleLibraryBatchPin}
                                                            style={{ padding: 8, backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 10 }}
                                                        >
                                                            <Pin size={20} color="white" fill={selectedLibraryIds.every(id => chatSessions[id]?.pinned) ? "white" : "transparent"} />
                                                        </TouchableOpacity>

                                                        <TouchableOpacity
                                                            onPress={handleLibraryBatchShare}
                                                            style={{ padding: 8, backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 10 }}
                                                        >
                                                            <Share2 size={20} color="white" />
                                                        </TouchableOpacity>

                                                        <TouchableOpacity
                                                            onPress={handleLibraryBatchExport}
                                                            style={{ padding: 8, backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 10 }}
                                                        >
                                                            <Upload size={20} color="white" />
                                                        </TouchableOpacity>

                                                        <TouchableOpacity
                                                            onPress={handleLibraryBatchDelete}
                                                            style={{ padding: 8, backgroundColor: 'rgba(255,59,48,0.8)', borderRadius: 10 }}
                                                        >
                                                            <Trash2 size={20} color="white" />
                                                        </TouchableOpacity>
                                                    </View>
                                                </View>
                                            ) : (
                                                <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 10 }]}>
                                                    <TextInput
                                                        style={[styles.searchInput, { color: theme.text }]}
                                                        placeholder="Search library..."
                                                        placeholderTextColor={theme.secondary}
                                                        value={librarySearchQuery}
                                                        onChangeText={setLibrarySearchQuery}
                                                    />



                                                    <TouchableOpacity
                                                        onPress={() => handleVoiceToggle('library_search')}
                                                        style={{
                                                            width: 38,
                                                            height: 38,
                                                            borderRadius: 19,
                                                            backgroundColor: (isRecording && voiceTarget === 'library_search') ? '#ef4444' : theme.buttonBg,
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            marginRight: 8,
                                                            borderWidth: 1,
                                                            borderColor: (isRecording || isTranscribing) && voiceTarget === 'library_search' ? '#ef4444' : theme.border
                                                        }}
                                                    >
                                                        {isTranscribing && voiceTarget === 'library_search' ? (
                                                            <ActivityIndicator size="small" color={theme.text} />
                                                        ) : (
                                                            <Animated.View style={{ opacity: voiceTarget === 'library_search' ? recordingOpacity : 1 }}>
                                                                <Mic size={18} color={(isRecording && voiceTarget === 'library_search') ? 'white' : theme.text} />
                                                            </Animated.View>
                                                        )}
                                                    </TouchableOpacity>

                                                    {librarySearchQuery.length > 0 ? (
                                                        <TouchableOpacity onPress={() => setLibrarySearchQuery("")} style={{ padding: 10 }}>
                                                            <X size={20} color={theme.secondary} />
                                                        </TouchableOpacity>
                                                    ) : (
                                                        <View style={{ padding: 10 }}>
                                                            <Search size={20} color={theme.secondary} />
                                                        </View>
                                                    )}
                                                </View>
                                            )}
                                        </View>

                                        <View style={{ flex: 1 }}>
                                            {/* UPDATED: Optimized Library Layout for Landscape using Key/Columns */}
                                            {libraryTab === 'chats' ? (
                                                <FlatList
                                                    key={isLandscape ? 'lib_land_chats' : 'lib_port_chats'} // Force remount on orientation change
                                                    numColumns={isLandscape ? 2 : 1}
                                                    columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                    contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                                    data={filteredLibraryItems}
                                                    ListFooterComponent={
                                                        <View style={{ paddingVertical: 20, alignItems: 'center', gap: 10 }}>
                                                            <Text style={{ color: theme.secondary, fontSize: 12 }}>
                                                                {filteredLibraryItems.length} items
                                                            </Text>
                                                            <View style={{ height: 20 }} />
                                                        </View>
                                                    }
                                                    keyExtractor={(item) => item.id}
                                                    ListEmptyComponent={
                                                        <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                            {librarySearchQuery ? (
                                                                <>
                                                                    <Search size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>No matches found.</Text>
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <NotebookPen size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>No journals yet.</Text>
                                                                    <TouchableOpacity onPress={() => setActiveTab('home')} style={{ marginTop: 20 }}>
                                                                        <Text style={{ color: '#2563eb' }}>Create your first one!</Text>
                                                                    </TouchableOpacity>
                                                                </>
                                                            )}
                                                        </View>
                                                    }
                                                    renderItem={renderLibraryItem}
                                                />
                                            ) : libraryTab === 'stories' ? (
                                                <FlatList
                                                    key={isLandscape ? 'lib_land_stories' : 'lib_port_stories'} // Force remount on orientation change
                                                    numColumns={isLandscape ? 2 : 1}
                                                    columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                    contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                                    // Use memoized filtered data
                                                    data={filteredLibraryItems}
                                                    ListFooterComponent={
                                                        <View style={{ paddingVertical: 20, alignItems: 'center', gap: 10 }}>
                                                            <View style={{ height: 20 }} />
                                                        </View>
                                                    }
                                                    keyExtractor={(item) => item.id}
                                                    ListEmptyComponent={
                                                        <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                            {librarySearchQuery ? (
                                                                <>
                                                                    <Search size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>No matches found.</Text>
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <BookOpenText size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>No stories saved yet.</Text>
                                                                    <TouchableOpacity onPress={() => setActiveTab('story')} style={{ marginTop: 20 }}>
                                                                        <Text style={{ color: '#2563eb' }}>Write a Story</Text>
                                                                    </TouchableOpacity>
                                                                </>
                                                            )}
                                                        </View>
                                                    }
                                                    renderItem={renderStoryItem}
                                                />
                                            ) : libraryTab === 'audio' ? (
                                                <View style={{ flex: 1 }}>
                                                    {/* Audio Header Stats */}
                                                    <View style={{ paddingHorizontal: 20, paddingTop: 10, paddingBottom: 5, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                                                        <Text style={{ color: theme.secondary, fontSize: 12, fontWeight: 'bold', textTransform: 'uppercase' }}>
                                                            {audioFiles.length} FILES FOUND
                                                        </Text>
                                                        <TouchableOpacity
                                                            onPress={loadAudioFiles}
                                                            style={{ flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                        >
                                                            <RefreshCcw size={12} color={primaryColor} />
                                                            <Text style={{ color: primaryColor, fontSize: 12, fontWeight: 'bold' }}>Refresh</Text>
                                                        </TouchableOpacity>
                                                    </View>

                                                    <FlatList
                                                        key={isLandscape ? 'lib_land_audio' : 'lib_port_audio'} // Force remount on orientation change
                                                        numColumns={isLandscape ? 2 : 1}
                                                        columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                        contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                                        // Use memoized data (which is just audioFiles, but consistent)
                                                        data={filteredLibraryItems}
                                                        ListFooterComponent={<View style={{ height: 20 }} />}
                                                        keyExtractor={(item) => item.id}
                                                        ListEmptyComponent={
                                                            <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                                {isAudioLoading ? (
                                                                    <ActivityIndicator size="large" color={primaryColor} />
                                                                ) : (
                                                                    <>
                                                                        <Headphones size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                        <Text style={{ color: theme.secondary, marginTop: 10 }}>No offline audio found.</Text>
                                                                        <TouchableOpacity onPress={() => setActiveTab('story')} style={{ marginTop: 20 }}>
                                                                            <Text style={{ color: '#2563eb' }}>Create a Story & Download Audio</Text>
                                                                        </TouchableOpacity>
                                                                    </>
                                                                )}
                                                            </View>
                                                        }
                                                        renderItem={({ item }: { item: any }) => {
                                                            const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 10 };

                                                            return (
                                                                <View style={containerStyle}>
                                                                    {/* BOOK GROUP RENDER */}
                                                                    {item.isBook ? (
                                                                        /* CALCULATE GROUP SELECTION STATE */
                                                                        (() => {
                                                                            const chapterIds = item.chapters ? item.chapters.map((c: any) => c.id) : [];
                                                                            const isGroupSelected = chapterIds.length > 0 && chapterIds.every((id: string) => selectedLibraryIds.includes(id));

                                                                            const uniqueChaptersCount = new Set(item.chapters ? item.chapters.map((c: any) => c.matchedTitle || c.title) : []).size;

                                                                            return (
                                                                                <View style={{
                                                                                    borderRadius: 16,
                                                                                    backgroundColor: isGroupSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.uiBg,
                                                                                    borderWidth: isGroupSelected ? 2 : 1,
                                                                                    borderColor: isGroupSelected ? primaryColor : theme.border,
                                                                                    overflow: 'hidden'
                                                                                }}>
                                                                                    <TouchableOpacity
                                                                                        onPress={() => {
                                                                                            if (isLibrarySelectionMode) {
                                                                                                handleGroupSelection(chapterIds);
                                                                                            } else {
                                                                                                setExpandedAudioGroups((prev: Record<string, boolean>) => ({ ...prev, [item.id]: !prev[item.id] }));
                                                                                            }
                                                                                        }}
                                                                                        onLongPress={() => {
                                                                                            if (!isLibrarySelectionMode) {
                                                                                                setIsLibrarySelectionMode(true);
                                                                                                setSelectedLibraryIds(chapterIds);
                                                                                            } else {
                                                                                                handleGroupSelection(chapterIds);
                                                                                            }
                                                                                        }}
                                                                                        activeOpacity={0.8}
                                                                                        style={{ flexDirection: 'row', alignItems: 'center', padding: 12 }}
                                                                                    >
                                                                                        {isLibrarySelectionMode && (
                                                                                            <View style={{
                                                                                                width: 18, height: 18, borderRadius: 9,
                                                                                                borderWidth: 2, borderColor: isGroupSelected ? primaryColor : theme.secondary,
                                                                                                backgroundColor: isGroupSelected ? primaryColor : 'transparent',
                                                                                                alignItems: 'center', justifyContent: 'center',
                                                                                                marginRight: 12
                                                                                            }}>
                                                                                                {isGroupSelected && <Check size={10} color="white" />}
                                                                                            </View>
                                                                                        )}

                                                                                        <View style={{ width: 48, height: 48, borderRadius: 8, marginRight: 12, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                                                                                            <BookAudio size={24} color={primaryColor} />
                                                                                        </View>

                                                                                        <View style={{ flex: 1 }}>
                                                                                            <Text style={[styles.historyTitle, { color: theme.text, fontSize: 16 }]} numberOfLines={1}>{item.title}</Text>
                                                                                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5 }}>
                                                                                                <Text style={{ color: theme.secondary, fontSize: 12, fontWeight: 'bold' }}>{uniqueChaptersCount} {uniqueChaptersCount === 1 ? 'Chapter' : 'Chapters'}</Text>
                                                                                                <Text style={{ color: theme.secondary, fontSize: 12 }}>â€¢ {(item.totalSize / 1024 / 1024).toFixed(1)} MB</Text>
                                                                                            </View>
                                                                                        </View>

                                                                                        <View style={{ padding: 8 }}>
                                                                                            <ChevronDown size={20} color={theme.secondary} style={{ transform: [{ rotate: expandedAudioGroups[item.id] ? '180deg' : '0deg' }] }} />
                                                                                        </View>
                                                                                    </TouchableOpacity>

                                                                                    {expandedAudioGroups[item.id] && (
                                                                                        <View style={{ borderTopWidth: 1, borderTopColor: theme.border, backgroundColor: theme.bg }}>
                                                                                            {(() => {
                                                                                                // Group sibling chapters by title to avoid duplicates
                                                                                                const groupedChapters: any[] = [];
                                                                                                const titleMap = new Map();

                                                                                                item.chapters.forEach((chapter: any) => {
                                                                                                    const title = chapter.matchedTitle;
                                                                                                    if (!titleMap.has(title)) {
                                                                                                        const newGroup = { ...chapter, parts: [chapter] };
                                                                                                        titleMap.set(title, newGroup);
                                                                                                        groupedChapters.push(newGroup);
                                                                                                    } else {
                                                                                                        const group = titleMap.get(title);
                                                                                                        group.parts.push(chapter);
                                                                                                        group.totalSize = (group.totalSize || group.size || 0) + (chapter.totalSize || chapter.size || 0);
                                                                                                    }
                                                                                                });

                                                                                                return groupedChapters.map((chapter: any, cIdx: number) => {
                                                                                                    // Configure proper group structure for playback if multiple parts exist
                                                                                                    if (chapter.parts && chapter.parts.length > 1) {
                                                                                                        chapter.isGroup = true;
                                                                                                        chapter.files = chapter.parts;
                                                                                                    }

                                                                                                    return (
                                                                                                        <TouchableOpacity
                                                                                                            key={chapter.id}
                                                                                                            onPress={() => {
                                                                                                                if (isLibrarySelectionMode) {
                                                                                                                    const id = chapter.id;
                                                                                                                    const newIds = selectedLibraryIds.includes(id)
                                                                                                                        ? selectedLibraryIds.filter(i => i !== id)
                                                                                                                        : [...selectedLibraryIds, id];
                                                                                                                    setSelectedLibraryIds(newIds);
                                                                                                                    if (newIds.length === 0) setIsLibrarySelectionMode(false);
                                                                                                                } else {
                                                                                                                    const updatedChapter = { ...chapter, timestamp: new Date().toISOString() };
                                                                                                                    if (chatSessions[chapter.id]) {
                                                                                                                        setChatSessions((prev: any) => ({ ...prev, [chapter.id]: updatedChapter }));
                                                                                                                    }
                                                                                                                    playLibraryItem(updatedChapter, true);
                                                                                                                }
                                                                                                            }}
                                                                                                            onLongPress={() => {
                                                                                                                if (!isLibrarySelectionMode) {
                                                                                                                    setIsLibrarySelectionMode(true);
                                                                                                                    setSelectedLibraryIds([chapter.id]);
                                                                                                                } else {
                                                                                                                    const id = chapter.id;
                                                                                                                    const newIds = selectedLibraryIds.includes(id)
                                                                                                                        ? selectedLibraryIds.filter(i => i !== id)
                                                                                                                        : [...selectedLibraryIds, id];
                                                                                                                    setSelectedLibraryIds(newIds);
                                                                                                                    if (newIds.length === 0) setIsLibrarySelectionMode(false);
                                                                                                                }
                                                                                                            }}
                                                                                                            style={{
                                                                                                                paddingVertical: 12,
                                                                                                                paddingHorizontal: 16,
                                                                                                                borderBottomWidth: cIdx === groupedChapters.length - 1 ? 0 : 1,
                                                                                                                borderBottomColor: theme.border,
                                                                                                                flexDirection: 'row',
                                                                                                                alignItems: 'center',
                                                                                                                backgroundColor: selectedLibraryIds.includes(chapter.id) ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : 'transparent'
                                                                                                            }}
                                                                                                        >
                                                                                                            {isLibrarySelectionMode && (
                                                                                                                <View style={{
                                                                                                                    width: 16, height: 16, borderRadius: 8,
                                                                                                                    borderWidth: 1.5, borderColor: selectedLibraryIds.includes(chapter.id) ? primaryColor : theme.secondary,
                                                                                                                    backgroundColor: selectedLibraryIds.includes(chapter.id) ? primaryColor : 'transparent',
                                                                                                                    alignItems: 'center', justifyContent: 'center',
                                                                                                                    marginRight: 10
                                                                                                                }}>
                                                                                                                    {selectedLibraryIds.includes(chapter.id) && <Check size={8} color="white" />}
                                                                                                                </View>
                                                                                                            )}

                                                                                                            <View style={{ width: 32, height: 32, borderRadius: 8, marginRight: 10, backgroundColor: theme.buttonBg, alignItems: 'center', justifyContent: 'center' }}>
                                                                                                                <Headphones size={16} color={theme.secondary} />
                                                                                                            </View>

                                                                                                            <View style={{ flex: 1 }}>
                                                                                                                <Text style={{ color: theme.text, fontSize: 14, fontWeight: '500' }} numberOfLines={1}>
                                                                                                                    {chapter.matchedTitle.replace(`${item.title}:`, '').trim()}
                                                                                                                </Text>
                                                                                                                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                                                                                                                    <Text style={{ color: theme.secondary, fontSize: 10 }}>
                                                                                                                        {((chapter.totalSize || chapter.size) / 1024 / 1024).toFixed(1)} MB
                                                                                                                    </Text>
                                                                                                                    {chapter.parts && chapter.parts.length > 1 && (
                                                                                                                        <Text style={{ color: theme.secondary, fontSize: 10, marginLeft: 4 }}>
                                                                                                                            â€¢ {chapter.parts.length} Parts
                                                                                                                        </Text>
                                                                                                                    )}
                                                                                                                </View>
                                                                                                            </View>

                                                                                                            <View style={{ flexDirection: 'row' }}>
                                                                                                                <TouchableOpacity onPress={() => handleExportAudioFile(chapter, item)} disabled={isExportingAudioId !== null} style={{ padding: 6 }}>
                                                                                                                    {isExportingAudioId === chapter.id ? <ActivityIndicator size="small" color={theme.text} /> : <DownloadCloud size={18} color={theme.secondary} />}
                                                                                                                </TouchableOpacity>
                                                                                                                <TouchableOpacity onPress={() => playLibraryItem(chapter, true)} style={{ padding: 6 }}>
                                                                                                                    <PlayCircle size={18} color={primaryColor} />
                                                                                                                </TouchableOpacity>
                                                                                                            </View>
                                                                                                        </TouchableOpacity>
                                                                                                    );
                                                                                                });
                                                                                            })()}
                                                                                        </View>
                                                                                    )}
                                                                                </View>
                                                                            );
                                                                        })()
                                                                    ) : (
                                                                        /* STANDALONE FILE RENDER */
                                                                        <TouchableOpacity
                                                                            onPress={async () => {
                                                                                if (isLibrarySelectionMode) {
                                                                                    // Toggle selection if in selection mode
                                                                                    const id = item.id;
                                                                                    const newIds = selectedLibraryIds.includes(id)
                                                                                        ? selectedLibraryIds.filter(i => i !== id)
                                                                                        : [...selectedLibraryIds, id];
                                                                                    setSelectedLibraryIds(newIds);
                                                                                    if (newIds.length === 0) setIsLibrarySelectionMode(false);
                                                                                    return;
                                                                                }
                                                                                const updatedItem = { ...item, timestamp: new Date().toISOString() };
                                                                                if (chatSessions[item.id]) {
                                                                                    setChatSessions((prev: any) => ({ ...prev, [item.id]: updatedItem }));
                                                                                }
                                                                                playLibraryItem(updatedItem, true);
                                                                            }}
                                                                            onLongPress={() => {
                                                                                if (!isLibrarySelectionMode) {
                                                                                    setIsLibrarySelectionMode(true);
                                                                                    setSelectedLibraryIds([item.id]);
                                                                                } else {
                                                                                    const id = item.id;
                                                                                    const newIds = selectedLibraryIds.includes(id)
                                                                                        ? selectedLibraryIds.filter(i => i !== id)
                                                                                        : [...selectedLibraryIds, id];
                                                                                    setSelectedLibraryIds(newIds);
                                                                                    if (newIds.length === 0) setIsLibrarySelectionMode(false);
                                                                                }
                                                                            }}
                                                                            delayLongPress={300}
                                                                            activeOpacity={0.8}
                                                                            style={[
                                                                                styles.historyItem,
                                                                                {
                                                                                    backgroundColor: selectedLibraryIds.includes(item.id) ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.uiBg,
                                                                                    borderColor: selectedLibraryIds.includes(item.id) ? primaryColor : theme.border,
                                                                                    flexDirection: 'row',
                                                                                    alignItems: 'center',
                                                                                    paddingRight: 10,
                                                                                    borderWidth: selectedLibraryIds.includes(item.id) ? 2 : 1
                                                                                }
                                                                            ]}
                                                                        >
                                                                            <View style={{ flex: 1 }}>
                                                                                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}>
                                                                                    {isLibrarySelectionMode && (
                                                                                        <View style={{
                                                                                            width: 18, height: 18, borderRadius: 9,
                                                                                            borderWidth: 2, borderColor: selectedLibraryIds.includes(item.id) ? primaryColor : theme.secondary,
                                                                                            backgroundColor: selectedLibraryIds.includes(item.id) ? primaryColor : 'transparent',
                                                                                            alignItems: 'center', justifyContent: 'center',
                                                                                            marginRight: 6
                                                                                        }}>
                                                                                            {selectedLibraryIds.includes(item.id) && <Check size={10} color="white" />}
                                                                                        </View>
                                                                                    )}

                                                                                    {/* Show Pin if linked session is pinned */}
                                                                                    {item.sessionId && chatSessions[item.sessionId]?.pinned && (
                                                                                        <Pin size={14} color={primaryColor} fill={primaryColor} style={{ transform: [{ rotate: '45deg' }] }} />
                                                                                    )}

                                                                                    <View style={{ width: 40, height: 40, borderRadius: 8, marginRight: 8, backgroundColor: item.matchedTitle ? theme.highlight : '#f3f4f6', alignItems: 'center', justifyContent: 'center' }}>
                                                                                        {item.matchedTitle ? (
                                                                                            <BookOpenText size={20} color={primaryColor} />
                                                                                        ) : (
                                                                                            <Headphones size={20} color="#9ca3af" />
                                                                                        )}
                                                                                    </View>

                                                                                    <View style={{ flex: 1 }}>
                                                                                        <Text style={[styles.historyTitle, { color: theme.text }]} numberOfLines={1}>
                                                                                            {item.matchedTitle || "Unknown Recording"}
                                                                                        </Text>
                                                                                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5, flexWrap: 'wrap' }}>
                                                                                            {item.isGroup ? (
                                                                                                <View style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 6, borderRadius: 4 }}>
                                                                                                    <Text style={{ color: theme.text, fontSize: 10, fontWeight: 'bold' }}>{item.files.length} PARTS</Text>
                                                                                                </View>
                                                                                            ) : (
                                                                                                item.partInfo && (
                                                                                                    <View style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 4, borderRadius: 4 }}>
                                                                                                        <Text style={{ color: theme.text, fontSize: 10, fontWeight: 'bold' }}>{item.partInfo}</Text>
                                                                                                    </View>
                                                                                                )
                                                                                            )}
                                                                                            <Text style={{ color: theme.secondary, fontSize: 11 }}>
                                                                                                {new Date(item.modificationTime * 1000).toLocaleDateString()} â€¢ {(item.totalSize ? item.totalSize : item.size) / 1024 / 1024 < 0.1 ? "<0.1" : ((item.totalSize || item.size) / 1024 / 1024).toFixed(1)} MB
                                                                                            </Text>
                                                                                        </View>
                                                                                    </View>
                                                                                </View>
                                                                            </View>

                                                                            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                                                                                {/* Export Button (Cloud Download Icon) - Always Visible */}
                                                                                <TouchableOpacity
                                                                                    onPress={() => handleExportAudioFile(item)}
                                                                                    disabled={isExportingAudioId !== null} // Disable if ANY export is happening
                                                                                    style={{ padding: 10 }}
                                                                                    hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                                                                                >
                                                                                    {isExportingAudioId === item.id ? (
                                                                                        <ActivityIndicator size="small" color={theme.text} />
                                                                                    ) : (
                                                                                        <DownloadCloud
                                                                                            size={22}
                                                                                            color={isExportingAudioId ? theme.secondary : theme.text}
                                                                                            style={{ opacity: isExportingAudioId ? 0.5 : 1 }}
                                                                                        />
                                                                                    )}
                                                                                </TouchableOpacity>

                                                                                <View style={{ padding: 10 }}>
                                                                                    <PlayCircle size={24} color={primaryColor} />
                                                                                </View>
                                                                            </View>
                                                                        </TouchableOpacity>
                                                                    )}
                                                                </View>
                                                            );
                                                        }}
                                                    />
                                                </View>
                                            ) : (
                                                <View style={{ flex: 1 }}>
                                                    <View style={{ flexDirection: 'row', margin: 15, marginTop: 0, backgroundColor: theme.buttonBg, borderRadius: 12, padding: 4 }}>
                                                        <TouchableOpacity
                                                            onPress={() => setQuestionsViewMode('quizzes')}
                                                            style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: questionsViewMode === 'quizzes' ? theme.bg : 'transparent', shadowOpacity: questionsViewMode === 'quizzes' ? 0.1 : 0 }}
                                                        >
                                                            <Text style={{ fontWeight: 'bold', color: questionsViewMode === 'quizzes' ? theme.text : theme.secondary, fontSize: 11 }}>Quizzes</Text>
                                                        </TouchableOpacity>

                                                        <TouchableOpacity
                                                            onPress={() => setQuestionsViewMode('cards')}
                                                            style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: questionsViewMode === 'cards' ? theme.bg : 'transparent', shadowOpacity: questionsViewMode === 'cards' ? 0.1 : 0 }}
                                                        >
                                                            <Text style={{ fontWeight: 'bold', color: questionsViewMode === 'cards' ? theme.text : theme.secondary, fontSize: 11 }}>Cards</Text>
                                                        </TouchableOpacity>
                                                        <TouchableOpacity
                                                            onPress={() => setQuestionsViewMode('saved')}
                                                            style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: questionsViewMode === 'saved' ? theme.bg : 'transparent', shadowOpacity: questionsViewMode === 'saved' ? 0.1 : 0 }}
                                                        >
                                                            <Text style={{ fontWeight: 'bold', color: questionsViewMode === 'saved' ? theme.text : theme.secondary, fontSize: 11 }}>Questions</Text>
                                                        </TouchableOpacity>
                                                        <TouchableOpacity
                                                            onPress={() => setQuestionsViewMode('vocabulary')}
                                                            style={{ flex: 1, paddingVertical: 8, alignItems: 'center', borderRadius: 10, backgroundColor: questionsViewMode === 'vocabulary' ? theme.bg : 'transparent', shadowOpacity: questionsViewMode === 'vocabulary' ? 0.1 : 0 }}
                                                        >
                                                            <Text style={{ fontWeight: 'bold', color: questionsViewMode === 'vocabulary' ? theme.text : theme.secondary, fontSize: 11 }}>Vocabulary</Text>
                                                        </TouchableOpacity>
                                                    </View>

                                                    {questionsViewMode === 'quizzes' ? (
                                                        <FlatList
                                                            key={isLandscape ? 'lib_land_quizzes' : 'lib_port_quizzes'} // Force remount on orientation change
                                                            numColumns={isLandscape ? 2 : 1}
                                                            columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                            contentContainerStyle={{ padding: 20, paddingTop: 0, paddingBottom: 100 }}
                                                            // Use memoized filtered data
                                                            data={filteredLibraryItems}
                                                            ListFooterComponent={<View style={{ height: 20 }} />}
                                                            keyExtractor={(item) => item.id}
                                                            extraData={{ librarySearchQuery }}
                                                            ListEmptyComponent={
                                                                <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                                    <MonitorCheck size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>No quizzes.</Text>
                                                                    {!librarySearchQuery && (
                                                                        <TouchableOpacity onPress={() => { setSelectedScenario(SCHOOL_TOOLS.find(t => t.id === 'examiner')); setAppMode('setup'); }} style={{ marginTop: 20 }}>
                                                                            <Text style={{ color: '#2563eb' }}>Start a New Quiz</Text>
                                                                        </TouchableOpacity>
                                                                    )}
                                                                </View>
                                                            }
                                                            renderItem={({ item: session }: { item: any }) => {
                                                                const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 10 };
                                                                const isSelected = selectedLibraryIds.includes(session.id);
                                                                return (
                                                                    <TouchableOpacity
                                                                        onPress={() => handleLibraryPress(session)}
                                                                        onLongPress={() => handleLibraryLongPress(session.id)}
                                                                        delayLongPress={300}
                                                                        activeOpacity={0.8}
                                                                        style={[
                                                                            styles.historyItem,
                                                                            {
                                                                                backgroundColor: isSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.uiBg,
                                                                                borderColor: isSelected ? primaryColor : theme.border,
                                                                                flexDirection: 'row',
                                                                                alignItems: 'center',
                                                                                paddingRight: 10,
                                                                                borderWidth: isSelected ? 2 : 1
                                                                            },
                                                                            containerStyle
                                                                        ]}
                                                                    >
                                                                        <View style={{ flex: 1 }}>
                                                                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}>
                                                                                {isLibrarySelectionMode && (
                                                                                    <View style={{
                                                                                        width: 18, height: 18, borderRadius: 9,
                                                                                        borderWidth: 2, borderColor: isSelected ? primaryColor : theme.secondary,
                                                                                        backgroundColor: isSelected ? primaryColor : 'transparent',
                                                                                        alignItems: 'center', justifyContent: 'center'
                                                                                    }}>
                                                                                        {isSelected && <Check size={10} color="white" />}
                                                                                    </View>
                                                                                )}
                                                                                {session.pinned && (
                                                                                    <Pin size={14} color={primaryColor} fill={primaryColor} style={{ transform: [{ rotate: '45deg' }] }} />
                                                                                )}
                                                                                <Text style={[styles.historyTitle, { color: theme.text, flex: 1 }]} numberOfLines={1}>{session.title || "Untitled Quiz"}</Text>
                                                                            </View>

                                                                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5, marginLeft: (isLibrarySelectionMode ? 24 : 0) + (session.pinned && !isLibrarySelectionMode ? 0 : 0) }}>
                                                                                <Text style={{ color: theme.secondary, fontSize: 12 }}>{new Date(session.timestamp).toLocaleDateString()}</Text>
                                                                                {/* FIX: Ensure session.totalTime is strictly checked against null/undefined to avoid rendering '0' crash */}
                                                                                {session.totalTime !== undefined && session.totalTime !== null && (
                                                                                    <Text style={{ color: theme.secondary, fontSize: 12 }}> â€¢ {formatTimer(session.totalTime)}</Text>
                                                                                )}
                                                                            </View>
                                                                        </View>

                                                                        {session.score !== undefined && (
                                                                            <View style={{
                                                                                width: 42, height: 42, borderRadius: 21,
                                                                                backgroundColor: theme.bg,
                                                                                alignItems: 'center', justifyContent: 'center',
                                                                                borderWidth: 3,
                                                                                borderColor: session.score / session.totalQuestions >= 0.8 ? '#22c55e' : (session.score / session.totalQuestions >= 0.5 ? '#eab308' : '#ef4444'),
                                                                            }}>
                                                                                <Text style={{ fontSize: 13, fontWeight: 'bold', color: theme.text }}>
                                                                                    {session.score}
                                                                                </Text>
                                                                            </View>
                                                                        )}
                                                                    </TouchableOpacity>
                                                                );
                                                            }}
                                                        />
                                                    ) : questionsViewMode === 'saved' ? (
                                                        <View style={{ flex: 1 }}>
                                                            {/* Questions Tab: Saved Quiz Questions (Old Way) */}

                                                            <View style={{ padding: 20, paddingTop: 0, paddingBottom: 0, alignItems: 'center' }}>
                                                                <Text style={{ color: theme.secondary, marginBottom: 10 }}>{savedQuestions.filter(q => q.options && q.options.length > 0).length} questions saved</Text>
                                                                {savedQuestions.filter(q => q.options && q.options.length > 0).length > 0 ? (
                                                                    <View style={{ alignItems: 'center', width: '100%' }}>
                                                                        <View style={{ flexDirection: 'row', gap: 10, marginBottom: 15, width: '100%', paddingHorizontal: 20 }}>
                                                                            <TouchableOpacity
                                                                                onPress={handleSavedQuestionsQuiz}
                                                                                style={{ flex: 1, backgroundColor: primaryColor, paddingVertical: 12, borderRadius: 12, alignItems: 'center', justifyContent: 'center', shadowColor: primaryColor, shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.2, shadowRadius: 3, elevation: 2 }}
                                                                            >
                                                                                <Text style={{ color: 'white', fontWeight: 'bold' }}>Practice Quiz</Text>
                                                                            </TouchableOpacity>
                                                                            <TouchableOpacity
                                                                                onPress={handleSavedQuizAsFlashcards}
                                                                                style={{ flex: 1, backgroundColor: theme.uiBg, borderWidth: 1, borderColor: primaryColor, paddingVertical: 12, borderRadius: 12, alignItems: 'center', justifyContent: 'center' }}
                                                                            >
                                                                                <Text style={{ color: primaryColor, fontWeight: 'bold' }}>Flashcards</Text>
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    </View>
                                                                ) : !librarySearchQuery && (
                                                                    <Text style={{ fontStyle: 'italic', color: theme.secondary, textAlign: 'center' }}>Tap the star icon during a quiz to save tricky questions here.</Text>
                                                                )}
                                                            </View>
                                                            <FlatList
                                                                key={isLandscape ? 'lib_land_saved_qs' : 'lib_port_saved_qs'} // Force remount on orientation change
                                                                numColumns={isLandscape ? 2 : 1}
                                                                columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                                contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                                                // Filter for Quiz Questions (with options)
                                                                data={savedQuestions.filter((q: any) => q.options && q.options.length > 0).filter((q: any) => !librarySearchQuery || q.question.toLowerCase().includes(librarySearchQuery.toLowerCase())).sort((a: any, b: any) => new Date(b.savedAt || 0).getTime() - new Date(a.savedAt || 0).getTime())}
                                                                ListFooterComponent={<View style={{ height: 20 }} />}
                                                                keyExtractor={(item: any, index: number) => item.id || index.toString()}
                                                                extraData={{ savedQuestions, librarySearchQuery }}
                                                                ListEmptyComponent={
                                                                    <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                                        {librarySearchQuery ? (
                                                                            <>
                                                                                <Search size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                                <Text style={{ color: theme.secondary, marginTop: 10 }}>No matches found.</Text>
                                                                            </>
                                                                        ) : (
                                                                            <>
                                                                                <HelpCircle size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                                <Text style={{ color: theme.secondary, marginTop: 10 }}>No saved questions.</Text>
                                                                            </>
                                                                        )}
                                                                    </View>
                                                                }
                                                                renderItem={({ item, index }: { item: any, index: number }) => {
                                                                    const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 15 };
                                                                    return (
                                                                        <TouchableOpacity
                                                                            onLongPress={() => {
                                                                                Alert.alert("Delete Question", "Remove this question?", [
                                                                                    { text: "Cancel", style: "cancel" },
                                                                                    { text: "Delete", style: 'destructive', onPress: () => toggleSaveQuestion(item) }
                                                                                ]);
                                                                            }}
                                                                            delayLongPress={500}
                                                                            activeOpacity={0.8}
                                                                            style={[{
                                                                                backgroundColor: theme.uiBg,
                                                                                borderRadius: 12,
                                                                                borderWidth: 1,
                                                                                borderColor: theme.border,
                                                                                padding: 15
                                                                            }, containerStyle]}
                                                                        >
                                                                            <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 16, marginBottom: 10 }}>{item.question}</Text>

                                                                            <View style={{ gap: 5, marginBottom: 10 }}>
                                                                                {item.options?.map((opt: string, i: number) => (
                                                                                    <Text key={i} style={{
                                                                                        color: i === item.correctOptionIndex ? '#16a34a' : theme.secondary,
                                                                                        fontWeight: i === item.correctOptionIndex ? 'bold' : '400'
                                                                                    }}>
                                                                                        {String.fromCharCode(65 + i)}. {opt}
                                                                                    </Text>
                                                                                ))}
                                                                            </View>

                                                                            <View style={{ backgroundColor: theme.highlight, padding: 10, borderRadius: 8 }}>
                                                                                <Text style={{ fontSize: 12, color: theme.secondary }}>{item.explanation}</Text>
                                                                            </View>
                                                                        </TouchableOpacity>
                                                                    );
                                                                }}
                                                            />
                                                        </View>
                                                    ) : questionsViewMode === 'saved_flashcards' ? (
                                                        <View style={{ flex: 1 }}>
                                                            {/* Saved Questions Group View (From Cards tab) - strictly Flashcard questions */}
                                                            <View style={{ flexDirection: 'row', alignItems: 'center', paddingHorizontal: 20, paddingBottom: 10 }}>
                                                                <TouchableOpacity onPress={() => setQuestionsViewMode('cards')} style={{ flexDirection: 'row', alignItems: 'center', gap: 5 }}>
                                                                    <ChevronLeft size={20} color={primaryColor} />
                                                                    <Text style={{ color: primaryColor, fontSize: 16 }}>Back</Text>
                                                                </TouchableOpacity>
                                                            </View>

                                                            <View style={{ padding: 20, paddingTop: 0, paddingBottom: 0, alignItems: 'center' }}>
                                                                <Text style={{ color: theme.secondary, marginBottom: 10 }}>{savedQuestions.filter(q => !q.options || q.options.length === 0).length} flashcards saved</Text>
                                                                {savedQuestions.filter(q => !q.options || q.options.length === 0).length > 0 && (
                                                                    <View style={{ alignItems: 'center', width: '100%' }}>
                                                                        <View style={{ flexDirection: 'row', gap: 10, marginBottom: 15, width: '100%', paddingHorizontal: 20 }}>
                                                                            <TouchableOpacity
                                                                                onPress={handleSavedQuestionsFlashcards}
                                                                                style={{ flex: 1, backgroundColor: primaryColor, paddingVertical: 12, borderRadius: 12, alignItems: 'center', justifyContent: 'center', shadowColor: primaryColor, shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.2, shadowRadius: 3, elevation: 2 }}
                                                                            >
                                                                                <Text style={{ color: 'white', fontWeight: 'bold' }}>Practice Flashcards</Text>
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    </View>
                                                                )}
                                                            </View>
                                                            <FlatList
                                                                key={isLandscape ? 'lib_land_saved_cards' : 'lib_port_saved_cards'}
                                                                numColumns={isLandscape ? 2 : 1}
                                                                columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                                contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                                                // Filter for Flashcard Questions (no options)
                                                                data={savedQuestions.filter((q: any) => !q.options || q.options.length === 0).filter((q: any) => !librarySearchQuery || q.question.toLowerCase().includes(librarySearchQuery.toLowerCase())).sort((a: any, b: any) => new Date(b.savedAt || 0).getTime() - new Date(a.savedAt || 0).getTime())}
                                                                ListFooterComponent={<View style={{ height: 20 }} />}
                                                                keyExtractor={(item: any, index: number) => item.id || index.toString()}
                                                                extraData={{ savedQuestions, librarySearchQuery }}
                                                                ListEmptyComponent={
                                                                    <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                                        {librarySearchQuery ? (
                                                                            <>
                                                                                <Search size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                                <Text style={{ color: theme.secondary, marginTop: 10 }}>No matches found.</Text>
                                                                            </>
                                                                        ) : (
                                                                            <>
                                                                                <HelpCircle size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                                <Text style={{ color: theme.secondary, marginTop: 10 }}>No saved flashcards.</Text>
                                                                            </>
                                                                        )}
                                                                    </View>
                                                                }
                                                                renderItem={({ item, index }: { item: any, index: number }) => {
                                                                    const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 15 };
                                                                    return (
                                                                        <TouchableOpacity
                                                                            onLongPress={() => {
                                                                                Alert.alert("Delete Flashcard", "Remove this flashcard?", [
                                                                                    { text: "Cancel", style: "cancel" },
                                                                                    { text: "Delete", style: 'destructive', onPress: () => toggleSaveQuestion(item) }
                                                                                ]);
                                                                            }}
                                                                            delayLongPress={500}
                                                                            activeOpacity={0.8}
                                                                            style={[{
                                                                                backgroundColor: theme.uiBg,
                                                                                borderRadius: 12,
                                                                                borderWidth: 1,
                                                                                borderColor: theme.border,
                                                                                padding: 15
                                                                            }, containerStyle]}
                                                                        >
                                                                            <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 16, marginBottom: 10 }}>{item.question}</Text>
                                                                            <Text style={{ color: theme.secondary }}>{item.explanation || item.answer}</Text>
                                                                        </TouchableOpacity>
                                                                    );
                                                                }}
                                                            />
                                                        </View>
                                                    ) : questionsViewMode === 'cards' ? (
                                                        <FlatList
                                                            key={isLandscape ? 'lib_land_cards' : 'lib_port_cards'}
                                                            numColumns={isLandscape ? 2 : 1}
                                                            columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                            contentContainerStyle={{ padding: 20, paddingTop: 0, paddingBottom: 100 }}
                                                            data={filteredLibraryItems}
                                                            ListFooterComponent={<View style={{ height: 20 }} />}
                                                            keyExtractor={(item: ChatSession) => item.id}

                                                            extraData={{ librarySearchQuery, questionsViewMode }}
                                                            ListEmptyComponent={
                                                                <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                                    <Copy size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>No flashcards.</Text>
                                                                    {!librarySearchQuery && (
                                                                        <TouchableOpacity onPress={() => { setSelectedScenario(SCHOOL_TOOLS.find(t => t.id === 'examiner')); setAppMode('setup'); }} style={{ marginTop: 20 }}>
                                                                            <Text style={{ color: '#2563eb' }}>Create Flashcards</Text>
                                                                        </TouchableOpacity>
                                                                    )}
                                                                </View>
                                                            }
                                                            renderItem={({ item: session }: { item: any }) => {
                                                                // Special handling for the "Saved Questions" group item
                                                                if (session.isGroup) {
                                                                    const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 10 };
                                                                    return (
                                                                        <TouchableOpacity
                                                                            onPress={() => setQuestionsViewMode('saved_flashcards')}
                                                                            style={[
                                                                                styles.historyItem,
                                                                                {
                                                                                    backgroundColor: theme.id === 'day' ? '#fdf2f8' : 'rgba(236,72,153,0.1)', // Distinct color for "Saved"
                                                                                    borderColor: theme.id === 'day' ? '#fbcfe8' : 'rgba(236,72,153,0.3)',
                                                                                    flexDirection: 'row',
                                                                                    alignItems: 'center',
                                                                                    paddingRight: 10,
                                                                                    borderWidth: 1
                                                                                },
                                                                                containerStyle
                                                                            ]}
                                                                        >
                                                                            <View style={{ width: 48, height: 48, borderRadius: 12, backgroundColor: theme.id === 'day' ? '#fce7f3' : 'rgba(236,72,153,0.2)', alignItems: 'center', justifyContent: 'center', marginRight: 15 }}>
                                                                                <Star size={24} color="#db2777" fill="#db2777" />
                                                                            </View>

                                                                            <View style={{ flex: 1 }}>
                                                                                <Text style={[styles.historyTitle, { color: theme.text, fontSize: 16 }]}>{session.title}</Text>
                                                                                <Text style={{ color: theme.secondary, fontSize: 12 }}>{session.count} Questions</Text>
                                                                            </View>

                                                                            <ChevronRight size={20} color={theme.secondary} opacity={0.5} />
                                                                        </TouchableOpacity>
                                                                    )
                                                                }

                                                                const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 15 } : { marginBottom: 10 };
                                                                const isSelected = selectedLibraryIds.includes(session.id);
                                                                return (
                                                                    <TouchableOpacity
                                                                        onPress={() => handleLibraryPress(session)}
                                                                        onLongPress={() => handleLibraryLongPress(session.id)}
                                                                        delayLongPress={300}
                                                                        activeOpacity={0.8}
                                                                        style={[
                                                                            styles.historyItem,
                                                                            {
                                                                                backgroundColor: isSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.uiBg,
                                                                                borderColor: isSelected ? primaryColor : theme.border,
                                                                                flexDirection: 'row',
                                                                                alignItems: 'center',
                                                                                paddingRight: 10,
                                                                                borderWidth: isSelected ? 2 : 1
                                                                            },
                                                                            containerStyle
                                                                        ]}
                                                                    >
                                                                        <View style={{ flex: 1 }}>
                                                                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}>
                                                                                {isLibrarySelectionMode && (
                                                                                    <View style={{
                                                                                        width: 18, height: 18, borderRadius: 9,
                                                                                        borderWidth: 2, borderColor: isSelected ? primaryColor : theme.secondary,
                                                                                        backgroundColor: isSelected ? primaryColor : 'transparent',
                                                                                        alignItems: 'center', justifyContent: 'center'
                                                                                    }}>
                                                                                        {isSelected && <Check size={10} color="white" />}
                                                                                    </View>
                                                                                )}
                                                                                {session.pinned && (
                                                                                    <Pin size={14} color={primaryColor} fill={primaryColor} style={{ transform: [{ rotate: '45deg' }] }} />
                                                                                )}
                                                                                <Text style={[styles.historyTitle, { color: theme.text, flex: 1 }]} numberOfLines={1}>{session.title || "Untitled Flashcards"}</Text>
                                                                            </View>

                                                                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5, marginLeft: (isLibrarySelectionMode ? 24 : 0) + (session.pinned && !isLibrarySelectionMode ? 0 : 0) }}>
                                                                                <Text style={{ color: theme.secondary, fontSize: 12 }}>{new Date(session.timestamp).toLocaleDateString()}</Text>
                                                                                {session.items && (
                                                                                    <Text style={{ color: theme.secondary, fontSize: 12 }}> â€¢ {session.items.length} Cards</Text>
                                                                                )}
                                                                            </View>
                                                                        </View>

                                                                        <View style={{ padding: 10 }}>
                                                                            <Copy size={20} color={theme.secondary} />
                                                                        </View>
                                                                    </TouchableOpacity>
                                                                );
                                                            }}
                                                        />
                                                    ) : (
                                                        <View style={{ flex: 1 }}>
                                                            <View style={{ padding: 20, paddingTop: 0, paddingBottom: 0, alignItems: 'center' }}>
                                                                <Text style={{ color: theme.secondary, marginBottom: 10 }}>{savedWords.length} words saved</Text>
                                                                {savedWords.length > 0 ? (
                                                                    <View style={{ alignItems: 'center', width: '100%' }}>
                                                                        {/* Toggle Quiz/Flashcards */}
                                                                        <View style={{ flexDirection: 'row', gap: 10, marginBottom: 15, width: '100%', paddingHorizontal: 20 }}>
                                                                            <TouchableOpacity
                                                                                onPress={handleSavedWordsQuiz}
                                                                                style={{ flex: 1, backgroundColor: primaryColor, paddingVertical: 12, borderRadius: 12, alignItems: 'center', justifyContent: 'center', shadowColor: primaryColor, shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.2, shadowRadius: 3, elevation: 2 }}
                                                                            >
                                                                                <Text style={{ color: 'white', fontWeight: 'bold' }}>Practice Quiz</Text>
                                                                            </TouchableOpacity>
                                                                            <TouchableOpacity
                                                                                onPress={handleSavedWordsFlashcards}
                                                                                style={{ flex: 1, backgroundColor: theme.uiBg, borderWidth: 1, borderColor: primaryColor, paddingVertical: 12, borderRadius: 12, alignItems: 'center', justifyContent: 'center' }}
                                                                            >
                                                                                <Text style={{ color: primaryColor, fontWeight: 'bold' }}>Flashcards</Text>
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    </View>
                                                                ) : !librarySearchQuery && (
                                                                    <Text style={{ fontStyle: 'italic', color: theme.secondary, textAlign: 'center' }}>Save words to start a quiz.</Text>
                                                                )}
                                                            </View>
                                                            <FlatList
                                                                key={isLandscape ? 'lib_land_vocab' : 'lib_port_vocab'} // Force remount on orientation change
                                                                numColumns={isLandscape ? 2 : 1}
                                                                columnWrapperStyle={isLandscape ? { justifyContent: 'space-between', gap: 15 } : null}
                                                                contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                                                // Use memoized filtered data
                                                                data={filteredLibraryItems}
                                                                ListFooterComponent={<View style={{ height: 20 }} />}
                                                                keyExtractor={(item: any, index: number) => item.id || index.toString()}
                                                                extraData={{ savedWords, librarySearchQuery }} // FIXED: Ensure list updates on state change
                                                                ListEmptyComponent={
                                                                    <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                                        {librarySearchQuery ? (
                                                                            <>
                                                                                <Search size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                                <Text style={{ color: theme.secondary, marginTop: 10 }}>No matches found.</Text>
                                                                            </>
                                                                        ) : (
                                                                            <>
                                                                                <BookA size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                                <Text style={{ color: theme.secondary, marginTop: 10 }}>No saved words.</Text>
                                                                            </>
                                                                        )}
                                                                    </View>
                                                                }
                                                                renderItem={({ item }: { item: any }) => {
                                                                    const containerStyle = isLandscape ? { flex: 0.5, marginBottom: 10 } : { marginBottom: 10 };
                                                                    return (
                                                                        <TouchableOpacity
                                                                            onPress={() => { handleWordLookup(item.word); }}
                                                                            onLongPress={() => {
                                                                                Alert.alert("Delete Word", `Remove "${item.word}"?`, [
                                                                                    { text: "Cancel", style: "cancel" },
                                                                                    { text: "Delete", style: 'destructive', onPress: () => deleteSavedWord(item.id) }
                                                                                ]);
                                                                            }}
                                                                            delayLongPress={500}
                                                                            style={[styles.historyItem, { backgroundColor: theme.uiBg, borderColor: theme.border, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }, containerStyle]}
                                                                        >
                                                                            <View style={{ flex: 1, marginRight: 10 }}>
                                                                                <View style={{ flexDirection: 'row', alignItems: 'baseline', gap: 8, marginBottom: 2 }}>
                                                                                    <Text style={[styles.historyTitle, { color: theme.text, marginBottom: 0 }]}>{item.word}</Text>
                                                                                    {item.partOfSpeech && (
                                                                                        <Text style={{ fontSize: 11, color: primaryColor, fontWeight: '700', fontStyle: 'italic' }}>
                                                                                            {item.partOfSpeech}
                                                                                        </Text>
                                                                                    )}
                                                                                </View>
                                                                                <Text style={{ color: theme.secondary, fontSize: 12 }} numberOfLines={1}>{item.definition}</Text>
                                                                            </View>
                                                                            <View style={{ backgroundColor: theme.highlight, padding: 5, borderRadius: 5 }}>
                                                                                <Text style={{ fontSize: 10, color: theme.secondary }}>View</Text>
                                                                            </View>
                                                                        </TouchableOpacity>
                                                                    );
                                                                }}
                                                            />
                                                        </View>
                                                    )}
                                                </View>
                                            )}
                                        </View>
                                    </View>
                                ) : activeTab === 'dictionary' ? (
                                    isLandscape ? (
                                        /* LANDSCAPE DICTIONARY LAYOUT (SPLIT VIEW) */
                                        <View style={{ flex: 1, flexDirection: 'row' }}>
                                            {/* LEFT: Search & History List */}
                                            <View style={{ flex: 1, borderRightWidth: 1, borderRightColor: theme.border, backgroundColor: theme.uiBg }}>
                                                <View style={{ padding: 15, paddingBottom: 5, zIndex: 50 }}>
                                                    {/* Batch Processing Indicator (Non-blocking) */}
                                                    {isBatchProcessing && (
                                                        <View style={{ backgroundColor: theme.highlight, padding: 10, borderRadius: 8, marginBottom: 10, flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                                                            <ActivityIndicator size="small" color={primaryColor} />
                                                            <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }}>Processing batch words...</Text>
                                                        </View>
                                                    )}
                                                    {renderDictionarySearchBar({ marginBottom: 10 })}

                                                    {/* Autocomplete Suggestions Dropdown */}
                                                    {dictionarySuggestions.length > 0 && (
                                                        <View style={{
                                                            position: 'absolute',
                                                            top: 60,
                                                            left: 15,
                                                            right: 15,
                                                            backgroundColor: theme.uiBg,
                                                            borderRadius: 12,
                                                            borderWidth: 1,
                                                            borderColor: theme.border,
                                                            zIndex: 100,
                                                            shadowColor: "#000",
                                                            shadowOffset: { width: 0, height: 4 },
                                                            shadowOpacity: 0.1,
                                                            shadowRadius: 5,
                                                            elevation: 5
                                                        }}>
                                                            {dictionarySuggestions.map((word: string, idx: number) => (
                                                                <TouchableOpacity
                                                                    key={idx}
                                                                    onPress={() => handleDictionaryTabSearch(word)}
                                                                    style={{
                                                                        padding: 12,
                                                                        borderBottomWidth: idx === dictionarySuggestions.length - 1 ? 0 : 1,
                                                                        borderBottomColor: theme.border,
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center'
                                                                    }}
                                                                >
                                                                    <History size={12} color={theme.secondary} style={{ marginRight: 10 }} />
                                                                    <Text style={{ color: theme.text, fontSize: 14 }}>{word}</Text>
                                                                </TouchableOpacity>
                                                            ))}
                                                        </View>
                                                    )}
                                                </View>

                                                <View style={{ flexDirection: 'row', justifyContent: 'space-between', paddingHorizontal: 15, marginBottom: 8, alignItems: 'center' }}>
                                                    <Text style={{ color: theme.secondary, fontSize: 11, fontWeight: 'bold', textTransform: 'uppercase' }}>HISTORY ({recentSearches.length})</Text>

                                                    <View style={{ flexDirection: 'row', gap: 10 }}>
                                                        <TouchableOpacity onPress={handleImportDictionary}>
                                                            <FileDown size={16} color={theme.text} />
                                                        </TouchableOpacity>
                                                        <TouchableOpacity onPress={handleExportDictionary}>
                                                            <Upload size={16} color={theme.text} />
                                                        </TouchableOpacity>
                                                    </View>
                                                </View>

                                                <FlatList
                                                    data={recentSearches.slice(0, visibleWordCount)}
                                                    keyExtractor={(item: any, index: number) => (typeof item === 'string' ? item : item.word) + index}
                                                    contentContainerStyle={{ paddingBottom: 100 }}
                                                    showsVerticalScrollIndicator={false}
                                                    onEndReached={() => setVisibleWordCount((prev: number) => prev + 25)}
                                                    onEndReachedThreshold={0.5}
                                                    renderItem={({ item }: { item: any }) => {
                                                        const displayWord = typeof item === 'string' ? item : item.word;
                                                        const data = typeof item === 'object' ? item.data : null;
                                                        const def = data?.simple?.definition || data?.definition || "Tap to define";
                                                        const isSelected = dictionaryCurrentWord.toLowerCase() === displayWord.toLowerCase();

                                                        return (
                                                            <TouchableOpacity
                                                                onPress={() => {
                                                                    // In landscape, searching updates the right panel
                                                                    handleDictionaryTabSearch(displayWord);
                                                                }}
                                                                onLongPress={() => deleteRecentSearch(displayWord)}
                                                                style={{
                                                                    flexDirection: 'row',
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    paddingVertical: 12,
                                                                    paddingHorizontal: 15,
                                                                    backgroundColor: isSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : 'transparent',
                                                                    borderBottomWidth: 1,
                                                                    borderBottomColor: theme.border
                                                                }}
                                                            >
                                                                <View style={{ flex: 1 }}>
                                                                    <Text style={{ fontSize: 14, fontWeight: isSelected ? 'bold' : '600', color: isSelected ? primaryColor : theme.text }}>{displayWord}</Text>
                                                                    <Text style={{ fontSize: 11, color: theme.secondary, marginTop: 2 }} numberOfLines={1}>{def}</Text>
                                                                </View>
                                                                {isSelected && <ChevronDown size={14} color={primaryColor} style={{ transform: [{ rotate: '-90deg' }] }} />}
                                                            </TouchableOpacity>
                                                        );
                                                    }}
                                                    ListEmptyComponent={
                                                        <View style={{ alignItems: 'center', marginTop: 50, opacity: 0.5 }}>
                                                            <BookOpen size={32} color={theme.secondary} />
                                                            <Text style={{ color: theme.secondary, marginTop: 10, fontSize: 12, textAlign: 'center' }}>Empty History</Text>
                                                        </View>
                                                    }
                                                />
                                            </View>

                                            {/* RIGHT: Content Area */}
                                            <View style={{ flex: 1.5, backgroundColor: theme.bg, padding: 25 }}>
                                                {isDictionaryLoading ? (
                                                    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                                                        <ActivityIndicator size="large" color={primaryColor} />
                                                        <Text style={{ color: theme.secondary, marginTop: 15, fontWeight: '600' }}>Defining...</Text>
                                                    </View>
                                                ) : dictionaryResult ? (
                                                    renderDefinitionContent(
                                                        dictionaryResult,
                                                        dictionaryCurrentWord,
                                                        isWordSaved,
                                                        toggleSaveWord,
                                                        false,
                                                        () => handleStartQuiz(`The meaning and usage of the word '${dictionaryCurrentWord}'`),
                                                        () => handleRefreshDefinition(dictionaryCurrentWord)
                                                    )
                                                ) : (
                                                    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', opacity: 0.6 }}>
                                                        <BookA size={64} color={theme.secondary} style={{ marginBottom: 20 }} />
                                                        <Text style={{ fontSize: 18, fontWeight: 'bold', color: theme.text }}>Select a word</Text>
                                                        <Text style={{ color: theme.secondary, textAlign: 'center', marginTop: 10, maxWidth: 300 }}>
                                                            Search for a word on the left or select one from your history to view its definition here.
                                                        </Text>
                                                    </View>
                                                )}
                                            </View>
                                        </View>
                                    ) : (
                                        /* PORTRAIT DICTIONARY LAYOUT (EXISTING) */
                                        <View style={{ flex: 1, padding: 20 }}>
                                            {/* Batch Processing Indicator (Non-blocking) */}
                                            {isBatchProcessing && (
                                                <View style={{ backgroundColor: theme.highlight, padding: 10, borderRadius: 8, marginBottom: 15, flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                                                    <ActivityIndicator size="small" color={primaryColor} />
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600' }}>Processing batch words in background...</Text>
                                                </View>
                                            )}
                                            <View style={{ zIndex: 10 }}>
                                                {renderDictionarySearchBar({ marginBottom: 15 })}

                                                {/* Autocomplete Suggestions Dropdown */}
                                                {dictionarySuggestions.length > 0 && (
                                                    <View style={{
                                                        position: 'absolute',
                                                        top: 65, // Just below search bar
                                                        left: 0,
                                                        right: 0,
                                                        backgroundColor: theme.uiBg,
                                                        borderRadius: 12,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        zIndex: 100,
                                                        shadowColor: "#000",
                                                        shadowOffset: { width: 0, height: 4 },
                                                        shadowOpacity: 0.1,
                                                        shadowRadius: 5,
                                                        elevation: 5
                                                    }}>
                                                        {dictionarySuggestions.map((word: string, idx: number) => (
                                                            <TouchableOpacity
                                                                key={idx}
                                                                onPress={() => handleDictionaryTabSearch(word)}
                                                                style={{
                                                                    padding: 15,
                                                                    borderBottomWidth: idx === dictionarySuggestions.length - 1 ? 0 : 1,
                                                                    borderBottomColor: theme.border,
                                                                    flexDirection: 'row',
                                                                    alignItems: 'center'
                                                                }}
                                                            >
                                                                <History size={14} color={theme.secondary} style={{ marginRight: 10 }} />
                                                                <Text style={{ color: theme.text, fontSize: 16 }}>{word}</Text>
                                                            </TouchableOpacity>
                                                        ))}
                                                    </View>
                                                )}
                                            </View>

                                            {recentSearches.length > 0 && !isDictionaryLoading && !isBatchProcessing && (
                                                <View style={{ marginBottom: 20, zIndex: 1 }}>
                                                    <Text style={{ color: theme.secondary, fontSize: 12, fontWeight: 'bold', marginBottom: 8, textTransform: 'uppercase' }}>Recently Searched</Text>
                                                    <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 8 }}>
                                                        {recentSearches.slice(0, 15).map((item: any, index: number) => (
                                                            <TouchableOpacity
                                                                key={index}
                                                                onPress={() => handleDictionaryTabSearch(item.word)}
                                                                onLongPress={() => deleteRecentSearch(item.word)}
                                                                style={{ flexDirection: 'row', alignItems: 'center', paddingHorizontal: 12, paddingVertical: 6, borderRadius: 20, backgroundColor: theme.highlight, borderWidth: 1, borderColor: theme.border }}
                                                            >
                                                                <History size={12} color={theme.secondary} style={{ marginRight: 4 }} />
                                                                <Text style={{ color: theme.text, fontSize: 14 }}>{item.word}</Text>
                                                            </TouchableOpacity>
                                                        ))}
                                                    </ScrollView>
                                                </View>
                                            )}

                                            <View style={{ flex: 1 }}>
                                                {isDictionaryLoading ? (
                                                    <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                        <ActivityIndicator size="large" color={primaryColor} />
                                                        <Text style={{ color: theme.secondary, marginTop: 10 }}>Looking up definition...</Text>
                                                    </View>
                                                ) : dictionaryResult ? (
                                                    <View style={{ flex: 1 }}>
                                                        {renderDefinitionContent(
                                                            dictionaryResult,
                                                            dictionaryCurrentWord,
                                                            isWordSaved,
                                                            toggleSaveWord,
                                                            false,
                                                            () => handleStartQuiz(`The meaning and usage of the word '${dictionaryCurrentWord}'`),
                                                            () => handleRefreshDefinition(dictionaryCurrentWord)
                                                        )}
                                                    </View>
                                                ) : (
                                                    // Dictionary List View (Default)
                                                    <View style={{ flex: 1 }}>
                                                        <View style={{ marginBottom: 20 }}>
                                                            <View style={{ marginBottom: 12 }}>
                                                                <Text style={{ fontSize: 22, fontWeight: 'bold', color: theme.text }}>Recent Words Flashcards</Text>
                                                                <Text style={{ fontSize: 13, color: theme.secondary }}>{recentSearches.length} words in history</Text>
                                                            </View>

                                                            <View style={{ flexDirection: 'row', gap: 10 }}>
                                                                <TouchableOpacity
                                                                    onPress={handleShareDictionary}
                                                                    disabled={isSharing}
                                                                    style={{
                                                                        flex: 1,
                                                                        paddingVertical: 10,
                                                                        backgroundColor: theme.buttonBg,
                                                                        borderRadius: 12,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border,
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        gap: 6,
                                                                        opacity: isSharing ? 0.6 : 1
                                                                    }}
                                                                >
                                                                    {isSharing ? (
                                                                        <ActivityIndicator size="small" color={theme.text} />
                                                                    ) : (
                                                                        <Share2 size={16} color={theme.text} />
                                                                    )}
                                                                    <Text style={{ fontSize: 13, fontWeight: '600', color: theme.text }}>Share</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={handleImportDictionary}
                                                                    style={{
                                                                        flex: 1,
                                                                        paddingVertical: 10,
                                                                        backgroundColor: theme.buttonBg,
                                                                        borderRadius: 12,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border,
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        gap: 6
                                                                    }}
                                                                >
                                                                    <FileDown size={16} color={theme.text} />
                                                                    <Text style={{ fontSize: 13, fontWeight: '600', color: theme.text }}>Import</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={handleExportDictionary}
                                                                    style={{
                                                                        flex: 1,
                                                                        paddingVertical: 10,
                                                                        backgroundColor: theme.buttonBg,
                                                                        borderRadius: 12,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border,
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        gap: 6
                                                                    }}
                                                                >
                                                                    <Upload size={16} color={theme.text} />
                                                                    <Text style={{ fontSize: 13, fontWeight: '600', color: theme.text }}>Export</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={handleDownloadDictionary}
                                                                    style={{
                                                                        flex: 1,
                                                                        paddingVertical: 10,
                                                                        backgroundColor: theme.buttonBg,
                                                                        borderRadius: 12,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border,
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        gap: 6
                                                                    }}
                                                                >
                                                                    <DownloadCloud size={16} color={theme.text} />
                                                                    <Text style={{ fontSize: 13, fontWeight: '600', color: theme.text }}>Download</Text>
                                                                </TouchableOpacity>
                                                            </View>
                                                        </View>

                                                        <FlatList
                                                            data={recentSearches.slice(0, visibleWordCount)}
                                                            keyExtractor={(item: any, index: number) => (typeof item === 'string' ? item : item.word) + index}
                                                            contentContainerStyle={{ paddingBottom: 100 }}
                                                            showsVerticalScrollIndicator={false}
                                                            onEndReached={() => setVisibleWordCount((prev: number) => prev + 25)}
                                                            onEndReachedThreshold={0.5}
                                                            renderItem={({ item }: { item: any }) => {
                                                                const displayWord = typeof item === 'string' ? item : item.word;
                                                                const data = typeof item === 'object' ? item.data : null;
                                                                const def = data?.simple?.definition || data?.definition || "Tap to define";
                                                                const pos = data?.partOfSpeech;

                                                                return (
                                                                    <TouchableOpacity
                                                                        onPress={() => handleWordLookup(displayWord)}
                                                                        onLongPress={() => deleteRecentSearch(displayWord)}
                                                                        style={{
                                                                            flexDirection: 'row',
                                                                            justifyContent: 'space-between',
                                                                            alignItems: 'center',
                                                                            paddingVertical: 12,
                                                                            borderBottomWidth: 1,
                                                                            borderBottomColor: theme.border
                                                                        }}
                                                                    >
                                                                        <View style={{ flex: 1, marginRight: 10 }}>
                                                                            <View style={{ flexDirection: 'row', alignItems: 'baseline', gap: 8 }}>
                                                                                <Text style={{ fontSize: 16, fontWeight: '600', color: theme.text }}>{displayWord}</Text>
                                                                                {pos ? (
                                                                                    <Text style={{ fontSize: 11, color: primaryColor, fontStyle: 'italic' }}>{pos}</Text>
                                                                                ) : null}
                                                                            </View>
                                                                            <Text style={{ fontSize: 12, color: theme.secondary, marginTop: 2 }} numberOfLines={1}>
                                                                                {def}
                                                                            </Text>
                                                                        </View>
                                                                    </TouchableOpacity>
                                                                );
                                                            }}
                                                            ListEmptyComponent={
                                                                <View style={{ alignItems: 'center', marginTop: 50, opacity: 0.5 }}>
                                                                    <BookOpen size={48} color={theme.secondary} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 15, textAlign: 'center' }}>
                                                                        Your history is empty.
                                                                    </Text>
                                                                </View>
                                                            }
                                                        />
                                                    </View>
                                                )}
                                            </View>
                                        </View>
                                    )
                                ) : activeTab === 'story' ? (
                                    <KeyboardAvoidingView
                                        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                                        style={{ flex: 1 }}
                                        keyboardVerticalOffset={Platform.OS === 'ios' ? 100 : 0} // Adjusted offset
                                    >
                                        <View style={{ flex: 1, backgroundColor: theme.bg }}>
                                            {/* NEW: Top Bar Toggle for Story vs Editorial */}
                                            <View style={{ paddingHorizontal: 20, paddingTop: 20, paddingBottom: 10 }}>
                                                <View style={{ flexDirection: 'row', backgroundColor: theme.buttonBg, padding: 4, borderRadius: 12 }}>
                                                    <TouchableOpacity
                                                        onPress={() => setStoryTabMode('story')}
                                                        style={{
                                                            flex: 1,
                                                            paddingVertical: 8,
                                                            alignItems: 'center',
                                                            borderRadius: 10,
                                                            backgroundColor: storyTabMode === 'story' ? theme.bg : 'transparent',
                                                            shadowColor: "#000",
                                                            shadowOffset: { width: 0, height: 1 },
                                                            shadowOpacity: storyTabMode === 'story' ? 0.1 : 0,
                                                            shadowRadius: 2,
                                                            elevation: storyTabMode === 'story' ? 2 : 0,
                                                            flexDirection: 'row',
                                                            justifyContent: 'center',
                                                            gap: 6
                                                        }}
                                                    >
                                                        <BookOpenText size={16} color={storyTabMode === 'story' ? primaryColor : theme.secondary} />
                                                        <Text style={{ fontWeight: 'bold', color: storyTabMode === 'story' ? theme.text : theme.secondary, fontSize: 13 }}>Story Generator</Text>
                                                    </TouchableOpacity>

                                                    <TouchableOpacity
                                                        onPress={() => setStoryTabMode('editorial')}
                                                        style={{
                                                            flex: 1,
                                                            paddingVertical: 8,
                                                            alignItems: 'center',
                                                            borderRadius: 10,
                                                            backgroundColor: storyTabMode === 'editorial' ? theme.bg : 'transparent',
                                                            shadowColor: "#000",
                                                            shadowOffset: { width: 0, height: 1 },
                                                            shadowOpacity: storyTabMode === 'editorial' ? 0.1 : 0,
                                                            shadowRadius: 2,
                                                            elevation: storyTabMode === 'editorial' ? 2 : 0,
                                                            flexDirection: 'row',
                                                            justifyContent: 'center',
                                                            gap: 6
                                                        }}
                                                    >
                                                        <ScrollText size={16} color={storyTabMode === 'editorial' ? primaryColor : theme.secondary} />
                                                        <Text style={{ fontWeight: 'bold', color: storyTabMode === 'editorial' ? theme.text : theme.secondary, fontSize: 13 }}>Editorial</Text>
                                                    </TouchableOpacity>
                                                </View>
                                            </View>

                                            {storyTabMode === 'story' ? (
                                                /* --- STORY GENERATOR UI --- */
                                                <>
                                                    <ScrollView
                                                        contentContainerStyle={{ flexGrow: 1, padding: 20, paddingTop: 0 }}
                                                        keyboardShouldPersistTaps="handled"
                                                    >
                                                        {/* ... content omitted for brevity, logic remains same, just wrapper changes ... */}
                                                        {/* RE-INSERTING START OF CONTENT TO MATCH CONTEXT CORRECTLY IF NEEDED, BUT HERE I AM JUST WRAPPING THE WHOLE BLOCK APPROXIMATELY */}

                                                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 20, gap: 15, marginTop: 10 }}>
                                                            <View style={{ width: 50, height: 50, backgroundColor: theme.highlight, borderRadius: 16, alignItems: 'center', justifyContent: 'center' }}>
                                                                <Feather size={24} color={primaryColor} />
                                                            </View>
                                                            <View style={{ flex: 1 }}>
                                                                <Text style={{ fontSize: 18, fontWeight: 'bold', color: theme.text }}>Story Generator</Text>
                                                                <Text style={{ fontSize: 12, color: theme.secondary }}>Write Novels, Epics, & Biographies</Text>
                                                            </View>
                                                        </View>

                                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>Story Details</Text>
                                                        <View style={{ marginBottom: 20 }}>
                                                            <View style={[styles.input, { backgroundColor: theme.inputBg, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', paddingRight: 5, minHeight: 60, paddingVertical: 5 }]}>
                                                                <TextInput
                                                                    style={{ flex: 1, color: theme.text, fontSize: 16, paddingLeft: 10, paddingRight: 5 }}
                                                                    placeholder="Enter Title: Description..."
                                                                    placeholderTextColor={theme.secondary}
                                                                    value={storyQuery}
                                                                    onChangeText={setStoryQuery}
                                                                    multiline={true}
                                                                />

                                                                <TouchableOpacity
                                                                    onPress={() => handleVoiceToggle('story_query')}
                                                                    style={{ width: 38, height: 38, alignItems: 'center', justifyContent: 'center' }}
                                                                >
                                                                    {isTranscribing && voiceTarget === 'story_query' ? (
                                                                        <ActivityIndicator size="small" color={theme.text} />
                                                                    ) : (
                                                                        <Animated.View style={{ opacity: voiceTarget === 'story_query' ? recordingOpacity : 1 }}>
                                                                            <Mic size={20} color={(isRecording && voiceTarget === 'story_query') ? primaryColor : theme.text} />
                                                                        </Animated.View>
                                                                    )}
                                                                </TouchableOpacity>

                                                                {/* Vision Button inside Search Bar */}
                                                                <TouchableOpacity
                                                                    onPress={() => {
                                                                        setImagePickerMode('story');
                                                                        setShowImageSourceModal(true);
                                                                    }}
                                                                    style={{ width: 38, height: 38, alignItems: 'center', justifyContent: 'center', marginRight: 4 }}
                                                                >
                                                                    <Camera size={20} color={theme.text} />
                                                                </TouchableOpacity>

                                                                {/* Generate Action Button inside Search Bar */}
                                                                <TouchableOpacity
                                                                    onPress={handleGenerateBookChapter}
                                                                    style={{ width: 38, height: 38, alignItems: 'center', justifyContent: 'center' }}
                                                                >
                                                                    {storyQuery.trim().length > 0 ? (<ArrowRight size={20} color={primaryColor} />) : (<BookOpenText size={20} color={primaryColor} />)}
                                                                </TouchableOpacity>
                                                            </View>
                                                            <Text style={{ fontSize: 10, color: theme.secondary, marginTop: 5, fontStyle: 'italic' }}>
                                                                Tip: Enter "Title: Description" or just click the book icon for a story based on your profile.
                                                            </Text>
                                                        </View>

                                                        {/* Scrollable Genre Section */}
                                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase' }}>Genre / Style</Text>
                                                        <ScrollView
                                                            showsVerticalScrollIndicator={false}
                                                            contentContainerStyle={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10, paddingBottom: 20 }}
                                                        >

                                                            {/* Genre List */}
                                                            {['Adventure', 'Autobiography', 'Biography', 'Comedy', 'Fantasy', 'Fiction/Novel', 'History', 'Horror', 'Mystery/Thriller', 'Mythology/Epic', 'Philosophy', 'Poetry', 'Sci-Fi'].map((genre: string) => (
                                                                <TouchableOpacity
                                                                    key={genre}
                                                                    onPress={() => setBookParams(prev => ({ ...prev, genre }))}
                                                                    style={{
                                                                        width: '48%',
                                                                        paddingVertical: 12,
                                                                        borderRadius: 16,
                                                                        backgroundColor: bookParams.genre === genre ? primaryColor : theme.buttonBg,
                                                                        borderWidth: 1,
                                                                        borderColor: bookParams.genre === genre ? primaryColor : theme.border,
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center'
                                                                    }}
                                                                >
                                                                    <Text
                                                                        style={{ color: bookParams.genre === genre ? 'white' : theme.text, fontWeight: '600', fontSize: 14, textAlign: 'center' }}
                                                                        numberOfLines={2}
                                                                    >
                                                                        {genre}
                                                                    </Text>
                                                                </TouchableOpacity>
                                                            ))}
                                                        </ScrollView>
                                                    </ScrollView>

                                                    {/* Removed separate bottom generate button as it's now in the search bar */}
                                                </>
                                            ) : (
                                                /* --- EDITORIAL GENERATOR UI --- */
                                                <>
                                                    <ScrollView
                                                        contentContainerStyle={{ flexGrow: 1, padding: 20, paddingTop: 0 }}
                                                        keyboardShouldPersistTaps="handled"
                                                    >
                                                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 20, gap: 15, marginTop: 10 }}>
                                                            <View style={{ width: 50, height: 50, backgroundColor: theme.highlight, borderRadius: 16, alignItems: 'center', justifyContent: 'center' }}>
                                                                <ScrollText size={24} color={primaryColor} />
                                                            </View>
                                                            <View style={{ flex: 1 }}>
                                                                <Text style={{ fontSize: 18, fontWeight: 'bold', color: theme.text }}>Editorial Writer</Text>
                                                                <Text style={{ fontSize: 12, color: theme.secondary }}>Opinions, Articles & News Analysis</Text>
                                                            </View>
                                                        </View>

                                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>Topic / Headline</Text>
                                                        <View style={{ marginBottom: 20 }}>
                                                            <View style={[styles.input, { backgroundColor: theme.inputBg, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', paddingRight: 5, minHeight: 60, paddingVertical: 5 }]}>
                                                                <TextInput
                                                                    style={{ flex: 1, color: theme.text, fontSize: 16, paddingLeft: 10, paddingRight: 5 }}
                                                                    placeholder="e.g. The Future of AI in Schools"
                                                                    placeholderTextColor={theme.secondary}
                                                                    value={editorialParams.topic}
                                                                    onChangeText={(t: string) => setEditorialParams(prev => ({ ...prev, topic: t }))}
                                                                    multiline={true}
                                                                />

                                                                <TouchableOpacity
                                                                    onPress={() => handleVoiceToggle('editorial_topic')}
                                                                    style={{ width: 38, height: 38, alignItems: 'center', justifyContent: 'center' }}
                                                                >
                                                                    {isTranscribing && voiceTarget === 'editorial_topic' ? (
                                                                        <ActivityIndicator size="small" color={theme.text} />
                                                                    ) : (
                                                                        <Animated.View style={{ opacity: voiceTarget === 'editorial_topic' ? recordingOpacity : 1 }}>
                                                                            <Mic size={20} color={(isRecording && voiceTarget === 'editorial_topic') ? primaryColor : theme.text} />
                                                                        </Animated.View>
                                                                    )}
                                                                </TouchableOpacity>

                                                                {/* Vision Button */}
                                                                <TouchableOpacity
                                                                    onPress={() => {
                                                                        setImagePickerMode('editorial');
                                                                        setShowImageSourceModal(true);
                                                                    }}
                                                                    style={{ width: 38, height: 38, alignItems: 'center', justifyContent: 'center', marginRight: 4 }}
                                                                >
                                                                    <Camera size={20} color={theme.text} />
                                                                </TouchableOpacity>

                                                                {/* Write/Brainstorm Action Button */}
                                                                <TouchableOpacity
                                                                    onPress={handleGenerateEditorial}
                                                                    style={{ width: 38, height: 38, alignItems: 'center', justifyContent: 'center' }}
                                                                >
                                                                    {editorialParams.topic.trim().length > 0 ? (
                                                                        <ArrowRight size={20} color={primaryColor} />
                                                                    ) : (
                                                                        <Sparkles size={20} color={primaryColor} />
                                                                    )}
                                                                </TouchableOpacity>
                                                            </View>
                                                            <Text style={{ fontSize: 10, color: theme.secondary, marginTop: 5, fontStyle: 'italic' }}>
                                                                Tip: Enter a topic or just click the sparkles icon to brainstorm and write automatically.
                                                            </Text>
                                                        </View>

                                                        {/* Stance Selection */}
                                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase' }}>Stance / Perspective</Text>
                                                        <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10, paddingBottom: 20 }}>

                                                            {['Balanced', 'Opinionated', 'Critical', 'Supportive', 'Satirical', 'Analytical', 'Persuasive'].map((stance: string) => (
                                                                <TouchableOpacity
                                                                    key={stance}
                                                                    onPress={() => setEditorialParams(prev => ({ ...prev, stance }))}
                                                                    style={{
                                                                        width: '48%',
                                                                        paddingVertical: 12,
                                                                        borderRadius: 16,
                                                                        backgroundColor: editorialParams.stance === stance ? primaryColor : theme.buttonBg,
                                                                        borderWidth: 1,
                                                                        borderColor: editorialParams.stance === stance ? primaryColor : theme.border,
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center'
                                                                    }}
                                                                >
                                                                    <Text style={{ color: editorialParams.stance === stance ? 'white' : theme.text, fontWeight: '600', fontSize: 13, textAlign: 'center' }} numberOfLines={1}>{stance}</Text>
                                                                </TouchableOpacity>
                                                            ))}
                                                        </View>

                                                        {/* Tone Selection */}
                                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase' }}>Tone of Voice</Text>
                                                        <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10, paddingBottom: 20 }}>
                                                            {['Professional', 'Casual', 'Academic', 'Urgent', 'Inspirational', 'Witty', 'Direct'].map((tone: string) => (
                                                                <TouchableOpacity
                                                                    key={tone}
                                                                    onPress={() => setEditorialParams(prev => ({ ...prev, tone }))}
                                                                    style={{
                                                                        width: '48%',
                                                                        paddingVertical: 12,
                                                                        borderRadius: 16,
                                                                        backgroundColor: editorialParams.tone === tone ? primaryColor : theme.buttonBg,
                                                                        borderWidth: 1,
                                                                        borderColor: editorialParams.tone === tone ? primaryColor : theme.border,
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center'
                                                                    }}
                                                                >
                                                                    <Text style={{ color: editorialParams.tone === tone ? 'white' : theme.text, fontWeight: '600', fontSize: 13, textAlign: 'center' }} numberOfLines={1}>{tone}</Text>
                                                                </TouchableOpacity>
                                                            ))}
                                                        </View>



                                                    </ScrollView>

                                                    {/* Removed separate bottom write button as it's now in the search bar */}
                                                </>
                                            )}
                                        </View>
                                    </KeyboardAvoidingView>
                                ) : activeTab === 'settings' ? (
                                    <KeyboardAvoidingView
                                        key="settings-keyboard-wrapper"
                                        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                                        style={{ flex: 1 }}
                                        keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
                                    >
                                        {renderSettingsScreen()}
                                    </KeyboardAvoidingView>
                                ) : (
                                    <View style={{ flex: 1, padding: 20 }}>
                                        {isEditingNote ? (
                                            <KeyboardAvoidingView
                                                behavior={Platform.OS === "ios" ? "padding" : "height"}
                                                keyboardVerticalOffset={Platform.OS === 'ios' ? 100 : 20}
                                                style={{ flex: 1 }}
                                            >
                                                {/* NEW: Landscape Split for Note Editor */}
                                                {isLandscape ? (
                                                    <View style={{ flex: 1, flexDirection: 'row', gap: 20 }}>
                                                        {/* LEFT: Editor Area */}
                                                        <View style={{ flex: 1.5 }}>
                                                            <View style={{ marginBottom: 15 }}>
                                                                <TextInput
                                                                    style={[styles.input, {
                                                                        color: theme.text,
                                                                        borderColor: theme.border,
                                                                        backgroundColor: theme.inputBg,
                                                                        fontWeight: 'bold',
                                                                        fontSize: 18,
                                                                        marginBottom: 0,
                                                                        paddingRight: 50
                                                                    }]}
                                                                    placeholder="Title"
                                                                    placeholderTextColor={theme.secondary}
                                                                    value={currentNoteTitle}
                                                                    onChangeText={setCurrentNoteTitle}
                                                                    onFocus={() => setActiveNoteField('title')}
                                                                    maxLength={100}
                                                                />
                                                                {renderMicButton('note_title', { position: 'absolute', right: 10, top: 11, backgroundColor: theme.uiBg })}
                                                            </View>

                                                            <View style={{ flex: 1, position: 'relative' }}>
                                                                <TextInput
                                                                    style={[styles.textArea, { flex: 1, color: theme.text, borderColor: theme.border, backgroundColor: theme.inputBg, fontSize: 16, textAlignVertical: 'top', marginBottom: 0, height: undefined, paddingBottom: 50 }]}
                                                                    placeholder="Write your notes here..."
                                                                    placeholderTextColor={theme.secondary}
                                                                    value={currentNoteInput}
                                                                    onChangeText={handleNoteInputChange}
                                                                    onFocus={() => setActiveNoteField('body')}
                                                                    multiline
                                                                />
                                                                {renderMicButton('note_body', {
                                                                    position: 'absolute', bottom: 20, right: 15,
                                                                    backgroundColor: (isRecording && voiceTarget === 'note_body') ? '#ef4444' : theme.uiBg,
                                                                }, 20)}
                                                            </View>
                                                        </View>

                                                        {/* RIGHT: Tools & Metadata */}
                                                        <View style={{ flex: 1, paddingLeft: 20, borderLeftWidth: 1, borderLeftColor: theme.border }}>
                                                            <ScrollView showsVerticalScrollIndicator={false}>
                                                                <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase' }}>ATTACHMENTS</Text>
                                                                <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 10 }} style={{ marginBottom: 20 }}>
                                                                    <TouchableOpacity
                                                                        onPress={() => { setImagePickerMode('note'); setShowImageSourceModal(true); }}
                                                                        style={{ width: 80, height: 80, borderRadius: 12, backgroundColor: theme.buttonBg, borderWidth: 1, borderColor: theme.border, borderStyle: 'dashed', alignItems: 'center', justifyContent: 'center' }}
                                                                    >
                                                                        <Plus size={24} color={theme.secondary} />
                                                                    </TouchableOpacity>
                                                                    {currentNoteImages.map((uri: string, idx: number) => (
                                                                        <View key={idx} style={{ position: 'relative' }}>
                                                                            <Image source={{ uri: uri }} style={{ width: 80, height: 80, borderRadius: 12, backgroundColor: theme.inputBg }} resizeMode="cover" />
                                                                            <TouchableOpacity onPress={() => {
                                                                                const newImages = [...currentNoteImages];
                                                                                newImages.splice(idx, 1);
                                                                                setCurrentNoteImages(newImages);
                                                                            }} style={{ position: 'absolute', top: 2, right: 2, backgroundColor: 'rgba(0,0,0,0.6)', borderRadius: 10, padding: 2 }}>
                                                                                <X size={10} color="white" />
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    ))}
                                                                </ScrollView>

                                                                <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 10, textTransform: 'uppercase' }}>AI TOOLS</Text>
                                                                <View style={{ flexDirection: 'row', gap: 10, marginBottom: 15 }}>
                                                                    <View style={{ flex: 1 }}>
                                                                        <TextInput
                                                                            style={[styles.input, { width: '100%', backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 0, height: 44, fontSize: 13 }]}
                                                                            placeholder="Ask AI..."
                                                                            placeholderTextColor={theme.secondary}
                                                                            value={customNotePrompt}
                                                                            onChangeText={setCustomNotePrompt}
                                                                            onFocus={() => setActiveNoteField('prompt')}
                                                                            onSubmitEditing={() => { if (customNotePrompt.trim()) handleAnalyzeNote('custom'); }}
                                                                        />
                                                                    </View>
                                                                    <TouchableOpacity onPress={() => handleAnalyzeNote('custom')} disabled={!customNotePrompt.trim() || isNoteAnalyzing} style={{ width: 44, height: 44, borderRadius: 12, backgroundColor: primaryColor, alignItems: 'center', justifyContent: 'center' }}>
                                                                        {isNoteAnalyzing ? <ActivityIndicator size="small" color="white" /> : <ArrowRight size={20} color="white" />}
                                                                    </TouchableOpacity>
                                                                </View>

                                                                <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8 }}>
                                                                    {/* Vision Button */}
                                                                    <TouchableOpacity
                                                                        onPress={() => {
                                                                            setImagePickerMode('note');
                                                                            setShowImageSourceModal(true);
                                                                        }}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <Camera size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontSize: 12, fontWeight: '600' }}>Vision</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Scan Images Button */}
                                                                    {currentNoteImages.length > 0 && (
                                                                        <TouchableOpacity
                                                                            onPress={() => setCustomNotePrompt("Analyze the attached documents/images and create detailed study notes from them.")}
                                                                            disabled={isNoteAnalyzing}
                                                                            style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 4, borderLeftWidth: 3, borderLeftColor: primaryColor }}
                                                                        >
                                                                            <ScanText size={14} color={primaryColor} />
                                                                            <Text style={{ color: theme.text, fontWeight: 'bold', fontSize: 12 }}>
                                                                                {currentNoteImages.some((uri: string) => isPdf(uri)) ? "Scan PDF" : "Scan Images"}
                                                                            </Text>
                                                                        </TouchableOpacity>
                                                                    )}

                                                                    {/* Quiz */}
                                                                    <TouchableOpacity
                                                                        onPress={() => handleAnalyzeNote('quiz')}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <MonitorCheck size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Quiz</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Expand */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Expand this content with more details, clarity, and context.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <Maximize2 size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Expand</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Grammar */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Fix all grammar, spelling, and punctuation errors.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <Wand2 size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Grammar</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Translate */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt(`Translate this content into ${displaySettings.language}.`)}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <Languages size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Translate</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Draft Email */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Draft a professional email based on these notes.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <Mail size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Email</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Action Items */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Identify and list all actionable items or tasks.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <CheckSquare size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Actions</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Summarize */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Summarize this content in 1-2 clear sentences.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <ScrollText size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Summarize</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Simplify */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Rewrite this content in simple, easy-to-understand language.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <Feather size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Simplify</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Format */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Reformat this text using Markdown headers and bullet points.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <Type size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Format</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Key Points */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Extract the main key points as a bulleted list.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <List size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Key Points</Text>
                                                                    </TouchableOpacity>

                                                                    {/* Critique */}
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Provide a constructive critique identifying logical gaps or tone issues.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 8, borderRadius: 10, borderWidth: 1, borderColor: theme.border, flexDirection: 'row', alignItems: 'center', gap: 4 }}
                                                                    >
                                                                        <MessageSquare size={14} color={theme.secondary} />
                                                                        <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Critique</Text>
                                                                    </TouchableOpacity>
                                                                </View>

                                                                {currentNoteSummary ? (
                                                                    <View style={{ marginTop: 20, backgroundColor: theme.highlight, padding: 12, borderRadius: 8, borderLeftWidth: 4, borderLeftColor: primaryColor }}>
                                                                        <Text style={{ fontWeight: 'bold', color: primaryColor, fontSize: 11, textTransform: 'uppercase', marginBottom: 4 }}>RESULT</Text>
                                                                        <Text style={{ color: theme.text, fontSize: 13 }}>{currentNoteSummary}</Text>
                                                                    </View>
                                                                ) : null}
                                                            </ScrollView>
                                                        </View>
                                                    </View>
                                                ) : (
                                                    // Portrait Mode (Existing)
                                                    <ScrollView
                                                        style={{ flex: 1 }}
                                                        contentContainerStyle={{ flexGrow: 1 }}
                                                        keyboardShouldPersistTaps="handled"
                                                        showsVerticalScrollIndicator={false}
                                                    >
                                                        <View style={{ marginBottom: 20 }}>
                                                            <TextInput
                                                                style={[styles.input, {
                                                                    color: theme.text,
                                                                    borderColor: theme.border,
                                                                    backgroundColor: theme.inputBg,
                                                                    fontWeight: 'bold',
                                                                    fontSize: 18,
                                                                    marginBottom: 0,
                                                                    paddingRight: 50,
                                                                    minHeight: 50,
                                                                    height: undefined
                                                                }]}
                                                                placeholder="Title"
                                                                placeholderTextColor={theme.secondary}
                                                                value={currentNoteTitle}
                                                                onChangeText={setCurrentNoteTitle}
                                                                onFocus={() => setActiveNoteField('title')}
                                                                maxLength={100}
                                                                multiline={true}
                                                            />
                                                            {renderMicButton('note_title', { position: 'absolute', right: 10, top: 11, backgroundColor: theme.uiBg })}
                                                        </View>

                                                        {currentNoteImages.length > 0 && (
                                                            <View style={{ marginBottom: 15 }}>
                                                                <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 10 }}>
                                                                    {currentNoteImages.map((uri: string, idx: number) => (
                                                                        <View key={idx} style={{ position: 'relative' }}>
                                                                            <TouchableOpacity
                                                                                onPress={() => {
                                                                                    if (!isPdf(uri)) {
                                                                                        setImagePickerMode('note');
                                                                                        openEditorForExistingImage(uri, idx);
                                                                                    }
                                                                                }}
                                                                                activeOpacity={0.9}
                                                                            >
                                                                                {isPdf(uri) ? (
                                                                                    <View style={{ width: 120, height: 120, borderRadius: 12, backgroundColor: '#fee2e2', alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: '#fecaca' }}>
                                                                                        <FileText size={32} color="#dc2626" />
                                                                                        <Text style={{ fontSize: 10, color: "#dc2626", fontWeight: 'bold', marginTop: 4 }}>PDF</Text>
                                                                                    </View>
                                                                                ) : (
                                                                                    <Image
                                                                                        source={{ uri: uri }}
                                                                                        style={{ width: 120, height: 120, borderRadius: 12, backgroundColor: theme.inputBg }}
                                                                                        resizeMode="cover"
                                                                                    />
                                                                                )}
                                                                            </TouchableOpacity>
                                                                            <TouchableOpacity
                                                                                onPress={() => {
                                                                                    const newImages = [...currentNoteImages];
                                                                                    newImages.splice(idx, 1);
                                                                                    setCurrentNoteImages(newImages);
                                                                                }}
                                                                                style={{
                                                                                    position: 'absolute', top: 5, right: 5,
                                                                                    backgroundColor: 'rgba(0,0,0,0.6)', borderRadius: 12, padding: 4
                                                                                }}
                                                                            >
                                                                                <X size={14} color="white" />
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    ))}

                                                                    <TouchableOpacity
                                                                        onPress={() => {
                                                                            setImagePickerMode('note');
                                                                            setShowImageSourceModal(true);
                                                                        }}
                                                                        style={{
                                                                            width: 120, height: 120,
                                                                            borderRadius: 12,
                                                                            backgroundColor: theme.buttonBg,
                                                                            borderWidth: 1,
                                                                            borderColor: theme.border,
                                                                            borderStyle: 'dashed',
                                                                            alignItems: 'center',
                                                                            justifyContent: 'center'
                                                                        }}
                                                                    >
                                                                        <Plus size={24} color={theme.secondary} />
                                                                        <Text style={{ marginTop: 8, fontSize: 12, fontWeight: '600', color: theme.secondary }}>Add</Text>
                                                                    </TouchableOpacity>
                                                                </ScrollView>
                                                            </View>
                                                        )}

                                                        <View style={{ flex: 1, position: 'relative', minHeight: 200 }}>
                                                            <TextInput
                                                                style={[styles.textArea, { flex: 1, color: theme.text, borderColor: theme.border, backgroundColor: theme.inputBg, fontSize: 16, textAlignVertical: 'top', marginBottom: 10, height: undefined, paddingBottom: 50 }]}
                                                                // CHANGED: Updated placeholder text to reflect new manual save behavior
                                                                placeholder={`Write your notes here...\n\nâ€¢ Press SAVE to keep changes.\nâ€¢ Closing without saving discards changes.\n\nTips:\nâ€¢ Quiz: Create a quiz to revise your notes.\nâ€¢ Expand: Expand your notes material, definition and source.\nâ€¢ Action Items: Create an action item list in your notes.`}
                                                                placeholderTextColor={theme.secondary}
                                                                value={currentNoteInput}
                                                                onChangeText={handleNoteInputChange} // UPDATED: Use wrapper for history
                                                                onFocus={() => setActiveNoteField('body')}
                                                                multiline
                                                                scrollEnabled={false} // Disable inner scrolling to let parent ScrollView handle it
                                                            />

                                                            {/* NEW: Notes Voice Input Button - Always visible for body */}
                                                            {renderMicButton('note_body', {
                                                                position: 'absolute',
                                                                bottom: 20,
                                                                right: 15,
                                                                width: 44,
                                                                height: 44,
                                                                borderRadius: 22,
                                                                backgroundColor: (isRecording && voiceTarget === 'note_body') ? '#ef4444' : theme.uiBg,
                                                            }, 20)}

                                                            {currentNoteSummary ? (
                                                                <View style={{
                                                                    backgroundColor: theme.highlight,
                                                                    padding: 12,
                                                                    borderRadius: 8,
                                                                    marginBottom: 10,
                                                                    borderLeftWidth: 4,
                                                                    borderLeftColor: primaryColor
                                                                }}>
                                                                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                                                                        <Text style={{ fontWeight: 'bold', color: primaryColor, fontSize: 12, textTransform: 'uppercase' }}>Summary</Text>
                                                                        <TouchableOpacity onPress={() => setCurrentNoteSummary("")}>
                                                                            <X size={14} color={primaryColor} />
                                                                        </TouchableOpacity>
                                                                    </View>
                                                                    <Text style={{ color: theme.text, fontSize: 14 }}>{currentNoteSummary}</Text>
                                                                </View>
                                                            ) : null}

                                                            {isNoteAnalyzing && (
                                                                <View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(255,255,255,0.5)', justifyContent: 'center', alignItems: 'center' }}>
                                                                    <ActivityIndicator color={primaryColor} />
                                                                </View>
                                                            )}
                                                        </View>
                                                    </ScrollView>
                                                )}

                                                {/* Portrait-Only Bottom Controls (Hidden in Landscape as they are moved to sidebar) */}
                                                {!isLandscape && (
                                                    <View style={{ paddingTop: 10 }}>
                                                        {/* Unified AI Input Bar (Matches Home Search Design) */}
                                                        <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 15, marginTop: 0 }]}>
                                                            <TextInput
                                                                style={[styles.searchInput, { color: theme.text, marginLeft: 10, fontSize: 14 }]}
                                                                placeholder="Ask AI about this note..."
                                                                placeholderTextColor={theme.secondary}
                                                                value={customNotePrompt}
                                                                onChangeText={setCustomNotePrompt}
                                                                multiline={true}
                                                                onFocus={() => setActiveNoteField('prompt')}
                                                                onSubmitEditing={() => { if (customNotePrompt.trim()) handleAnalyzeNote('custom'); }}
                                                            />

                                                            {/* Microphone Button */}
                                                            {renderMicButton('note_prompt', {
                                                                backgroundColor: 'transparent',
                                                                borderWidth: 0,
                                                                shadowOpacity: 0,
                                                                elevation: 0,
                                                                marginRight: 4
                                                            }, 20)}

                                                            {/* Vision Button */}
                                                            <TouchableOpacity
                                                                onPress={() => {
                                                                    setImagePickerMode('note');
                                                                    setShowImageSourceModal(true);
                                                                }}
                                                                style={{
                                                                    width: 38,
                                                                    height: 38,
                                                                    alignItems: 'center',
                                                                    justifyContent: 'center',
                                                                    marginRight: 4
                                                                }}
                                                            >
                                                                <Camera size={20} color={theme.text} />
                                                            </TouchableOpacity>

                                                            {/* Send/Submit Button */}
                                                            <TouchableOpacity
                                                                onPress={() => handleAnalyzeNote('custom')}
                                                                disabled={!customNotePrompt.trim() || isNoteAnalyzing}
                                                                style={{
                                                                    width: 38,
                                                                    height: 38,
                                                                    alignItems: 'center',
                                                                    justifyContent: 'center'
                                                                }}
                                                            >
                                                                {isNoteAnalyzing && customNotePrompt.trim() ? (
                                                                    <ActivityIndicator size="small" color={primaryColor} />
                                                                ) : (
                                                                    <ArrowRight size={20} color={customNotePrompt.trim() ? primaryColor : theme.text} />
                                                                )}
                                                            </TouchableOpacity>
                                                        </View>

                                                        <View style={{ marginBottom: 15, marginTop: 0 }}>
                                                            {/* Row 1: Editing & Formatting */}
                                                            <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 10, paddingRight: 20 }} style={{ marginBottom: 10 }}>

                                                                {/* REPLACED: Camera and FileIcon buttons with single Vision button */}
                                                                <TouchableOpacity
                                                                    onPress={() => {
                                                                        setImagePickerMode('note');
                                                                        setShowImageSourceModal(true);
                                                                    }}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <Camera size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Vision</Text>
                                                                </TouchableOpacity>

                                                                {currentNoteImages.length > 0 && (
                                                                    <TouchableOpacity
                                                                        onPress={() => setCustomNotePrompt("Analyze the attached documents/images and create detailed study notes from them.")}
                                                                        disabled={isNoteAnalyzing}
                                                                        style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6, marginRight: 5, borderLeftWidth: 3, borderLeftColor: primaryColor }}
                                                                    >
                                                                        <ScanText size={16} color={primaryColor} />
                                                                        <Text style={{ color: theme.text, fontWeight: 'bold', fontSize: 12 }}>
                                                                            {currentNoteImages.some((uri: string) => isPdf(uri)) ? "Scan PDF" : "Scan Images"}
                                                                        </Text>
                                                                    </TouchableOpacity>
                                                                )}

                                                                <TouchableOpacity
                                                                    onPress={() => handleAnalyzeNote('quiz')}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <MonitorCheck size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Quiz</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Expand this content with more details, clarity, and context.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <Maximize2 size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Expand</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Fix all grammar, spelling, and punctuation errors.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <Wand2 size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Grammar</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt(`Translate this content into ${displaySettings.language}.`)}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <Languages size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Translate</Text>
                                                                </TouchableOpacity>

                                                            </ScrollView>

                                                            {/* Row 2: Analysis & Study Tools */}
                                                            <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 10, paddingRight: 20 }}>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Draft a professional email based on these notes.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <Mail size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Draft Email</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Identify and list all actionable items or tasks.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <CheckSquare size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Action Items</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Summarize this content in 1-2 clear sentences.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <ScrollText size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Summarize</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Rewrite this content in simple, easy-to-understand language.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <Feather size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Simplify</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Reformat this text using Markdown headers and bullet points.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <Type size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Format</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Extract the main key points as a bulleted list.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <List size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Key Points</Text>
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => setCustomNotePrompt("Provide a constructive critique identifying logical gaps or tone issues.")}
                                                                    disabled={isNoteAnalyzing}
                                                                    style={{ backgroundColor: theme.buttonBg, paddingHorizontal: 12, paddingVertical: 10, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, flexDirection: 'row', gap: 6 }}
                                                                >
                                                                    <MessageSquare size={16} color={theme.secondary} />
                                                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 12 }}>Critique</Text>
                                                                </TouchableOpacity>

                                                            </ScrollView>
                                                        </View>
                                                    </View>
                                                )}
                                            </KeyboardAvoidingView>
                                        ) : (
                                            <>
                                                {isSelectionMode ? (
                                                    <View style={{
                                                        backgroundColor: primaryColor,
                                                        borderRadius: 16,
                                                        marginBottom: 15,
                                                        padding: 10,
                                                        flexDirection: 'row',
                                                        alignItems: 'center',
                                                        justifyContent: 'space-between',
                                                        shadowColor: primaryColor,
                                                        shadowOffset: { width: 0, height: 4 },
                                                        shadowOpacity: 0.3,
                                                        shadowRadius: 5,
                                                        elevation: 5
                                                    }}>
                                                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12, paddingLeft: 10, flex: 1 }}>
                                                            <TouchableOpacity onPress={() => { setIsSelectionMode(false); setSelectedNoteIds([]); }}>
                                                                <X size={20} color="white" />
                                                            </TouchableOpacity>
                                                            <View style={{ flex: 1 }}>
                                                                <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 16 }} numberOfLines={1}>
                                                                    {selectedNoteIds.length} Selected
                                                                </Text>
                                                                <TouchableOpacity onPress={handleToggleSelectAllNotes}>
                                                                    <Text style={{ color: 'rgba(255,255,255,0.8)', fontSize: 11, fontWeight: 'bold', textDecorationLine: 'underline', marginTop: 2 }}>
                                                                        {(selectedNoteIds.length === filteredNotes.length && filteredNotes.length > 0) ? "Deselect All" : "Select All"}
                                                                    </Text>
                                                                </TouchableOpacity>
                                                            </View>
                                                        </View>

                                                        <View style={{ flexDirection: 'row', gap: 8 }}>
                                                            {/* Hide Pin in Trash Mode */}
                                                            <TouchableOpacity
                                                                onPress={handleBatchPin}
                                                                style={{ padding: 8, backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 10 }}
                                                            >
                                                                <Pin size={20} color="white" fill={selectedNoteIds.every((id: string) => chatSessions[id]?.pinned) ? "white" : "transparent"} />
                                                            </TouchableOpacity>

                                                            {/* NEW: Batch Share Button (Active Mode Only) */}
                                                            <TouchableOpacity
                                                                onPress={handleNoteBatchShare}
                                                                style={{ padding: 8, backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 10 }}
                                                            >
                                                                <Share2 size={20} color="white" />
                                                            </TouchableOpacity>

                                                            {/* NEW: Batch Export Button (Active Mode Only) */}
                                                            <TouchableOpacity
                                                                onPress={handleBatchExport}
                                                                style={{ padding: 8, backgroundColor: 'rgba(255,255,255,0.2)', borderRadius: 10 }}
                                                            >
                                                                <Upload size={20} color="white" />
                                                            </TouchableOpacity>




                                                            <TouchableOpacity
                                                                onPress={handleBatchDelete}
                                                                style={{ padding: 8, backgroundColor: 'rgba(255,59,48,0.8)', borderRadius: 10 }}
                                                            >
                                                                <Trash2 size={20} color="white" />
                                                            </TouchableOpacity>
                                                        </View>
                                                    </View>
                                                ) : (
                                                    <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 15 }]}>

                                                        <TextInput
                                                            style={[styles.searchInput, { color: theme.text }]}
                                                            placeholder="Search notes..."
                                                            placeholderTextColor={theme.secondary}
                                                            value={noteSearchQuery}
                                                            onChangeText={setNoteSearchQuery}
                                                        />

                                                        <TouchableOpacity
                                                            onPress={() => handleVoiceToggle('notes_search')}
                                                            style={{
                                                                width: 38,
                                                                height: 38,
                                                                borderRadius: 19,
                                                                backgroundColor: (isRecording && voiceTarget === 'notes_search') ? '#ef4444' : theme.buttonBg,
                                                                alignItems: 'center',
                                                                justifyContent: 'center',
                                                                marginRight: 8,
                                                                borderWidth: 1,
                                                                borderColor: (isRecording || isTranscribing) && voiceTarget === 'notes_search' ? '#ef4444' : theme.border
                                                            }}
                                                        >
                                                            {isTranscribing && voiceTarget === 'notes_search' ? (
                                                                <ActivityIndicator size="small" color={theme.text} />
                                                            ) : (
                                                                <Animated.View style={{ opacity: voiceTarget === 'notes_search' ? recordingOpacity : 1 }}>
                                                                    <Mic size={18} color={(isRecording && voiceTarget === 'notes_search') ? 'white' : theme.text} />
                                                                </Animated.View>
                                                            )}
                                                        </TouchableOpacity>

                                                        {noteSearchQuery.length > 0 ? (
                                                            <TouchableOpacity onPress={() => setNoteSearchQuery("")} style={{ padding: 10 }}>
                                                                <X size={20} color={theme.secondary} />
                                                            </TouchableOpacity>
                                                        ) : (
                                                            <View style={{ padding: 10 }}>
                                                                <Search size={20} color={theme.secondary} />
                                                            </View>
                                                        )}
                                                    </View>
                                                )}

                                                <FlatList
                                                    contentContainerStyle={{ paddingBottom: 100 }}
                                                    // Use memoized filtered notes
                                                    data={filteredNotes}
                                                    onEndReachedThreshold={0.5}
                                                    ListFooterComponent={<View style={{ height: 20 }} />}
                                                    keyExtractor={(item: ChatSession) => item.id}
                                                    ListEmptyComponent={
                                                        <View style={{ alignItems: 'center', marginTop: 50 }}>
                                                            {noteSearchQuery ? (
                                                                <>
                                                                    <Search size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>No matching notes found.</Text>
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <StickyNote size={48} color={theme.secondary} style={{ opacity: 0.3 }} />
                                                                    <Text style={{ color: theme.secondary, marginTop: 10 }}>
                                                                        No notes yet.
                                                                    </Text>
                                                                </>
                                                            )}
                                                        </View>
                                                    }
                                                    renderItem={({ item: session }: { item: ChatSession }) => {
                                                        const isSelected = selectedNoteIds.includes(session.id);
                                                        return (
                                                            <TouchableOpacity
                                                                onPress={() => {
                                                                    handleNotePressInList(session);
                                                                }}
                                                                onLongPress={() => handleNoteLongPress(session.id)}
                                                                delayLongPress={300}
                                                                activeOpacity={0.8}
                                                                style={[
                                                                    styles.historyItem,
                                                                    {
                                                                        backgroundColor: isSelected ? (theme.id === 'day' ? '#eff6ff' : theme.highlight) : theme.uiBg,
                                                                        borderColor: isSelected ? primaryColor : theme.border,
                                                                        borderWidth: isSelected ? 2 : 1,
                                                                        marginBottom: 10
                                                                    }
                                                                ]}
                                                            >
                                                                <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                    <View style={{ flex: 1, flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                                                                        {isSelectionMode && (
                                                                            <View style={{
                                                                                width: 20, height: 20, borderRadius: 10,
                                                                                borderWidth: 2, borderColor: isSelected ? primaryColor : theme.secondary,
                                                                                backgroundColor: isSelected ? primaryColor : 'transparent',
                                                                                alignItems: 'center', justifyContent: 'center'
                                                                            }}>
                                                                                {isSelected && <Check size={12} color="white" />}
                                                                            </View>
                                                                        )}

                                                                        {session.pinned && (
                                                                            <Pin size={14} color={primaryColor} fill={primaryColor} style={{ transform: [{ rotate: '45deg' }] }} />
                                                                        )}

                                                                        <Text style={[styles.historyTitle, { color: theme.text, flex: 1 }]} numberOfLines={1}>{session.title || "Untitled Note"}</Text>
                                                                    </View>

                                                                    {(session.image || (session.images && session.images.length > 0)) && (
                                                                        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                                                                            {session.images && session.images.length > 1 && (
                                                                                <Text style={{ color: theme.secondary, fontSize: 10, marginRight: 2, fontWeight: 'bold' }}>{session.images.length}</Text>
                                                                            )}
                                                                            <ImageIcon size={16} color={theme.secondary} style={{ marginLeft: 2 }} />
                                                                        </View>
                                                                    )}
                                                                </View>
                                                                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5, marginLeft: (isSelectionMode ? 28 : 0) + (session.pinned && !isSelectionMode ? 0 : 0) }}>
                                                                    <Text style={{ color: theme.secondary, fontSize: 12 }}>{new Date(session.timestamp).toLocaleDateString()}</Text>
                                                                    {session.hasAudio && (
                                                                        <Volume2 size={14} color={primaryColor} style={{ marginLeft: 5 }} />
                                                                    )}

                                                                </View>
                                                            </TouchableOpacity>
                                                        );
                                                    }}
                                                />

                                                {!isSelectionMode && (
                                                    <TouchableOpacity
                                                        style={[styles.primaryBtn, { position: 'absolute', bottom: 10, left: 0, right: 0, marginHorizontal: 20, marginBottom: 0, flexDirection: 'row', gap: 10, backgroundColor: primaryColor }]}
                                                        onPress={() => {
                                                            setIsEditingNote(true);
                                                            setCurrentNoteInput("");
                                                            setCurrentNoteTitle("");
                                                            setCurrentNoteSummary("");
                                                            setCurrentNoteId(null);
                                                            setCurrentNoteImages([]);
                                                            resetHistory(""); // Reset History for new note
                                                        }}
                                                    >
                                                        <Plus size={20} color="white" />
                                                        <Text style={styles.primaryBtnText}>Create New Note</Text>
                                                    </TouchableOpacity>
                                                )}
                                            </>
                                        )}
                                    </View>
                                )}
                            </>
                        )}

                        {appMode === 'setup' && renderSetupScreen()}

                        {appMode === 'generating' && (
                            <View style={styles.centerContent}>
                                <ActivityIndicator size="large" color={primaryColor} />
                                <Text style={[styles.loadingText, { color: theme.text }]}>{generationData || "Thinking..."}</Text>
                            </View>
                        )}

                        {/* NEW: Render Mini Player logic is handled by function call below, ensuring zIndex layering */}

                        {appMode === 'reader' && readingSession && (
                            <View style={{ flex: 1, backgroundColor: theme.bg, flexDirection: isLandscape ? 'row' : 'column' }}>

                                {/* NEW: Minimized Session Restore Pill (Now Global for Reader) */}
                                {minimizedSession && (
                                    <TouchableOpacity
                                        onPress={() => {
                                            // SWAP Logic: Switch to minimized, minimize current
                                            const current = readingSession;
                                            setReadingSession(minimizedSession);
                                            setMinimizedSession(current);
                                        }}
                                        style={{
                                            position: 'absolute',
                                            bottom: 90, // Above the bottom controls
                                            right: 20,
                                            backgroundColor: theme.uiBg,
                                            paddingVertical: 10,
                                            paddingHorizontal: 16,
                                            borderRadius: 25,
                                            flexDirection: 'row',
                                            alignItems: 'center',
                                            gap: 8,
                                            shadowColor: "#000",
                                            shadowOffset: { width: 0, height: 2 },
                                            shadowOpacity: 0.2,
                                            shadowRadius: 4,
                                            elevation: 5,
                                            zIndex: 50,
                                            borderWidth: 1,
                                            borderColor: primaryColor
                                        }}
                                    >
                                        {/* Changed icon to RefreshCcw (Swap) to indicate switching */}
                                        <RefreshCcw size={16} color={primaryColor} />
                                        <View>
                                            <Text style={{ fontSize: 10, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase' }}>SWITCH TO</Text>
                                            <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 12, maxWidth: 150 }} numberOfLines={1}>
                                                {minimizedSession.title}
                                            </Text>
                                        </View>
                                        <TouchableOpacity onPress={() => setMinimizedSession(null)} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
                                            <X size={14} color={theme.secondary} style={{ marginLeft: 4 }} />
                                        </TouchableOpacity>
                                    </TouchableOpacity>
                                )}

                                {/* NEW: Landscape Optimized Reader Layout */}
                                {isLandscape && readingSession.toolId !== 'orphan_audio' ? (
                                    <>
                                        {/* LEFT: Text Content Area */}
                                        <View style={{ flex: isReaderSearchExpanded ? 2 : 1 }}>
                                            <FlatList
                                                ref={readerListRef}
                                                key={`reader-${readingSession.id}-${displaySettings.language}`} // UPDATED: Removed theme from key for instant update
                                                style={{ flex: 1 }}
                                                data={readerParagraphs}
                                                keyExtractor={(item) => item.id}
                                                contentContainerStyle={[styles.articleContent, { paddingHorizontal: 40 }]} // Wider padding for reading comfort
                                                initialNumToRender={6}
                                                maxToRenderPerBatch={5}
                                                windowSize={5}
                                                removeClippedSubviews={true}
                                                updateCellsBatchingPeriod={50}
                                                onScrollBeginDrag={() => { isUserScrolling.current = true; pendingRestoreOffset.current = null; }}
                                                onScrollEndDrag={(e) => {
                                                    if (readingSession?.id && !expandedTableData) scrollOffsets.current[readingSession.id] = e.nativeEvent.contentOffset.y;
                                                    isUserScrolling.current = false;
                                                }}
                                                onMomentumScrollBegin={() => { isUserScrolling.current = true; }}
                                                onMomentumScrollEnd={(e) => {
                                                    if (readingSession?.id && !expandedTableData) scrollOffsets.current[readingSession.id] = e.nativeEvent.contentOffset.y;
                                                    isUserScrolling.current = false;
                                                }}
                                                onScroll={(e) => {
                                                    if (isUserScrolling.current && !expandedTableData && readingSession?.id) scrollOffsets.current[readingSession.id] = e.nativeEvent.contentOffset.y;
                                                }}
                                                renderItem={renderReaderItem}
                                                extraData={[readingSession?.highlights, displaySettings.tapToDefine, displaySettings.theme, displaySettings.fontSize, displaySettings.fontFamily, displaySettings.textStyles]}
                                                ListHeaderComponent={/* Same header component code as before but simpler since we have side panel */
                                                    <View>
                                                        {readingSession.image ? (
                                                            <TouchableOpacity onPress={() => setFullScreenImage(readingSession.image)} activeOpacity={0.9}>
                                                                <Image source={{ uri: readingSession.image }} style={[styles.coverImage, { backgroundColor: theme.inputBg, height: undefined, aspectRatio: coverAspectRatio, width: '100%' }]} resizeMode="cover" />
                                                            </TouchableOpacity>
                                                        ) : null}
                                                        <Text style={[styles.articleTitle, { color: theme.text, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }]}>{readingSession.title}</Text>
                                                    </View>
                                                }
                                                ListFooterComponent={
                                                    <View style={{ marginBottom: readingSession.toolId === 'orphan_audio' ? 0 : 50 }}>
                                                        {!(ttsStatus === 'playing' && playingMeta?.id === readingSession?.id) && readingSession.toolId !== 'orphan_audio' && (
                                                            <Text style={{ textAlign: 'center', marginTop: 20, marginBottom: 20, color: theme.secondary, fontStyle: 'italic', ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>(Tap any word to define)</Text>
                                                        )}

                                                        {((ttsStatus === 'playing' && playingMeta?.id === readingSession?.id) || readingSession.toolId === 'orphan_audio') ? (
                                                            <View style={{ marginBottom: 20 }}>
                                                                <LinearGradient
                                                                    colors={['#4f46e5', '#9333ea']}
                                                                    start={{ x: 0, y: 0 }}
                                                                    end={{ x: 1, y: 1 }}
                                                                    style={[styles.adContainer, {
                                                                        borderColor: theme.border,
                                                                        marginBottom: 0,
                                                                        borderBottomLeftRadius: 0,
                                                                        borderBottomRightRadius: 0,
                                                                        borderBottomWidth: 0,
                                                                        justifyContent: 'center',
                                                                        alignItems: 'center'
                                                                    }]}
                                                                >
                                                                    <Heart size={120} color="white" style={{ position: 'absolute', right: -20, top: -20, opacity: 0.1 }} />
                                                                    <Star
                                                                        size={60}
                                                                        color="white"
                                                                        style={{ position: 'absolute', left: -20, bottom: -20, opacity: 0.1 }}
                                                                    />

                                                                    <View style={{ alignItems: 'center', zIndex: 1 }}>
                                                                        <View style={{
                                                                            flexDirection: 'row',
                                                                            alignItems: 'center',
                                                                            marginBottom: 8,
                                                                            backgroundColor: 'rgba(0,0,0,0.3)', // Darker glass for contrast
                                                                            borderWidth: 1,
                                                                            borderColor: '#FFD700', // Gold Border
                                                                            paddingHorizontal: 12,
                                                                            paddingVertical: 4,
                                                                            borderRadius: 20,
                                                                            shadowColor: '#FFD700',
                                                                            shadowOffset: { width: 0, height: 0 },
                                                                            shadowOpacity: 0.5,
                                                                            shadowRadius: 10,
                                                                            elevation: 5 // Android Glow
                                                                        }}>
                                                                            <Trophy size={14} color="#FFD700" fill="#FFD700" style={{ marginRight: 6 }} />
                                                                            <Text style={{ color: '#FFD700', fontWeight: 'bold', fontSize: 12, textTransform: 'uppercase', letterSpacing: 1.5 }}>ELITE</Text>
                                                                        </View>
                                                                        <Text style={styles.adTitle}>ReaderApp</Text>
                                                                        <Text style={styles.adSubtitle}>Built with â¤ï¸ by Mukesh Yadav</Text>
                                                                    </View>
                                                                </LinearGradient>

                                                                <View style={{
                                                                    backgroundColor: theme.uiBg,
                                                                    padding: 20,
                                                                    borderBottomLeftRadius: 16,
                                                                    borderBottomRightRadius: 16,
                                                                    borderWidth: 1,
                                                                    borderColor: theme.border,
                                                                    borderTopWidth: 0
                                                                }}>
                                                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
                                                                        <Sparkles size={18} color="#eab308" style={{ marginRight: 8 }} fill="#eab308" />
                                                                        <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Supercharge Your Learning</Text>
                                                                    </View>

                                                                    <Text style={{ fontSize: 14, color: theme.secondary, lineHeight: 24, marginBottom: 20 }}>
                                                                        â€¢ Generate unlimited stories & articles{'\n'}
                                                                        â€¢ Learn languages with instant translation{'\n'}
                                                                        â€¢ Master subjects with AI quizzes{'\n'}
                                                                        â€¢ Listen on the go with Offline Audio
                                                                    </Text>

                                                                    <TouchableOpacity
                                                                        onPress={() => Linking.openURL('https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp')}
                                                                        style={{
                                                                            backgroundColor: primaryColor,
                                                                            paddingVertical: 12,
                                                                            borderRadius: 12,
                                                                            alignItems: 'center',
                                                                            flexDirection: 'row',
                                                                            justifyContent: 'center',
                                                                            gap: 8,
                                                                            shadowColor: primaryColor,
                                                                            shadowOffset: { width: 0, height: 4 },
                                                                            shadowOpacity: 0.2,
                                                                            shadowRadius: 4,
                                                                            elevation: 3
                                                                        }}
                                                                    >
                                                                        <Star size={16} color="white" fill="white" />
                                                                        <Text style={{ color: 'white', fontWeight: 'bold' }}>Rate Us 5 Stars</Text>
                                                                    </TouchableOpacity>
                                                                </View>
                                                            </View>
                                                        ) : (
                                                            <View style={{ flexDirection: 'row', gap: 10 }}>
                                                                {/* CHANGED: Hide Take Quiz for specific functional tools AND Story Generator AND Orphan Audio */}
                                                                {!['help_guide', 'greetings_gen', 'health_guide', 'study_planner', 'story_generator', 'orphan_audio'].includes(readingSession.toolId) && (
                                                                    <TouchableOpacity
                                                                        style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: theme.highlight, borderWidth: 1, borderColor: theme.border }]}
                                                                        onPress={() => handleStartQuiz(readingSession.messages[0].content, false, "General", true, readingSession.images)}
                                                                    >
                                                                        <MonitorCheck size={20} color={theme.text} />
                                                                        <Text style={[styles.primaryBtnText, { color: theme.text }]}>Take Quiz</Text>
                                                                    </TouchableOpacity>
                                                                )}

                                                                {/* NEW: Flashcards Button for Reader content */}
                                                                {!['help_guide', 'greetings_gen', 'health_guide', 'study_planner', 'story_generator', 'orphan_audio'].includes(readingSession.toolId) && (
                                                                    <TouchableOpacity
                                                                        style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: theme.highlight, borderWidth: 1, borderColor: theme.border }]}
                                                                        onPress={() => handleStartQuiz(readingSession.messages[0].content, false, "General", true, readingSession.images, null, true)}
                                                                    >
                                                                        <Copy size={20} color={theme.text} />
                                                                        <Text style={[styles.primaryBtnText, { color: theme.text }]}>Flashcards</Text>
                                                                    </TouchableOpacity>
                                                                )}

                                                                {readingSession.toolId === 'story_generator' && (
                                                                    <View style={{ width: '100%', gap: 15 }}>
                                                                        {/* NEW: Input for Next Chapter Guidance */}
                                                                        {!readingSession.nextChapterId && (
                                                                            <View>
                                                                                <Text style={{ color: theme.secondary, fontSize: 11, fontWeight: 'bold', marginBottom: 8, textTransform: 'uppercase' }}>What happens next?</Text>
                                                                                <View>
                                                                                    <TextInput
                                                                                        style={[styles.input, {
                                                                                            backgroundColor: theme.inputBg,
                                                                                            color: theme.text,
                                                                                            borderColor: theme.border,
                                                                                            marginBottom: 0,
                                                                                            paddingRight: 90, // Increased padding for 2 buttons
                                                                                            minHeight: 50,
                                                                                            height: undefined,
                                                                                            maxHeight: 150
                                                                                        }]}
                                                                                        placeholder="Guide the story (optional)..."
                                                                                        placeholderTextColor={theme.secondary}
                                                                                        value={nextChapterInput}
                                                                                        onChangeText={setNextChapterInput}
                                                                                        onFocus={() => setShowStoryAd(true)} // NEW: Show ad on focus
                                                                                        multiline={true}
                                                                                    />

                                                                                    {/* NEW: Vision Button for Story Next */}
                                                                                    <TouchableOpacity
                                                                                        onPress={() => {
                                                                                            setImagePickerMode('story_next');
                                                                                            setVisionDraft({ uris: [], prompt: "Describe the events in this image to continue the story." });
                                                                                            setShowImageSourceModal(true);
                                                                                        }}
                                                                                        style={{
                                                                                            position: 'absolute',
                                                                                            right: 50,
                                                                                            top: 6,
                                                                                            width: 38,
                                                                                            height: 38,
                                                                                            borderRadius: 19,
                                                                                            backgroundColor: theme.uiBg,
                                                                                            alignItems: 'center',
                                                                                            justifyContent: 'center',
                                                                                            borderWidth: 1,
                                                                                            borderColor: theme.border
                                                                                        }}
                                                                                    >
                                                                                        <Camera size={18} color={theme.text} />
                                                                                    </TouchableOpacity>

                                                                                    {renderMicButton('story_next', { position: 'absolute', right: 6, top: 6, width: 38, height: 38, backgroundColor: theme.uiBg })}
                                                                                </View>
                                                                            </View>
                                                                        )}

                                                                        {/* NEW: Advertisement Block triggers on input focus */}
                                                                        {showStoryAd && !readingSession.nextChapterId && (
                                                                            <View style={{ marginBottom: 5 }}>
                                                                                <LinearGradient
                                                                                    colors={['#4f46e5', '#9333ea']}
                                                                                    start={{ x: 0, y: 0 }}
                                                                                    end={{ x: 1, y: 1 }}
                                                                                    style={[styles.adContainer, {
                                                                                        borderColor: theme.border,
                                                                                        marginBottom: 0,
                                                                                        borderBottomLeftRadius: 0,
                                                                                        borderBottomRightRadius: 0,
                                                                                        borderBottomWidth: 0,
                                                                                        justifyContent: 'center',
                                                                                        alignItems: 'center'
                                                                                    }]}
                                                                                >
                                                                                    <Heart size={120} color="white" style={{ position: 'absolute', right: -20, top: -20, opacity: 0.1 }} />
                                                                                    <View style={{ alignItems: 'center', zIndex: 1 }}>
                                                                                        <Text style={[styles.adTitle, { fontSize: 18 }]}>Enjoying the App?</Text>
                                                                                        <Text style={{ color: 'rgba(255,255,255,0.9)', fontSize: 13, marginTop: 4 }}>Drowning in 5-Star Reviews!</Text>
                                                                                    </View>
                                                                                </LinearGradient>

                                                                                <View style={{
                                                                                    backgroundColor: theme.uiBg,
                                                                                    padding: 20,
                                                                                    borderBottomLeftRadius: 16,
                                                                                    borderBottomRightRadius: 16,
                                                                                    borderWidth: 1,
                                                                                    borderColor: theme.border,
                                                                                    borderTopWidth: 0
                                                                                }}>
                                                                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
                                                                                        <Sparkles size={18} color="#eab308" style={{ marginRight: 8 }} fill="#eab308" />
                                                                                        <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Supercharge Your Learning</Text>
                                                                                    </View>

                                                                                    <Text style={{ fontSize: 14, color: theme.secondary, lineHeight: 24, marginBottom: 20 }}>
                                                                                        â€¢ Generate unlimited stories & articles{'\n'}
                                                                                        â€¢ Learn languages with instant translation{'\n'}
                                                                                        â€¢ Master subjects with AI quizzes{'\n'}
                                                                                        â€¢ Listen on the go with Offline Audio
                                                                                    </Text>

                                                                                    <TouchableOpacity
                                                                                        onPress={() => Linking.openURL('https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp')}
                                                                                        style={{
                                                                                            backgroundColor: primaryColor,
                                                                                            paddingVertical: 12,
                                                                                            borderRadius: 12,
                                                                                            alignItems: 'center',
                                                                                            flexDirection: 'row',
                                                                                            justifyContent: 'center',
                                                                                            gap: 8,
                                                                                            shadowColor: primaryColor,
                                                                                            shadowOffset: { width: 0, height: 4 },
                                                                                            shadowOpacity: 0.2,
                                                                                            shadowRadius: 4,
                                                                                            elevation: 3
                                                                                        }}
                                                                                    >
                                                                                        <Star size={16} color="white" fill="white" />
                                                                                        <Text style={{ color: 'white', fontWeight: 'bold' }}>Rate Us 5 Stars</Text>
                                                                                    </TouchableOpacity>
                                                                                </View>
                                                                            </View>
                                                                        )}

                                                                        <View style={{ flexDirection: 'row', gap: 10 }}>
                                                                            {readingSession.previousChapterId && chatSessions[readingSession.previousChapterId] && (
                                                                                <TouchableOpacity
                                                                                    style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: theme.buttonBg, borderWidth: 1, borderColor: theme.border }]}
                                                                                    onPress={handlePreviousChapter}
                                                                                >
                                                                                    <ArrowLeft size={20} color={theme.text} />
                                                                                    <Text style={[styles.primaryBtnText, { color: theme.text }]}>Previous</Text>
                                                                                </TouchableOpacity>
                                                                            )}
                                                                            <TouchableOpacity
                                                                                style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: primaryColor }]}
                                                                                onPress={() => {
                                                                                    if (readingSession.nextChapterId && chatSessions[readingSession.nextChapterId]) {
                                                                                        const nextSession = chatSessions[readingSession.nextChapterId];
                                                                                        loadHistorySession(nextSession, 'reader');
                                                                                    } else {
                                                                                        handleNextChapter();
                                                                                    }
                                                                                }}
                                                                            >
                                                                                <BookOpenText size={20} color="white" />
                                                                                <Text style={styles.primaryBtnText}>
                                                                                    {readingSession.nextChapterId ? "Open Next" : "Next Chapter"}
                                                                                </Text>
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    </View>
                                                                )}
                                                            </View>
                                                        )}
                                                    </View>
                                                }
                                            />

                                            {/* NEW: Floating Controls when Sidebar is Hidden */}
                                            {!isReaderSearchExpanded && (
                                                <View style={{ position: 'absolute', top: 20, right: 20, flexDirection: 'row', gap: 12 }}>
                                                    <TouchableOpacity
                                                        onPress={() => setIsReaderSearchExpanded(true)}
                                                        style={{
                                                            backgroundColor: theme.buttonBg,
                                                            padding: 12,
                                                            borderRadius: 24,
                                                            borderWidth: 1,
                                                            borderColor: theme.border,
                                                            shadowColor: "#000",
                                                            shadowOffset: { width: 0, height: 2 },
                                                            shadowOpacity: 0.1,
                                                            shadowRadius: 4,
                                                            elevation: 3
                                                        }}
                                                    >
                                                        <LayoutGrid size={24} color={theme.text} />
                                                    </TouchableOpacity>
                                                </View>
                                            )}
                                        </View>

                                        {/* RIGHT: Sidebar for Controls & Chat */}
                                        {isReaderSearchExpanded && (
                                            <View style={{ flex: 1, borderLeftWidth: 1, borderLeftColor: theme.border, backgroundColor: theme.uiBg }}>
                                                {/* Consistent Search/Control Logic (Same as Portrait) */}
                                                {readingSession.toolId !== 'orphan_audio' && (
                                                    <View style={{ paddingHorizontal: 20, paddingTop: 15, paddingBottom: 5, backgroundColor: theme.uiBg, zIndex: 10 }}>
                                                        {/* NEW: Highlight Color Palette (Visible when Highlight Mode is ON) */}
                                                        {isHighlightMode && (
                                                            <View style={{ marginBottom: 15 }}>
                                                                <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 12, paddingRight: 20, alignItems: 'center' }}>
                                                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginRight: 5 }}>
                                                                        <Highlighter size={16} color={primaryColor} style={{ marginRight: 6 }} />
                                                                        <Text style={{ fontSize: 12, fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase' }}>Color</Text>
                                                                    </View>
                                                                    {Object.entries(HIGHLIGHT_COLORS).map(([key, value]: [string, any]) => {
                                                                        const isSelected = activeHighlightColor === key;
                                                                        return (
                                                                            <TouchableOpacity
                                                                                key={key}
                                                                                onPress={() => setActiveHighlightColor(key)}
                                                                                style={{
                                                                                    width: 32,
                                                                                    height: 32,
                                                                                    borderRadius: 16,
                                                                                    backgroundColor: value.code,
                                                                                    borderWidth: isSelected ? 3 : 1,
                                                                                    borderColor: isSelected ? theme.text : 'rgba(0,0,0,0.1)',
                                                                                    alignItems: 'center',
                                                                                    justifyContent: 'center',
                                                                                    shadowColor: "#000",
                                                                                    shadowOffset: { width: 0, height: 1 },
                                                                                    shadowOpacity: 0.1,
                                                                                    shadowRadius: 2,
                                                                                    elevation: 2
                                                                                }}
                                                                            >
                                                                                {isSelected && <Check size={16} color={key === 'yellow' || key === 'green' || key === 'pink' || key === 'blue' || key === 'orange' ? '#000' : '#fff'} strokeWidth={3} />}
                                                                            </TouchableOpacity>
                                                                        );
                                                                    })}
                                                                </ScrollView>
                                                            </View>
                                                        )}

                                                        <View style={{ flexDirection: 'row', alignItems: 'flex-start', gap: 10 }}>
                                                            <View style={{ flex: 1 }}>
                                                                <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 0 }]}>
                                                                    <TextInput
                                                                        style={[styles.searchInput, { color: theme.text, marginLeft: 10 }]}
                                                                        placeholder={
                                                                            readingSession.toolId !== 'orphan_audio'
                                                                                ? "Ask anything..."
                                                                                : "Ask follow-up..."
                                                                        }
                                                                        placeholderTextColor={theme.secondary}
                                                                        value={quickSearchQuery}
                                                                        onChangeText={setQuickSearchQuery}
                                                                        onSubmitEditing={() => handleQuickSearch()}
                                                                        multiline={true}
                                                                    />

                                                                    <TouchableOpacity
                                                                        onPress={() => handleVoiceToggle('search')}
                                                                        style={{
                                                                            width: 38,
                                                                            height: 38,
                                                                            alignItems: 'center',
                                                                            justifyContent: 'center',
                                                                            marginRight: 4
                                                                        }}
                                                                    >
                                                                        {isTranscribing && voiceTarget === 'search' ? (
                                                                            <ActivityIndicator size="small" color={theme.text} />
                                                                        ) : (
                                                                            <Animated.View style={{ opacity: voiceTarget === 'search' ? recordingOpacity : 1 }}>
                                                                                <Mic size={20} color={(isRecording && voiceTarget === 'search') ? primaryColor : theme.text} />
                                                                            </Animated.View>
                                                                        )}
                                                                    </TouchableOpacity>

                                                                    <TouchableOpacity
                                                                        onPress={() => { setImagePickerMode('vision'); setVisionDraft({ uris: [], prompt: quickSearchQuery }); setShowImageSourceModal(true); }}
                                                                        style={{
                                                                            width: 38,
                                                                            height: 38,
                                                                            alignItems: 'center',
                                                                            justifyContent: 'center',
                                                                            marginRight: 4
                                                                        }}
                                                                    >
                                                                        <Camera size={20} color={theme.text} />
                                                                    </TouchableOpacity>

                                                                    <TouchableOpacity disabled={isReaderQuerying} onPress={() => handleQuickSearch()} style={{
                                                                        width: 38,
                                                                        height: 38,
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center'
                                                                    }}>
                                                                        {isReaderQuerying ? (
                                                                            <ActivityIndicator size="small" color={primaryColor} />
                                                                        ) : (
                                                                            quickSearchQuery.trim().length > 0 ? (
                                                                                <ArrowRight size={20} color={primaryColor} />
                                                                            ) : (
                                                                                <Search size={20} color={theme.text} />
                                                                            )
                                                                        )}
                                                                    </TouchableOpacity>
                                                                </View>

                                                                {/* Library Suggestions Dropdown */}
                                                                {quickSearchQuery.trim().length > 0 && librarySuggestions.length > 0 && (
                                                                    <View style={{
                                                                        position: 'absolute',
                                                                        top: 55, // Adjusted to be below the search bar within this flex container
                                                                        left: 0,
                                                                        right: 0,
                                                                        backgroundColor: theme.uiBg,
                                                                        borderRadius: 12,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border,
                                                                        zIndex: 100,
                                                                        shadowColor: "#000",
                                                                        shadowOffset: { width: 0, height: 4 },
                                                                        shadowOpacity: 0.1,
                                                                        shadowRadius: 5,
                                                                        elevation: 5
                                                                    }}>
                                                                        {librarySuggestions.map((session: any, idx: number) => (
                                                                            <TouchableOpacity
                                                                                key={idx}
                                                                                onPress={() => {
                                                                                    setQuickSearchQuery("");
                                                                                    Keyboard.dismiss();
                                                                                    // DIRECT OPEN from suggestions (Skip modal)
                                                                                    if (readingSession) {
                                                                                        setMinimizedSession(readingSession);
                                                                                    }
                                                                                    loadHistorySession(session, 'reader');
                                                                                }}
                                                                                style={{
                                                                                    padding: 15,
                                                                                    borderBottomWidth: idx === librarySuggestions.length - 1 ? 0 : 1,
                                                                                    borderBottomColor: theme.border,
                                                                                    flexDirection: 'row',
                                                                                    alignItems: 'center'
                                                                                }}
                                                                            >
                                                                                <BookOpen size={14} color={theme.secondary} style={{ marginRight: 10 }} />
                                                                                <Text style={{ color: theme.text, fontSize: 16 }} numberOfLines={1}>{session.title}</Text>
                                                                            </TouchableOpacity>
                                                                        ))}
                                                                    </View>
                                                                )}
                                                            </View>

                                                            {/* Minimize Button */}
                                                            <TouchableOpacity
                                                                onPress={() => setIsReaderSearchExpanded(false)}
                                                                style={{
                                                                    width: 40,
                                                                    height: 50, // Match search bar height
                                                                    alignItems: 'center',
                                                                    justifyContent: 'center',
                                                                    backgroundColor: theme.buttonBg,
                                                                    borderRadius: 12,
                                                                    borderWidth: 1,
                                                                    borderColor: theme.border
                                                                }}
                                                            >
                                                                <ChevronUp size={20} color={theme.secondary} />
                                                            </TouchableOpacity>
                                                        </View>
                                                    </View>
                                                )}
                                            </View>
                                        )}

                                        {/* Onboarding Preview Footer - LANDSCAPE MODE */}
                                        {isInOnboardingPreview && (
                                            <OnboardingPreviewFooter
                                                theme={theme}
                                                apiKey={customApiKey}
                                                setApiKey={setCustomApiKey}
                                                testConnection={handleTestConnection}
                                                connectionStatus={apiConnectionStatus}
                                                isLandscape={isLandscape}
                                                onSkip={async () => {
                                                    await saveSettings({ isOnboarded: true });
                                                    setIsInOnboardingPreview(false);
                                                    setAppMode("idle");
                                                }}
                                                onFinish={async () => {
                                                    if (apiConnectionStatus !== 'success') {
                                                        Alert.alert("API Key Required", "Please test your connection first, or skip for now.");
                                                        return;
                                                    }
                                                    await saveSettings({ isOnboarded: true });
                                                    setIsInOnboardingPreview(false);
                                                    setAppMode("idle");
                                                    Alert.alert("Success", "Welcome to Reader App! Your profile and AI are ready.");
                                                }}
                                            />
                                        )}
                                    </>
                                ) : (
                                    // Standard Portrait Layout (or Orphan Audio) - Existing Code wrapped
                                    <KeyboardAvoidingView
                                        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                                        style={{ flex: 1 }}
                                        keyboardVerticalOffset={Platform.OS === 'ios' ? 80 : 0} // Account for header/status bar
                                    >
                                        {/* Only show search/controls header if NOT orphan audio */}
                                        {readingSession.toolId !== 'orphan_audio' && (
                                            <View style={{ paddingHorizontal: 20, paddingTop: isReaderSearchExpanded ? 15 : 10, paddingBottom: isReaderSearchExpanded ? 5 : 10, backgroundColor: theme.bg, zIndex: 10, borderBottomWidth: 1, borderBottomColor: theme.border }}>
                                                {/* NEW: Highlight Color Palette (Visible when Highlight Mode is ON) */}
                                                {isHighlightMode && (
                                                    <View style={{ marginBottom: 15 }}>
                                                        <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 12, paddingRight: 20, alignItems: 'center' }}>
                                                            <View style={{ flexDirection: 'row', alignItems: 'center', marginRight: 5 }}>
                                                                <Highlighter size={16} color={primaryColor} style={{ marginRight: 6 }} />
                                                                <Text style={{ fontSize: 12, fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase' }}>Color</Text>
                                                            </View>
                                                            {Object.entries(HIGHLIGHT_COLORS).map(([key, value]: [string, any]) => {
                                                                const isSelected = activeHighlightColor === key;
                                                                return (
                                                                    <TouchableOpacity
                                                                        key={key}
                                                                        onPress={() => setActiveHighlightColor(key)}
                                                                        style={{
                                                                            width: 32,
                                                                            height: 32,
                                                                            borderRadius: 16,
                                                                            backgroundColor: value.code,
                                                                            borderWidth: isSelected ? 3 : 1,
                                                                            borderColor: isSelected ? theme.text : 'rgba(0,0,0,0.1)',
                                                                            alignItems: 'center',
                                                                            justifyContent: 'center',
                                                                            shadowColor: "#000",
                                                                            shadowOffset: { width: 0, height: 1 },
                                                                            shadowOpacity: 0.1,
                                                                            shadowRadius: 2,
                                                                            elevation: 2
                                                                        }}
                                                                    >
                                                                        {isSelected && <Check size={16} color={key === 'yellow' || key === 'green' || key === 'pink' || key === 'blue' || key === 'orange' ? '#000' : '#fff'} strokeWidth={3} />}
                                                                    </TouchableOpacity>
                                                                );
                                                            })}
                                                        </ScrollView>
                                                    </View>
                                                )}

                                                {isReaderSearchExpanded ? (
                                                    <View style={{ flexDirection: 'row', alignItems: 'flex-start', gap: 10 }}>
                                                        <View style={{ flex: 1 }}>
                                                            <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 0 }]}>
                                                                {/* UNIFIED SEARCH: Toggle Button Removed. Logic defaults to AI, but shows suggestions for Library. */}

                                                                <TextInput
                                                                    style={[styles.searchInput, { color: theme.text, marginLeft: 10 }]} // Added marginLeft
                                                                    // UPDATED: Unified Placeholder
                                                                    placeholder={
                                                                        readingSession.toolId !== 'orphan_audio'
                                                                            ? "Ask anything..."
                                                                            : "Ask follow-up..." //chage placeholder text ask anything and ask folloup due to space problem.
                                                                    }
                                                                    placeholderTextColor={theme.secondary}
                                                                    value={quickSearchQuery}
                                                                    onChangeText={setQuickSearchQuery}
                                                                    onSubmitEditing={() => handleQuickSearch()}
                                                                    multiline={true}
                                                                />

                                                                <TouchableOpacity
                                                                    onPress={() => handleVoiceToggle('search')}
                                                                    style={{
                                                                        width: 38,
                                                                        height: 38,
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        marginRight: 4
                                                                    }}
                                                                >
                                                                    {isTranscribing && voiceTarget === 'search' ? (
                                                                        <ActivityIndicator size="small" color={theme.text} />
                                                                    ) : (
                                                                        <Animated.View style={{ opacity: voiceTarget === 'search' ? recordingOpacity : 1 }}>
                                                                            <Mic size={20} color={(isRecording && voiceTarget === 'search') ? primaryColor : theme.text} />
                                                                        </Animated.View>
                                                                    )}
                                                                </TouchableOpacity>

                                                                <TouchableOpacity
                                                                    onPress={() => { setImagePickerMode('vision'); setVisionDraft({ uris: [], prompt: quickSearchQuery }); setShowImageSourceModal(true); }}
                                                                    style={{
                                                                        width: 38,
                                                                        height: 38,
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        marginRight: 4
                                                                    }}
                                                                >
                                                                    <Camera size={20} color={theme.text} />
                                                                </TouchableOpacity>

                                                                <TouchableOpacity disabled={isReaderQuerying} onPress={() => handleQuickSearch()} style={{
                                                                    width: 38,
                                                                    height: 38,
                                                                    alignItems: 'center',
                                                                    justifyContent: 'center'
                                                                }}>
                                                                    {/* UPDATED: Show spinner during Reader Query */}
                                                                    {isReaderQuerying ? (
                                                                        <ActivityIndicator size="small" color={primaryColor} />
                                                                    ) : (
                                                                        quickSearchQuery.trim().length > 0 ? (
                                                                            <ArrowRight size={20} color={primaryColor} />
                                                                        ) : (
                                                                            <Search size={20} color={theme.text} />
                                                                        )
                                                                    )}
                                                                </TouchableOpacity>
                                                            </View>

                                                            {/* NEW: Library Suggestions Dropdown */}
                                                            {quickSearchQuery.trim().length > 0 && librarySuggestions.length > 0 && (
                                                                <View style={{
                                                                    position: 'absolute',
                                                                    top: 55, // Adjusted to be below the search bar within this flex container
                                                                    left: 0,
                                                                    right: 0,
                                                                    backgroundColor: theme.uiBg,
                                                                    borderRadius: 12,
                                                                    borderWidth: 1,
                                                                    borderColor: theme.border,
                                                                    zIndex: 100,
                                                                    shadowColor: "#000",
                                                                    shadowOffset: { width: 0, height: 4 },
                                                                    shadowOpacity: 0.1,
                                                                    shadowRadius: 5,
                                                                    elevation: 5
                                                                }}>
                                                                    {librarySuggestions.map((session: any, idx: number) => (
                                                                        <TouchableOpacity
                                                                            key={idx}
                                                                            onPress={() => {
                                                                                setQuickSearchQuery("");
                                                                                Keyboard.dismiss();
                                                                                // DIRECT OPEN from suggestions (Skip modal)
                                                                                if (readingSession) {
                                                                                    setMinimizedSession(readingSession);
                                                                                }
                                                                                loadHistorySession(session, 'reader');
                                                                            }}
                                                                            style={{
                                                                                padding: 15,
                                                                                borderBottomWidth: idx === librarySuggestions.length - 1 ? 0 : 1,
                                                                                borderBottomColor: theme.border,
                                                                                flexDirection: 'row',
                                                                                alignItems: 'center'
                                                                            }}
                                                                        >
                                                                            <BookOpen size={14} color={theme.secondary} style={{ marginRight: 10 }} />
                                                                            <Text style={{ color: theme.text, fontSize: 16 }} numberOfLines={1}>{session.title}</Text>
                                                                        </TouchableOpacity>
                                                                    ))}
                                                                </View>
                                                            )}
                                                        </View>

                                                        {/* Minimize Button */}
                                                        <TouchableOpacity
                                                            onPress={() => setIsReaderSearchExpanded(false)}
                                                            style={{
                                                                width: 40,
                                                                height: 50, // Match search bar height
                                                                alignItems: 'center',
                                                                justifyContent: 'center',
                                                                backgroundColor: theme.buttonBg,
                                                                borderRadius: 12,
                                                                borderWidth: 1,
                                                                borderColor: theme.border
                                                            }}
                                                        >
                                                            <ChevronUp size={20} color={theme.secondary} />
                                                        </TouchableOpacity>
                                                    </View>
                                                ) : (
                                                    /* Compact View when Minimized */
                                                    <TouchableOpacity
                                                        onPress={() => setIsReaderSearchExpanded(true)}
                                                        style={{
                                                            flexDirection: 'row',
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            paddingVertical: 8,
                                                            backgroundColor: theme.buttonBg,
                                                            borderRadius: 12
                                                        }}
                                                    >
                                                        <Search size={14} color={theme.secondary} style={{ marginRight: 6 }} />
                                                        <Text style={{ color: theme.secondary, fontWeight: '600', fontSize: 12 }}>Search / Ask AI</Text>
                                                        <ChevronDown size={14} color={theme.secondary} style={{ marginLeft: 6 }} />
                                                    </TouchableOpacity>
                                                )}
                                            </View>
                                        )}

                                        {/* For Orphan Audio, provide a simple absolute close button since header is hidden */}
                                        {readingSession.toolId === 'orphan_audio' && (
                                            <View style={{
                                                height: 50,
                                                flexDirection: 'row',
                                                alignItems: 'center',
                                                paddingHorizontal: 16,
                                                borderBottomWidth: 1,
                                                borderBottomColor: theme.border,
                                                backgroundColor: theme.bg,
                                                gap: 15
                                            }}>
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        // Handle Close
                                                        if (minimizedSession) {
                                                            setReadingSession(minimizedSession);
                                                            setMinimizedSession(null);
                                                            return;
                                                        }
                                                        if (navOrigin === 'setup') {
                                                            setAppMode("setup");
                                                        } else {
                                                            setAppMode("idle");
                                                        }
                                                    }}
                                                >
                                                    <ArrowLeft size={24} color={theme.text} />
                                                </TouchableOpacity>

                                                <Text style={{ fontSize: 18, fontWeight: 'bold', color: theme.text, flex: 1 }} numberOfLines={1}>
                                                    {readingSession.title || "Audio Recording"}
                                                </Text>
                                            </View>
                                        )}

                                        {/* NEW: Minimized Session Restore Pill (Portrait) */}
                                        {minimizedSession && (
                                            <TouchableOpacity
                                                onPress={() => {
                                                    // SWAP Logic: Switch to minimized, minimize current
                                                    const current = readingSession;
                                                    setReadingSession(minimizedSession);
                                                    setMinimizedSession(current);
                                                }}
                                                style={{
                                                    position: 'absolute',
                                                    bottom: 90, // Above the bottom controls
                                                    right: 20,
                                                    backgroundColor: theme.uiBg,
                                                    paddingVertical: 10,
                                                    paddingHorizontal: 16,
                                                    borderRadius: 25,
                                                    flexDirection: 'row',
                                                    alignItems: 'center',
                                                    gap: 8,
                                                    shadowColor: "#000",
                                                    shadowOffset: { width: 0, height: 2 },
                                                    shadowOpacity: 0.2,
                                                    shadowRadius: 4,
                                                    elevation: 5,
                                                    zIndex: 50,
                                                    borderWidth: 1,
                                                    borderColor: primaryColor
                                                }}
                                            >
                                                {/* Changed icon to RefreshCcw (Swap) to indicate switching */}
                                                <RefreshCcw size={16} color={primaryColor} />
                                                <View>
                                                    <Text style={{ fontSize: 10, color: theme.secondary, fontWeight: 'bold', textTransform: 'uppercase' }}>SWITCH TO</Text>
                                                    <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 12, maxWidth: 150 }} numberOfLines={1}>
                                                        {minimizedSession.title}
                                                    </Text>
                                                </View>
                                                <TouchableOpacity onPress={() => setMinimizedSession(null)} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
                                                    <X size={14} color={theme.secondary} style={{ marginLeft: 4 }} />
                                                </TouchableOpacity>
                                            </TouchableOpacity>
                                        )}

                                        <FlatList
                                            ref={readerListRef}
                                            key={`reader-${readingSession.id}-${displaySettings.language}`} // UPDATED: Removed theme from key for instant update
                                            style={{ flex: 1 }}
                                            data={readerParagraphs}
                                            keyExtractor={(item: any) => item.id}
                                            contentContainerStyle={[
                                                styles.articleContent,
                                                // NEW: Center content vertically for orphan audio files
                                                readingSession.toolId === 'orphan_audio' && { flexGrow: 1, justifyContent: 'center' }
                                            ]}
                                            // UPDATED: Balanced value for performance vs scroll stability
                                            initialNumToRender={6}
                                            maxToRenderPerBatch={5}
                                            windowSize={5}
                                            removeClippedSubviews={true}
                                            updateCellsBatchingPeriod={50}
                                            // NEW: Only save scroll position when user is actively dragging or momentum scrolling
                                            onScrollBeginDrag={() => {
                                                isUserScrolling.current = true;
                                                // User took control, cancel any pending auto-restore to prevent fighting
                                                pendingRestoreOffset.current = null;
                                            }}
                                            onScrollEndDrag={(e) => {
                                                if (readingSession?.id && !expandedTableData) {
                                                    scrollOffsets.current[readingSession.id] = e.nativeEvent.contentOffset.y;
                                                }
                                                // Mark as stopped (will be overridden by onMomentumScrollBegin immediately if momentum starts)
                                                isUserScrolling.current = false;
                                            }}
                                            onMomentumScrollBegin={() => {
                                                isUserScrolling.current = true;
                                            }}
                                            onMomentumScrollEnd={(e) => {
                                                // Capture final momentum position and reset flag
                                                if (readingSession?.id && !expandedTableData) {
                                                    scrollOffsets.current[readingSession.id] = e.nativeEvent.contentOffset.y;
                                                }
                                                isUserScrolling.current = false;
                                            }}
                                            onScroll={(e) => {
                                                // Only save offset if user initiated the scroll (prevents overwriting during restore)
                                                if (isUserScrolling.current && !expandedTableData && readingSession?.id) {
                                                    scrollOffsets.current[readingSession.id] = e.nativeEvent.contentOffset.y;
                                                }
                                            }}
                                            // NEW: Smart Restore Logic - Wait for content to be large enough before scrolling
                                            onContentSizeChange={(w, h) => {
                                                if (pendingRestoreOffset.current !== null && h >= pendingRestoreOffset.current) {
                                                    readerListRef.current?.scrollToOffset({ offset: pendingRestoreOffset.current, animated: false });
                                                    // We successfully restored to the target, clear pending
                                                    pendingRestoreOffset.current = null;
                                                } else if (shouldScrollToNewContentRef.current) {
                                                    // Smart Scroll: Scroll to the start of the NEW content (User query + AI response)
                                                    // instead of the absolute bottom.
                                                    const targetIndex = prevParagraphCountRef.current;

                                                    if (targetIndex >= 0 && targetIndex < readerParagraphs.length) {
                                                        try {
                                                            readerListRef.current?.scrollToIndex({
                                                                index: targetIndex,
                                                                animated: true,
                                                                viewPosition: 0 // Position at the top of the screen
                                                            });
                                                        } catch (e: any) {
                                                            // Fallback if item layout isn't measured yet
                                                            readerListRef.current?.scrollToEnd({ animated: true });
                                                        }
                                                    } else {
                                                        readerListRef.current?.scrollToEnd({ animated: true });
                                                    }
                                                    shouldScrollToNewContentRef.current = false;
                                                }
                                            }}
                                            onLayout={() => {
                                                // Attempt restore on initial layout (for cached/fast renders)
                                                if (pendingRestoreOffset.current !== null) {
                                                    readerListRef.current?.scrollToOffset({ offset: pendingRestoreOffset.current, animated: false });
                                                }
                                            }}
                                            scrollEventThrottle={16} // Ensure we get frequent enough updates
                                            ListHeaderComponent={
                                                <View>
                                                    {/* 1. Generated Output Image (Cover/Diagram) */}
                                                    {readingSession.image ? (
                                                        <TouchableOpacity onPress={() => setFullScreenImage(readingSession.image)} activeOpacity={0.9}>
                                                            <Image
                                                                source={{ uri: readingSession.image }}
                                                                style={[
                                                                    styles.coverImage,
                                                                    {
                                                                        backgroundColor: theme.inputBg,
                                                                        height: undefined, // Allow height to be determined by aspect ratio
                                                                        aspectRatio: coverAspectRatio, // Dynamic aspect ratio
                                                                        width: '100%'
                                                                    }
                                                                ]}
                                                                resizeMode="cover" // Cover fills the aspect-ratio-locked box perfectly
                                                            />
                                                        </TouchableOpacity>
                                                    ) : (
                                                        /* NEW: Fallback Book Cover Advertisement for Stories - THEME ADAPTIVE */
                                                        (readingSession.toolId === 'story_generator') && (
                                                            <View style={[styles.coverImage, {
                                                                overflow: 'hidden',
                                                                position: 'relative',
                                                                height: 450,
                                                                borderRadius: 12,
                                                                backgroundColor: theme.id === 'day' ? '#fdfbf7' : theme.uiBg, // Paper color in day, UI color in night
                                                                borderWidth: 1,
                                                                borderColor: theme.border,
                                                                shadowColor: "#000",
                                                                shadowOffset: { width: 0, height: 4 },
                                                                shadowOpacity: 0.2,
                                                                shadowRadius: 5,
                                                                elevation: 5
                                                            }]}>
                                                                {/* Classic Book Frame Border */}
                                                                <View style={{
                                                                    position: 'absolute', top: 20, left: 20, right: 20, bottom: 20,
                                                                    borderWidth: 3,
                                                                    borderColor: theme.text,
                                                                    opacity: 0.08,
                                                                    borderRadius: 4,
                                                                    borderStyle: 'solid'
                                                                }} />

                                                                {/* Inner Frame */}
                                                                <View style={{
                                                                    position: 'absolute', top: 26, left: 26, right: 26, bottom: 26,
                                                                    borderWidth: 1,
                                                                    borderColor: theme.text,
                                                                    opacity: 0.05,
                                                                    borderRadius: 2
                                                                }} />

                                                                <View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, justifyContent: 'center', alignItems: 'center', padding: 40 }}>

                                                                    {/* Branding */}
                                                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 40 }}>
                                                                        <Sparkles size={16} color="#eab308" style={{ marginRight: 8 }} fill="#eab308" />
                                                                        <Text style={{
                                                                            color: '#eab308',
                                                                            fontSize: 12,
                                                                            fontWeight: 'bold',
                                                                            letterSpacing: 3,
                                                                            textTransform: 'uppercase'
                                                                        }}>ReaderApp Original</Text>
                                                                    </View>

                                                                    {/* Main Title */}
                                                                    <Text style={{
                                                                        color: theme.text,
                                                                        fontSize: 36,
                                                                        fontWeight: '900',
                                                                        textAlign: 'center',
                                                                        fontFamily: Platform.OS === 'ios' ? 'Georgia' : 'serif',
                                                                        lineHeight: 46,
                                                                        marginBottom: 20,
                                                                        textShadowColor: theme.id === 'day' ? 'transparent' : 'rgba(0,0,0,0.5)',
                                                                        textShadowOffset: { width: 0, height: 2 },
                                                                        textShadowRadius: 4
                                                                    }}>
                                                                        {readingSession.title.split(':')[0].trim()}
                                                                    </Text>

                                                                    {/* Subtitle / Chapter Name */}
                                                                    {readingSession.title.includes(':') && (
                                                                        <View style={{ borderTopWidth: 2, borderTopColor: theme.border, paddingTop: 20, marginTop: 10, width: '40%', alignItems: 'center' }}>
                                                                            <Text style={{
                                                                                color: theme.secondary,
                                                                                fontSize: 18,
                                                                                fontStyle: 'italic',
                                                                                textAlign: 'center',
                                                                                fontFamily: Platform.OS === 'ios' ? 'Georgia' : 'serif',
                                                                                fontWeight: '500'
                                                                            }}>
                                                                                {readingSession.title.split(':').slice(1).join(':').trim()}
                                                                            </Text>
                                                                        </View>
                                                                    )}

                                                                    {/* Footer Icon */}
                                                                    <View style={{ position: 'absolute', bottom: 35, alignItems: 'center', opacity: 0.7 }}>
                                                                        <BookOpenText size={28} color={theme.text} style={{ marginBottom: 8 }} strokeWidth={1.5} />
                                                                        <Text style={{ color: theme.secondary, fontSize: 10, letterSpacing: 2, fontWeight: '700', textTransform: 'uppercase' }}>AI Generated Story</Text>
                                                                    </View>
                                                                </View>
                                                            </View>
                                                        )
                                                    )}

                                                    {/* 2. Source Input Images (Carousel) - Displayed below generated image if both exist */}
                                                    {(() => {
                                                        const validImages = readingSession.images ? readingSession.images.filter((uri: string) => !isPdf(uri)) : [];
                                                        if (validImages.length === 0) return null;
                                                        return (
                                                            <View style={{ marginBottom: 20 }}>
                                                                {readingSession.image && <Text style={{ color: theme.secondary, fontSize: 12, fontWeight: 'bold', marginBottom: 8, textTransform: 'uppercase' }}>Source Images</Text>}
                                                                <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 10 }}>
                                                                    {validImages.map((uri: string, idx: number) => (
                                                                        <TouchableOpacity key={idx} onPress={() => setFullScreenImage(uri)} activeOpacity={0.9}>
                                                                            <Image
                                                                                source={{ uri: uri }}
                                                                                style={{
                                                                                    width: readingSession.image ? 120 : 300, // Smaller if cover exists
                                                                                    height: readingSession.image ? 120 : 300, // Increased height
                                                                                    borderRadius: 16,
                                                                                    backgroundColor: theme.inputBg
                                                                                }}
                                                                                resizeMode="contain"
                                                                            />
                                                                        </TouchableOpacity>
                                                                    ))}
                                                                </ScrollView>
                                                            </View>
                                                        );
                                                    })()}

                                                    {/* FIXED: Title now fully respects user Typography styles (no default bold override from stylesheet) */}
                                                    {/* NEW: Hide title in body for Orphan Audio since it's in the header */}
                                                    {readingSession.toolId !== 'orphan_audio' && (
                                                        <View>
                                                            <Text style={[styles.articleTitle, { color: theme.text, marginBottom: 10, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }]}>
                                                                {readingSession.title}
                                                            </Text>
                                                            {customAudioUris[readingSession.id] && (
                                                                <TouchableOpacity
                                                                    onLongPress={() => handleDeleteCustomAudio(readingSession)}
                                                                    delayLongPress={500}
                                                                    style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 15, backgroundColor: theme.highlight, padding: 8, borderRadius: 8 }}
                                                                >
                                                                    <Volume2 size={14} color={primaryColor} style={{ marginRight: 6 }} />
                                                                    <Text style={{ fontSize: 12, color: theme.text, fontWeight: 'bold' }}>Custom Audio Loaded</Text>
                                                                </TouchableOpacity>
                                                            )}
                                                        </View>
                                                    )}
                                                </View>
                                            }
                                            renderItem={renderReaderItem} // Use memoized renderItem
                                            // UPDATED: Include theme and displaySettings in extraData to force re-render when appearance changes
                                            extraData={[readingSession?.highlights, displaySettings.tapToDefine, displaySettings.theme, displaySettings.fontSize, displaySettings.fontFamily, displaySettings.textStyles]}
                                            ListFooterComponent={
                                                <View style={{ marginBottom: readingSession.toolId === 'orphan_audio' ? 0 : 50 }}>
                                                    {!(ttsStatus === 'playing' && playingMeta?.id === readingSession?.id) && readingSession.toolId !== 'orphan_audio' && (
                                                        <Text style={{ textAlign: 'center', marginTop: 20, marginBottom: 20, color: theme.secondary, fontStyle: 'italic', ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}>(Tap any word to define)</Text>
                                                    )}

                                                    {/* UPDATED: Show Advertisement when TTS is Playing OR when it's an orphan audio file (No text content) */}
                                                    {((ttsStatus === 'playing' && playingMeta?.id === readingSession?.id) || readingSession.toolId === 'orphan_audio') ? (
                                                        <View style={{ marginBottom: 20 }}>
                                                            <LinearGradient
                                                                colors={['#4f46e5', '#9333ea']}
                                                                start={{ x: 0, y: 0 }}
                                                                end={{ x: 1, y: 1 }}
                                                                style={[styles.adContainer, {
                                                                    borderColor: theme.border,
                                                                    marginBottom: 0,
                                                                    borderBottomLeftRadius: 0,
                                                                    borderBottomRightRadius: 0,
                                                                    borderBottomWidth: 0,
                                                                    justifyContent: 'center',
                                                                    alignItems: 'center'
                                                                }]}
                                                            >
                                                                <Heart size={120} color="white" style={{ position: 'absolute', right: -20, top: -20, opacity: 0.1 }} />
                                                                <Star
                                                                    size={60}
                                                                    color="white"
                                                                    style={{ position: 'absolute', left: -20, bottom: -20, opacity: 0.1 }}
                                                                />

                                                                <View style={{ alignItems: 'center', zIndex: 1 }}>
                                                                    <View style={{
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center',
                                                                        marginBottom: 8,
                                                                        backgroundColor: 'rgba(0,0,0,0.3)', // Darker glass for contrast
                                                                        borderWidth: 1,
                                                                        borderColor: '#FFD700', // Gold Border
                                                                        paddingHorizontal: 12,
                                                                        paddingVertical: 4,
                                                                        borderRadius: 20,
                                                                        shadowColor: '#FFD700',
                                                                        shadowOffset: { width: 0, height: 0 },
                                                                        shadowOpacity: 0.5,
                                                                        shadowRadius: 10,
                                                                        elevation: 5 // Android Glow
                                                                    }}>
                                                                        <Trophy size={14} color="#FFD700" fill="#FFD700" style={{ marginRight: 6 }} />
                                                                        <Text style={{ color: '#FFD700', fontWeight: 'bold', fontSize: 12, textTransform: 'uppercase', letterSpacing: 1.5 }}>ELITE</Text>
                                                                    </View>
                                                                    <Text style={styles.adTitle}>ReaderApp</Text>
                                                                    <Text style={styles.adSubtitle}>Built with â¤ï¸ by Mukesh Yadav</Text>
                                                                </View>
                                                            </LinearGradient>

                                                            <View style={{
                                                                backgroundColor: theme.uiBg,
                                                                padding: 20,
                                                                borderBottomLeftRadius: 16,
                                                                borderBottomRightRadius: 16,
                                                                borderWidth: 1,
                                                                borderColor: theme.border,
                                                                borderTopWidth: 0
                                                            }}>
                                                                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
                                                                    <Sparkles size={18} color="#eab308" style={{ marginRight: 8 }} fill="#eab308" />
                                                                    <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Supercharge Your Learning</Text>
                                                                </View>

                                                                <Text style={{ fontSize: 14, color: theme.secondary, lineHeight: 24, marginBottom: 20 }}>
                                                                    â€¢ Generate unlimited stories & articles{'\n'}
                                                                    â€¢ Learn languages with instant translation{'\n'}
                                                                    â€¢ Master subjects with AI quizzes{'\n'}
                                                                    â€¢ Listen on the go with Offline Audio
                                                                </Text>

                                                                <TouchableOpacity
                                                                    onPress={() => Linking.openURL('https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp')}
                                                                    style={{
                                                                        backgroundColor: primaryColor,
                                                                        paddingVertical: 12,
                                                                        borderRadius: 12,
                                                                        alignItems: 'center',
                                                                        flexDirection: 'row',
                                                                        justifyContent: 'center',
                                                                        gap: 8,
                                                                        shadowColor: primaryColor,
                                                                        shadowOffset: { width: 0, height: 4 },
                                                                        shadowOpacity: 0.2,
                                                                        shadowRadius: 4,
                                                                        elevation: 3
                                                                    }}
                                                                >
                                                                    <Star size={16} color="white" fill="white" />
                                                                    <Text style={{ color: 'white', fontWeight: 'bold' }}>Rate Us 5 Stars</Text>
                                                                </TouchableOpacity>
                                                            </View>
                                                        </View>
                                                    ) : (
                                                        <View style={{ flexDirection: 'row', gap: 10 }}>
                                                            {/* CHANGED: Hide Take Quiz for specific functional tools AND Story Generator AND Orphan Audio */}
                                                            {!['help_guide', 'greetings_gen', 'health_guide', 'study_planner', 'story_generator', 'orphan_audio'].includes(readingSession.toolId) && (
                                                                <TouchableOpacity
                                                                    style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: theme.highlight, borderWidth: 1, borderColor: theme.border }]}
                                                                    onPress={() => handleStartQuiz(readingSession.messages[0].content, false, "General", true, readingSession.images)}
                                                                >
                                                                    <MonitorCheck size={20} color={theme.text} />
                                                                    <Text style={[styles.primaryBtnText, { color: theme.text }]}>Take Quiz</Text>
                                                                </TouchableOpacity>
                                                            )}

                                                            {/* NEW: Flashcards Button for Reader content */}
                                                            {!['help_guide', 'greetings_gen', 'health_guide', 'study_planner', 'story_generator', 'orphan_audio'].includes(readingSession.toolId) && (
                                                                <TouchableOpacity
                                                                    style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: theme.highlight, borderWidth: 1, borderColor: theme.border }]}
                                                                    onPress={() => handleStartQuiz(readingSession.messages[0].content, false, "General", true, readingSession.images, null, true)}
                                                                >
                                                                    <Copy size={20} color={theme.text} />
                                                                    <Text style={[styles.primaryBtnText, { color: theme.text }]}>Flashcards</Text>
                                                                </TouchableOpacity>
                                                            )}

                                                            {readingSession.toolId === 'story_generator' && (
                                                                <View style={{ width: '100%', gap: 15 }}>
                                                                    {/* NEW: Input for Next Chapter Guidance */}
                                                                    {!readingSession.nextChapterId && (
                                                                        <View>
                                                                            <Text style={{ color: theme.secondary, fontSize: 11, fontWeight: 'bold', marginBottom: 8, textTransform: 'uppercase' }}>What happens next?</Text>
                                                                            <View>
                                                                                <TextInput
                                                                                    style={[styles.input, {
                                                                                        backgroundColor: theme.inputBg,
                                                                                        color: theme.text,
                                                                                        borderColor: theme.border,
                                                                                        marginBottom: 0,
                                                                                        paddingRight: 90, // Increased padding for 2 buttons
                                                                                        minHeight: 50,
                                                                                        height: undefined,
                                                                                        maxHeight: 150
                                                                                    }]}
                                                                                    placeholder="Guide the story (optional)..."
                                                                                    placeholderTextColor={theme.secondary}
                                                                                    value={nextChapterInput}
                                                                                    onChangeText={setNextChapterInput}
                                                                                    onFocus={() => setShowStoryAd(true)} // NEW: Show ad on focus
                                                                                    multiline={true}
                                                                                />

                                                                                {/* NEW: Vision Button for Story Next */}
                                                                                <TouchableOpacity
                                                                                    onPress={() => {
                                                                                        setImagePickerMode('story_next');
                                                                                        setVisionDraft({ uris: [], prompt: "Describe the events in this image to continue the story." });
                                                                                        setShowImageSourceModal(true);
                                                                                    }}
                                                                                    style={{
                                                                                        position: 'absolute',
                                                                                        right: 50,
                                                                                        top: 6,
                                                                                        width: 38,
                                                                                        height: 38,
                                                                                        borderRadius: 19,
                                                                                        backgroundColor: theme.uiBg,
                                                                                        alignItems: 'center',
                                                                                        justifyContent: 'center',
                                                                                        borderWidth: 1,
                                                                                        borderColor: theme.border
                                                                                    }}
                                                                                >
                                                                                    <Camera size={18} color={theme.text} />
                                                                                </TouchableOpacity>

                                                                                {renderMicButton('story_next', { position: 'absolute', right: 6, top: 6, width: 38, height: 38, backgroundColor: theme.uiBg })}
                                                                            </View>
                                                                        </View>
                                                                    )}

                                                                    {/* NEW: Advertisement Block triggers on input focus */}
                                                                    {showStoryAd && !readingSession.nextChapterId && (
                                                                        <View style={{ marginBottom: 5 }}>
                                                                            <LinearGradient
                                                                                colors={['#4f46e5', '#9333ea']}
                                                                                start={{ x: 0, y: 0 }}
                                                                                end={{ x: 1, y: 1 }}
                                                                                style={[styles.adContainer, {
                                                                                    borderColor: theme.border,
                                                                                    marginBottom: 0,
                                                                                    borderBottomLeftRadius: 0,
                                                                                    borderBottomRightRadius: 0,
                                                                                    borderBottomWidth: 0,
                                                                                    justifyContent: 'center',
                                                                                    alignItems: 'center'
                                                                                }]}
                                                                            >
                                                                                <Heart size={120} color="white" style={{ position: 'absolute', right: -20, top: -20, opacity: 0.1 }} />
                                                                                <View style={{ alignItems: 'center', zIndex: 1 }}>
                                                                                    <Text style={[styles.adTitle, { fontSize: 18 }]}>Enjoying the App?</Text>
                                                                                    <Text style={{ color: 'rgba(255,255,255,0.9)', fontSize: 13, marginTop: 4 }}>Drowning in 5-Star Reviews!</Text>
                                                                                </View>
                                                                            </LinearGradient>

                                                                            <View style={{
                                                                                backgroundColor: theme.uiBg,
                                                                                padding: 20,
                                                                                borderBottomLeftRadius: 16,
                                                                                borderBottomRightRadius: 16,
                                                                                borderWidth: 1,
                                                                                borderColor: theme.border,
                                                                                borderTopWidth: 0
                                                                            }}>
                                                                                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
                                                                                    <Sparkles size={18} color="#eab308" style={{ marginRight: 8 }} fill="#eab308" />
                                                                                    <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Supercharge Your Learning</Text>
                                                                                </View>

                                                                                <Text style={{ fontSize: 14, color: theme.secondary, lineHeight: 24, marginBottom: 20 }}>
                                                                                    â€¢ Generate unlimited stories & articles{'\n'}
                                                                                    â€¢ Learn languages with instant translation{'\n'}
                                                                                    â€¢ Master subjects with AI quizzes{'\n'}
                                                                                    â€¢ Listen on the go with Offline Audio
                                                                                </Text>

                                                                                <TouchableOpacity
                                                                                    onPress={() => Linking.openURL('https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp')}
                                                                                    style={{
                                                                                        backgroundColor: primaryColor,
                                                                                        paddingVertical: 12,
                                                                                        borderRadius: 12,
                                                                                        alignItems: 'center',
                                                                                        flexDirection: 'row',
                                                                                        justifyContent: 'center',
                                                                                        gap: 8,
                                                                                        shadowColor: primaryColor,
                                                                                        shadowOffset: { width: 0, height: 4 },
                                                                                        shadowOpacity: 0.2,
                                                                                        shadowRadius: 4,
                                                                                        elevation: 3
                                                                                    }}
                                                                                >
                                                                                    <Star size={16} color="white" fill="white" />
                                                                                    <Text style={{ color: 'white', fontWeight: 'bold' }}>Rate Us 5 Stars</Text>
                                                                                </TouchableOpacity>
                                                                            </View>
                                                                        </View>
                                                                    )}

                                                                    <View style={{ flexDirection: 'row', gap: 10 }}>
                                                                        {readingSession.previousChapterId && chatSessions[readingSession.previousChapterId] && (
                                                                            <TouchableOpacity
                                                                                style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: theme.buttonBg, borderWidth: 1, borderColor: theme.border }]}
                                                                                onPress={handlePreviousChapter}
                                                                            >
                                                                                <ArrowLeft size={20} color={theme.text} />
                                                                                <Text style={[styles.primaryBtnText, { color: theme.text }]}>Previous</Text>
                                                                            </TouchableOpacity>
                                                                        )}
                                                                        <TouchableOpacity
                                                                            style={[styles.primaryBtn, { flex: 1, flexDirection: 'row', gap: 10, backgroundColor: primaryColor }]}
                                                                            onPress={() => {
                                                                                if (readingSession.nextChapterId && chatSessions[readingSession.nextChapterId]) {
                                                                                    const nextSession = chatSessions[readingSession.nextChapterId];
                                                                                    loadHistorySession(nextSession, 'reader');
                                                                                } else {
                                                                                    handleNextChapter();
                                                                                }
                                                                            }}
                                                                        >
                                                                            <BookOpenText size={20} color="white" />
                                                                            <Text style={styles.primaryBtnText}>
                                                                                {readingSession.nextChapterId ? "Open Next" : "Next Chapter"}
                                                                            </Text>
                                                                        </TouchableOpacity>
                                                                    </View>
                                                                </View>
                                                            )}
                                                        </View>
                                                    )}
                                                </View>
                                            }
                                        />

                                        {/* UPDATED: Only show in-reader controls if the playing session matches the viewed session */}
                                        {ttsStatus !== 'stopped' && playingMeta?.id === readingSession?.id && (
                                            <View style={{
                                                paddingHorizontal: 20,
                                                paddingVertical: 12,
                                                borderTopWidth: 1,
                                                borderTopColor: theme.border,
                                                backgroundColor: theme.uiBg,
                                                flexDirection: 'row',
                                                alignItems: 'center',
                                                gap: 15
                                            }}>
                                                <TouchableOpacity
                                                    onPress={async () => {
                                                        // NEW: Handle Orphan Play/Pause directly
                                                        if (readingSession?.toolId === 'orphan_audio') {
                                                            if (currentSound.current) {
                                                                const player = currentSound.current;
                                                                if ((player as any).playing) {
                                                                    (player as any).pause();
                                                                    setTtsStatus('paused');
                                                                } else {
                                                                    (player as any).play();
                                                                    setTtsStatus('playing');
                                                                }
                                                            }
                                                        } else {
                                                            // CUSTOM AUDIO CHECK
                                                            const customAudio = customAudioUris[readingSession.id];
                                                            if (customAudio) {
                                                                if (isCustomAudioPlaying) {
                                                                    stopCustomAudio();
                                                                    setTtsStatus('paused');
                                                                } else {
                                                                    const success = await playCustomAudio(readingSession.id);
                                                                    if (success) setTtsStatus('playing');
                                                                }
                                                            } else {
                                                                speak(readerFullText, 0, true);
                                                            }
                                                        }
                                                    }}
                                                    hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                                                >
                                                    {ttsStatus === 'playing' ? (
                                                        <Pause size={24} color={theme.text} />
                                                    ) : (
                                                        <PlayCircle size={24} color={theme.text} />
                                                    )}
                                                </TouchableOpacity>

                                                <TouchableOpacity
                                                    onPress={() => jumpSentence('prev')}
                                                    hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                                                    style={{ opacity: 0.8 }}
                                                >
                                                    <SkipBack size={24} color={theme.text} />
                                                </TouchableOpacity>

                                                <View style={{ flex: 1 }}>
                                                    <SeekSlider
                                                        // NEW: Use audioProgress for orphan files, text index for others, customAudioProgress for uploads
                                                        value={
                                                            (() => {
                                                                const val = readingSession?.toolId === 'orphan_audio' ? audioProgress.position :
                                                                    (isCustomAudioPlaying || (readingSession && customAudioUrisState[readingSession.id] && ttsStatus === 'playing')) ? customAudioProgress.position :
                                                                        (speechRange?.start || 0);
                                                                // console.log('[SeekDebug] Value:', val, 'CustomPlaying:', isCustomAudioPlaying, 'AudioProgress:', customAudioProgress.position);
                                                                return val;
                                                            })()
                                                        }
                                                        min={0}
                                                        max={
                                                            readingSession?.toolId === 'orphan_audio' ? audioProgress.duration :
                                                                (isCustomAudioPlaying || (readingSession && customAudioUrisState[readingSession.id] && ttsStatus === 'playing')) ? (customAudioProgress.duration || 1) :
                                                                    (readerFullText.length || 1)
                                                        }
                                                        onSeekEnd={async (val: number) => {
                                                            if (isCustomAudioPlaying && customAudioPlayerRef.current) {
                                                                // Handle seeking for custom audio (MS -> Seconds)
                                                                await customAudioPlayerRef.current.seekTo(val / 1000);
                                                                setCustomAudioProgress((prev: any) => ({ ...prev, position: val }));
                                                            } else {
                                                                handleTTSSeek(val);
                                                            }
                                                        }}
                                                        theme={theme}
                                                        activeColor={primaryColor}
                                                    />
                                                </View>

                                                <TouchableOpacity
                                                    onPress={() => jumpSentence('next')}
                                                    hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                                                    style={{ opacity: 0.8 }}
                                                >
                                                    <SkipForward size={24} color={theme.text} />
                                                </TouchableOpacity>
                                            </View>
                                        )}

                                        {/* Onboarding Preview Footer - NOW INSIDE KEYBOARD AVOIDING VIEW */}
                                        {isInOnboardingPreview && (
                                            <OnboardingPreviewFooter
                                                theme={theme}
                                                apiKey={customApiKey}
                                                setApiKey={setCustomApiKey}
                                                testConnection={handleTestConnection}
                                                connectionStatus={apiConnectionStatus}
                                                isLandscape={isLandscape}
                                                onSkip={async () => {
                                                    await saveSettings({ isOnboarded: true });
                                                    setIsInOnboardingPreview(false);
                                                    setAppMode("idle");
                                                }}
                                                onFinish={async () => {
                                                    if (apiConnectionStatus !== 'success') {
                                                        Alert.alert("API Key Required", "Please test your connection first, or skip for now.");
                                                        return;
                                                    }
                                                    await saveSettings({ isOnboarded: true });
                                                    setIsInOnboardingPreview(false);
                                                    setAppMode("idle");
                                                    Alert.alert("Success", "Welcome to Reader App! Your profile and AI are ready.");
                                                }}
                                            />
                                        )}
                                    </KeyboardAvoidingView>
                                )}
                            </View>
                        )}

                        {appMode === 'flashcards' && renderFlashcards()}

                        {appMode === 'live' && quizState && (
                            <View style={{ flex: 1 }}>
                                <View style={{
                                    padding: 15,
                                    borderBottomWidth: 1,
                                    borderBottomColor: theme.border,
                                    backgroundColor: theme.bg,
                                    flexDirection: 'row',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    {/* HEADER CONTENT */}
                                    <Text style={{ fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase', fontSize: 12 }}>
                                        {quizState.title.length > 25 ? quizState.title.substring(0, 25) + "..." : quizState.title}
                                    </Text>
                                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5 }}>
                                        <Text style={{ fontWeight: 'bold', color: theme.text }}>
                                            {quizState.completed ? "Results" : `${quizState.currentIndex + 1}/${quizState.questions.length}`}
                                        </Text>
                                        {!quizState.completed && <Text style={{ color: theme.secondary, fontSize: 12 }}>Question</Text>}
                                    </View>
                                </View>

                                {quizState.completed ? (
                                    <View style={{ flex: 1, backgroundColor: theme.bg }}>
                                        {/* CALCULATE LOCK STATE HERE */}
                                        {(() => {
                                            const session = chatSessions[quizState.originId];
                                            const hasPassword = !!session?.password;
                                            const isLocked = hasPassword && !isReviewUnlocked;

                                            return (
                                                <>
                                                    <View style={{
                                                        backgroundColor: theme.uiBg,
                                                        borderBottomWidth: 1,
                                                        borderBottomColor: theme.border,
                                                        paddingVertical: 12
                                                    }}>
                                                        <ScrollView
                                                            horizontal
                                                            showsHorizontalScrollIndicator={false}
                                                            contentContainerStyle={{ paddingHorizontal: 15, gap: 10 }}
                                                        >
                                                            {quizState.questions.map((q: any, idx: number) => {
                                                                const isCorrect = q.selected === q.correctOptionIndex;
                                                                const isSkipped = q.selected === null;
                                                                const bgColor = isCorrect ? '#22c55e' : (isSkipped ? '#f59e0b' : '#ef4444');
                                                                const isCurrent = idx === quizState.currentIndex;

                                                                return (
                                                                    <TouchableOpacity
                                                                        key={idx}
                                                                        onPress={() => {
                                                                            // PREVENT NAVIGATION IF LOCKED
                                                                            if (isLocked) {
                                                                                Alert.alert("Locked", "Please unlock to view details.");
                                                                                return;
                                                                            }
                                                                            setQuizState((prev: any) => ({ ...prev, currentIndex: idx }));
                                                                            reviewListRef.current?.scrollToIndex({
                                                                                index: idx,
                                                                                animated: true,
                                                                                viewPosition: 0
                                                                            });
                                                                        }}
                                                                        style={{
                                                                            width: 36, height: 36, borderRadius: 18,
                                                                            backgroundColor: bgColor,
                                                                            alignItems: 'center', justifyContent: 'center',
                                                                            shadowColor: "#000",
                                                                            shadowOffset: { width: 0, height: 1 },
                                                                            shadowOpacity: 0.2,
                                                                            shadowRadius: 2,
                                                                            elevation: 3,
                                                                            borderWidth: 2,
                                                                            borderColor: isCurrent ? theme.text : theme.bg
                                                                        }}
                                                                    >
                                                                        <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 12 }}>
                                                                            {idx + 1}
                                                                        </Text>
                                                                    </TouchableOpacity>
                                                                );
                                                            })}
                                                        </ScrollView>
                                                    </View>

                                                    <FlatList
                                                        ref={reviewListRef}
                                                        // HIDE DATA IF LOCKED
                                                        data={isLocked ? [] : quizState.questions}
                                                        keyExtractor={(_: any, index: number) => index.toString()}
                                                        contentContainerStyle={[styles.articleContent, { paddingBottom: 100, paddingTop: 20 }]}
                                                        onScrollToIndexFailed={(info: any) => {
                                                            const wait = new Promise(resolve => setTimeout(resolve, 50));
                                                            wait.then(() => {
                                                                reviewListRef.current?.scrollToOffset({
                                                                    offset: info.averageItemLength * info.index,
                                                                    animated: false
                                                                });
                                                                setTimeout(() => {
                                                                    reviewListRef.current?.scrollToIndex({
                                                                        index: info.index,
                                                                        animated: true,
                                                                        viewPosition: 0
                                                                    });
                                                                }, 100);
                                                            });
                                                        }}
                                                        onViewableItemsChanged={onViewableItemsChanged}
                                                        viewabilityConfig={viewabilityConfig}
                                                        ListHeaderComponent={
                                                            <View style={{ alignItems: 'center', paddingBottom: 30, borderBottomWidth: 1, borderBottomColor: theme.border, marginBottom: 20 }}>
                                                                <Trophy size={64} color="#eab308" />
                                                                <Text style={[styles.welcomeTitle, { color: theme.text, marginTop: 20 }]}>Quiz Complete!</Text>

                                                                {/* NEW: Auto-Submit Warning */}
                                                                {quizState.autoSubmitted && (
                                                                    <View style={{ marginTop: 15, padding: 12, backgroundColor: theme.id === 'day' ? '#fef2f2' : 'rgba(239, 68, 68, 0.15)', borderRadius: 12, borderWidth: 1, borderColor: '#ef4444', alignItems: 'center', width: '100%' }}>
                                                                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 4 }}>
                                                                            <AlertTriangle size={18} color="#dc2626" style={{ marginRight: 6 }} />
                                                                            <Text style={{ color: '#dc2626', fontWeight: 'bold', fontSize: 13 }}>Action Detected</Text>
                                                                        </View>
                                                                        <Text style={{ color: theme.id === 'day' ? '#b91c1c' : '#f87171', fontSize: 12, textAlign: 'center', lineHeight: 18 }}>
                                                                            Exam submitted automatically because you switched apps or minimized the screen.
                                                                        </Text>
                                                                    </View>
                                                                )}

                                                                {(displaySettings.userName || displaySettings.userProfession) && (
                                                                    <View style={{ marginTop: 5, marginBottom: 5, alignItems: 'center' }}>
                                                                        {displaySettings.userName ? (
                                                                            <Text style={{ fontSize: 20, fontWeight: 'bold', color: primaryColor }}>
                                                                                {displaySettings.userName}
                                                                            </Text>
                                                                        ) : null}
                                                                        {displaySettings.userProfession ? (
                                                                            <Text style={{ fontSize: 13, color: theme.secondary, marginTop: 2, textTransform: 'uppercase', letterSpacing: 1, fontWeight: '600' }}>
                                                                                {displaySettings.userProfession}
                                                                            </Text>
                                                                        ) : null}
                                                                    </View>
                                                                )}

                                                                <View style={{ flexDirection: 'row', gap: 8, marginTop: 8 }}>
                                                                    <View style={{ paddingHorizontal: 12, paddingVertical: 4, backgroundColor: theme.highlight, borderRadius: 12, borderWidth: 1, borderColor: theme.border }}>
                                                                        <Text style={{ fontSize: 12, fontWeight: 'bold', color: primaryColor }}>
                                                                            Attempt #{quizState.attempts || 1}
                                                                        </Text>
                                                                    </View>

                                                                    <View style={{
                                                                        paddingHorizontal: 12, paddingVertical: 4, borderRadius: 12,
                                                                        backgroundColor: quizState.isExamMode ? (theme.id === 'day' ? '#fee2e2' : 'rgba(239,68,68,0.2)') : (theme.id === 'day' ? '#dcfce7' : 'rgba(34,197,94,0.2)'),
                                                                        borderWidth: 1,
                                                                        borderColor: quizState.isExamMode ? '#ef4444' : '#22c55e'
                                                                    }}>
                                                                        <Text style={{
                                                                            fontSize: 12, fontWeight: 'bold',
                                                                            color: quizState.isExamMode ? '#dc2626' : '#15803d'
                                                                        }}>
                                                                            {quizState.isExamMode ? "Exam Mode" : "Practice Mode"}
                                                                        </Text>
                                                                    </View>
                                                                </View>

                                                                <View style={{ flexDirection: 'row', gap: 20, marginTop: 15 }}>
                                                                    <Text style={[styles.welcomeSub, { color: theme.text }]}>Score: {quizState.score}/{quizState.questions.length}</Text>
                                                                    <Text style={[styles.welcomeSub, { color: theme.text }]}>Time: {formatTimer(quizSecondsElapsed)}</Text>
                                                                </View>

                                                                <TouchableOpacity
                                                                    onPress={handleShareCertificate}
                                                                    style={{
                                                                        flexDirection: 'row',
                                                                        alignItems: 'center',
                                                                        backgroundColor: theme.buttonBg,
                                                                        paddingVertical: 10,
                                                                        paddingHorizontal: 20,
                                                                        borderRadius: 20,
                                                                        marginTop: 15,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border,
                                                                        shadowColor: "#000",
                                                                        shadowOffset: { width: 0, height: 1 },
                                                                        shadowOpacity: 0.1,
                                                                        shadowRadius: 2,
                                                                        elevation: 2
                                                                    }}
                                                                >
                                                                    <Share2 size={16} color={theme.text} style={{ marginRight: 8 }} />
                                                                    {/* UPDATED: Dynamic Label based on Lock Status */}
                                                                    <Text style={{ color: theme.text, fontWeight: '700', fontSize: 13 }}>
                                                                        {isLocked ? "Share Score" : "Share Certificate"}
                                                                    </Text>
                                                                </TouchableOpacity>

                                                                <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', width: '100%', marginTop: 25, paddingHorizontal: 5 }}>
                                                                    <Text style={{ fontSize: 20, fontWeight: 'bold', color: theme.text }}>Detailed Review</Text>

                                                                    <TouchableOpacity
                                                                        onPress={handleShareQuizFile}
                                                                        style={{
                                                                            flexDirection: 'row',
                                                                            alignItems: 'center',
                                                                            backgroundColor: theme.buttonBg,
                                                                            paddingVertical: 8,
                                                                            paddingHorizontal: 16,
                                                                            borderRadius: 20,
                                                                            borderWidth: 1,
                                                                            borderColor: theme.border,
                                                                            shadowColor: "#000",
                                                                            shadowOffset: { width: 0, height: 1 },
                                                                            shadowOpacity: 0.1,
                                                                            shadowRadius: 2,
                                                                            elevation: 2
                                                                        }}
                                                                    >
                                                                        <FileText size={16} color={theme.text} style={{ marginRight: 8 }} />
                                                                        <Text style={{ color: theme.text, fontWeight: '700', fontSize: 13 }}>
                                                                            Share Quiz
                                                                        </Text>
                                                                    </TouchableOpacity>
                                                                </View>

                                                                {/* LOCK/UNLOCK UI */}
                                                                {isLocked ? (
                                                                    <View style={{ width: '100%', paddingHorizontal: 5, marginTop: 15, alignItems: 'center' }}>
                                                                        <View style={{ width: 60, height: 60, borderRadius: 30, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center', marginBottom: 15 }}>
                                                                            {/* Using Lock icon if available or Key/Shield */}
                                                                            <CheckCircle size={32} color={primaryColor} />
                                                                        </View>
                                                                        <Text style={{ color: theme.secondary, marginBottom: 15, fontStyle: 'italic' }}>Review is locked. Enter password to view.</Text>

                                                                        <View style={{ flexDirection: 'row', gap: 10, width: '100%' }}>
                                                                            <TextInput
                                                                                style={{
                                                                                    flex: 1,
                                                                                    height: 44,
                                                                                    backgroundColor: theme.inputBg,
                                                                                    borderColor: theme.border,
                                                                                    borderWidth: 1,
                                                                                    borderRadius: 12,
                                                                                    paddingHorizontal: 12,
                                                                                    color: theme.text
                                                                                }}
                                                                                placeholder="Enter Password"
                                                                                placeholderTextColor={theme.secondary}
                                                                                value={quizUnlockInput}
                                                                                onChangeText={setQuizUnlockInput}
                                                                                secureTextEntry
                                                                            />
                                                                            <TouchableOpacity
                                                                                onPress={handleUnlockReview}
                                                                                style={{
                                                                                    height: 44,
                                                                                    backgroundColor: primaryColor,
                                                                                    justifyContent: 'center',
                                                                                    paddingHorizontal: 20,
                                                                                    borderRadius: 12
                                                                                }}
                                                                            >
                                                                                <Text style={{ color: 'white', fontWeight: 'bold' }}>Unlock</Text>
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    </View>
                                                                ) : (
                                                                    !hasPassword && (
                                                                        <View style={{ flexDirection: 'row', gap: 10, marginTop: 10, width: '100%', paddingHorizontal: 5 }}>
                                                                            <TextInput
                                                                                style={{
                                                                                    flex: 1,
                                                                                    height: 44,
                                                                                    backgroundColor: theme.inputBg,
                                                                                    borderColor: theme.border,
                                                                                    borderWidth: 1,
                                                                                    borderRadius: 12,
                                                                                    paddingHorizontal: 12,
                                                                                    color: theme.text
                                                                                }}
                                                                                placeholder="Set Password"
                                                                                placeholderTextColor={theme.secondary}
                                                                                value={quizPassword}
                                                                                onChangeText={setQuizPassword}
                                                                                secureTextEntry
                                                                            />
                                                                            <TouchableOpacity
                                                                                onPress={handleSaveQuizPassword}
                                                                                style={{
                                                                                    height: 44,
                                                                                    backgroundColor: primaryColor,
                                                                                    justifyContent: 'center',
                                                                                    paddingHorizontal: 20,
                                                                                    borderRadius: 12
                                                                                }}
                                                                            >
                                                                                <Text style={{ color: 'white', fontWeight: 'bold' }}>Save</Text>
                                                                            </TouchableOpacity>
                                                                        </View>
                                                                    )
                                                                )}
                                                            </View>
                                                        }
                                                        renderItem={({ item: q, index: i }: any) => (
                                                            <View style={{
                                                                marginBottom: 20,
                                                                padding: 16,
                                                                backgroundColor: theme.uiBg,
                                                                borderRadius: 16,
                                                                shadowColor: "#000",
                                                                shadowOffset: { width: 0, height: 2 },
                                                                shadowOpacity: 0.05,
                                                                shadowRadius: 4,
                                                                elevation: 2,
                                                                borderWidth: 1,
                                                                borderColor: theme.border
                                                            }}>
                                                                <View style={{ flexDirection: 'row', gap: 12, marginBottom: 15 }}>
                                                                    <View style={{
                                                                        width: 36, height: 36, borderRadius: 18,
                                                                        backgroundColor: q.selected === q.correctOptionIndex ? '#22c55e' : (q.selected === null ? '#f59e0b' : '#ef4444'),
                                                                        alignItems: 'center', justifyContent: 'center'
                                                                    }}>
                                                                        <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 14 }}>{i + 1}</Text>
                                                                    </View>

                                                                    <View style={{ flex: 1 }}>
                                                                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                                                                            <Text style={{ fontSize: 11, fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase' }}>
                                                                                {q.selected === q.correctOptionIndex ? 'Correct' : (q.selected === null ? 'Skipped' : 'Incorrect')}
                                                                            </Text>
                                                                            <Text style={{ fontSize: 11, color: theme.secondary }}>
                                                                                {formatDuration(quizState.timeSpent ? quizState.timeSpent[i] : 0)}
                                                                            </Text>
                                                                        </View>
                                                                        <ParsedText
                                                                            text={q.question}
                                                                            theme={theme}
                                                                            onExpand={handleExpandTable}
                                                                            style={{ color: theme.text, fontWeight: 'bold', fontSize: 16, lineHeight: 24, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                                        />
                                                                    </View>
                                                                </View>

                                                                {/* Options */}
                                                                <View style={{ gap: 8, marginBottom: 15 }}>
                                                                    {q.options?.map((opt: string, optIdx: number) => {
                                                                        const isCorrect = optIdx === q.correctOptionIndex;
                                                                        const isSelected = optIdx === q.selected;

                                                                        let bg = theme.bg;
                                                                        let border = theme.border;
                                                                        let textColor = theme.text;
                                                                        let icon = null;

                                                                        if (isCorrect) {
                                                                            bg = theme.id === 'day' ? '#f0fdf4' : 'rgba(22, 163, 74, 0.15)';
                                                                            border = '#22c55e';
                                                                            textColor = theme.id === 'day' ? '#15803d' : '#4ade80';
                                                                            icon = <CheckCircle size={16} color={theme.id === 'day' ? '#16a34a' : '#4ade80'} />;
                                                                        } else if (isSelected) {
                                                                            bg = theme.id === 'day' ? '#fef2f2' : 'rgba(220, 38, 38, 0.15)';
                                                                            border = '#ef4444';
                                                                            textColor = theme.id === 'day' ? '#b91c1c' : '#f87171';
                                                                            icon = <XCircle size={16} color={theme.id === 'day' ? '#dc2626' : '#f87171'} />;
                                                                        } else {
                                                                            textColor = theme.text;
                                                                        }

                                                                        return (
                                                                            <View key={optIdx} style={{
                                                                                flexDirection: 'row',
                                                                                alignItems: 'center',
                                                                                padding: 12,
                                                                                borderRadius: 8,
                                                                                backgroundColor: bg,
                                                                                borderWidth: 1,
                                                                                borderColor: border,
                                                                                opacity: (isCorrect || isSelected) ? 1 : 0.9
                                                                            }}>
                                                                                <View style={{ width: 24, alignItems: 'center', marginRight: 10 }}>
                                                                                    {icon ? icon : <Text style={{ fontSize: 12, fontWeight: 'bold', color: theme.secondary }}>{String.fromCharCode(65 + optIdx)}</Text>}
                                                                                </View>
                                                                                <Text style={{ flex: 1, fontSize: 15, color: textColor, fontWeight: (isCorrect || isSelected) ? '700' : '400', lineHeight: 22 }}>
                                                                                    {opt}
                                                                                </Text>
                                                                            </View>
                                                                        );
                                                                    })}
                                                                </View>

                                                                {/* Explanation */}
                                                                <View style={{
                                                                    backgroundColor: theme.highlight,
                                                                    padding: 15,
                                                                    borderRadius: 12,
                                                                    borderLeftWidth: 4,
                                                                    borderLeftColor: '#f59e0b',
                                                                    marginTop: 5
                                                                }}>
                                                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                                                        <Lightbulb size={16} color="#f59e0b" style={{ marginRight: 8 }} />
                                                                        <Text style={{ fontWeight: 'bold', color: '#f59e0b', fontSize: 13, textTransform: 'uppercase' }}>Explanation</Text>
                                                                    </View>
                                                                    <ParsedText
                                                                        text={q.explanation}
                                                                        theme={theme}
                                                                        onExpand={handleExpandTable}
                                                                        style={{ color: theme.text, fontSize: 15, lineHeight: 24, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                                    />

                                                                    {q.visualUri && (
                                                                        <TouchableOpacity onPress={() => setFullScreenImage(q.visualUri)}>
                                                                            <Image source={{ uri: q.visualUri }} style={{ width: '100%', height: 180, borderRadius: 8, marginTop: 10, backgroundColor: theme.inputBg }} resizeMode="contain" />
                                                                        </TouchableOpacity>
                                                                    )}
                                                                    {!q.visualUri && q.visualPrompt && displaySettings.imageGenerationEnabled && (
                                                                        <TouchableOpacity
                                                                            onPress={() => handleGenerateQuizVisual(i)}
                                                                            disabled={q.isGeneratingVisual}
                                                                            style={{ marginTop: 10, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', padding: 8, backgroundColor: theme.bg, borderRadius: 8, borderWidth: 1, borderColor: theme.border }}
                                                                        >
                                                                            {q.isGeneratingVisual ? <ActivityIndicator size="small" color={primaryColor} /> : <ImageIcon size={14} color={primaryColor} style={{ marginRight: 6 }} />}
                                                                            <Text style={{ color: primaryColor, fontWeight: 'bold', fontSize: 12 }}>{q.isGeneratingVisual ? "Creating Diagram..." : "Show Diagram"}</Text>
                                                                        </TouchableOpacity>
                                                                    )}
                                                                </View>
                                                            </View>
                                                        )}
                                                        ListFooterComponent={
                                                            <View style={{ marginTop: 20, marginHorizontal: 20, marginBottom: 40 }}>

                                                                {/* NEW: Advertisement Block in Quiz Review */}
                                                                <View style={{ marginBottom: 20 }}>
                                                                    <LinearGradient
                                                                        colors={['#4f46e5', '#9333ea']}
                                                                        start={{ x: 0, y: 0 }}
                                                                        end={{ x: 1, y: 1 }}
                                                                        style={[styles.adContainer, {
                                                                            borderColor: theme.border,
                                                                            marginBottom: 0,
                                                                            borderBottomLeftRadius: 0,
                                                                            borderBottomRightRadius: 0,
                                                                            borderBottomWidth: 0,
                                                                            justifyContent: 'center',
                                                                            alignItems: 'center'
                                                                        }]}
                                                                    >
                                                                        <Star size={120} color="white" style={{ position: 'absolute', right: -20, top: -20, opacity: 0.1 }} />
                                                                        <View style={{ alignItems: 'center', zIndex: 1 }}>
                                                                            <Text style={styles.adTitle}>Support Free Education</Text>
                                                                            <Text style={styles.adSubtitle}>Rate us 5 Stars on Play Store</Text>
                                                                        </View>
                                                                    </LinearGradient>

                                                                    <View style={{
                                                                        backgroundColor: theme.uiBg,
                                                                        padding: 20,
                                                                        borderBottomLeftRadius: 16,
                                                                        borderBottomRightRadius: 16,
                                                                        borderWidth: 1,
                                                                        borderColor: theme.border,
                                                                        borderTopWidth: 0
                                                                    }}>
                                                                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
                                                                            <Sparkles size={18} color="#eab308" style={{ marginRight: 8 }} fill="#eab308" />
                                                                            <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Supercharge Your Learning</Text>
                                                                        </View>

                                                                        <Text style={{ fontSize: 14, color: theme.secondary, lineHeight: 24, marginBottom: 20 }}>
                                                                            â€¢ Generate unlimited stories & articles{'\n'}
                                                                            â€¢ Learn languages with instant translation{'\n'}
                                                                            â€¢ Master subjects with AI quizzes{'\n'}
                                                                            â€¢ Listen on the go with Offline Audio
                                                                        </Text>

                                                                        <TouchableOpacity
                                                                            onPress={() => Linking.openURL('https://play.google.com/store/apps/details?id=com.mkysitapur.ReaderApp')}
                                                                            style={{
                                                                                backgroundColor: primaryColor,
                                                                                paddingVertical: 12,
                                                                                borderRadius: 12,
                                                                                alignItems: 'center',
                                                                                flexDirection: 'row',
                                                                                justifyContent: 'center',
                                                                                gap: 8,
                                                                                shadowColor: primaryColor,
                                                                                shadowOffset: { width: 0, height: 4 },
                                                                                shadowOpacity: 0.2,
                                                                                shadowRadius: 4,
                                                                                elevation: 3
                                                                            }}
                                                                        >
                                                                            <Star size={16} color="white" fill="white" />
                                                                            <Text style={{ color: 'white', fontWeight: 'bold' }}>Rate Us 5 Stars</Text>
                                                                        </TouchableOpacity>
                                                                    </View>
                                                                </View>

                                                                <View style={{ flexDirection: 'row', gap: 10, marginBottom: 12, height: 50 }}>
                                                                    <View style={{ flex: 1, flexDirection: 'row', backgroundColor: theme.buttonBg, padding: 3, borderRadius: 12, borderWidth: 1, borderColor: theme.border }}>
                                                                        <TouchableOpacity
                                                                            onPress={() => !quizState.modeLocked && updateQuizMode(false)}
                                                                            disabled={quizState.modeLocked}
                                                                            style={{
                                                                                flex: 1,
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                borderRadius: 9,
                                                                                backgroundColor: !quizState.isExamMode ? theme.bg : 'transparent',
                                                                                shadowOpacity: !quizState.isExamMode ? 0.1 : 0,
                                                                                opacity: quizState.modeLocked ? 0.5 : 1
                                                                            }}
                                                                        >
                                                                            <Text style={{ fontWeight: 'bold', color: !quizState.isExamMode ? theme.text : theme.secondary, fontSize: 11 }}>Practice</Text>
                                                                        </TouchableOpacity>
                                                                        <TouchableOpacity
                                                                            onPress={() => !quizState.modeLocked && updateQuizMode(true)}
                                                                            disabled={quizState.modeLocked}
                                                                            style={{
                                                                                flex: 1,
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                borderRadius: 9,
                                                                                backgroundColor: quizState.isExamMode ? theme.bg : 'transparent',
                                                                                shadowOpacity: quizState.isExamMode ? 0.1 : 0,
                                                                                opacity: quizState.modeLocked ? 0.5 : 1
                                                                            }}
                                                                        >
                                                                            <Text style={{ fontWeight: 'bold', color: quizState.isExamMode ? theme.text : theme.secondary, fontSize: 11 }}>Exam</Text>
                                                                        </TouchableOpacity>
                                                                    </View>

                                                                    {/* Test Again Button - Always Visible */}


                                                                    <TouchableOpacity
                                                                        onPress={() => handleRetakeQuiz()}
                                                                        style={{ flex: 1, backgroundColor: primaryColor, borderRadius: 12, alignItems: 'center', justifyContent: 'center', shadowColor: primaryColor, shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.2, shadowRadius: 4, elevation: 3 }}
                                                                    >
                                                                        <Text style={{ color: 'white', fontWeight: 'bold', fontSize: 13 }}>Test Again</Text>
                                                                    </TouchableOpacity>
                                                                </View>

                                                                <TouchableOpacity
                                                                    onPress={closeQuizSession}
                                                                    style={{ backgroundColor: theme.uiBg, paddingVertical: 14, borderRadius: 12, alignItems: 'center', borderWidth: 1, borderColor: theme.border }}
                                                                >
                                                                    <Text style={{ color: theme.text, fontWeight: 'bold' }}>Close Quiz</Text>
                                                                </TouchableOpacity>
                                                            </View>
                                                        }
                                                    />
                                                </>
                                            );
                                        })()}
                                    </View>
                                ) : (
                                    <View style={{ flex: 1 }}>
                                        {(() => {
                                            const q = quizState.questions[quizState.currentIndex];
                                            const isSelected = q.selected !== null && q.selected !== undefined;
                                            const showResult = isSelected && !quizState.isExamMode; // UPDATED: Use frozen mode

                                            if (isLandscape) {
                                                // --- NEW: LANDSCAPE LAYOUT ---
                                                return (
                                                    <View style={{ flex: 1, flexDirection: 'row' }}>
                                                        {/* LEFT: Question Content */}
                                                        <ScrollView
                                                            style={{ flex: 1.2, borderRightWidth: 1, borderRightColor: theme.border }}
                                                            contentContainerStyle={{ padding: 20, paddingBottom: 100 }}
                                                        >
                                                            <QuizContentHeader
                                                                currentIndex={quizState.currentIndex}
                                                                contextText={quizState.contextText}
                                                                showReferenceText={showReferenceText}
                                                                setShowReferenceText={setShowReferenceText}
                                                                visualUri={q.visualUri}
                                                                isGeneratingVisual={q.isGeneratingVisual}
                                                                onGenerateVisual={() => handleGenerateQuizVisual(quizState.currentIndex, true)}
                                                                theme={theme}
                                                                primaryColor={primaryColor}
                                                                showResult={showResult}
                                                                qSelected={q.selected}
                                                                qCorrectIndex={q.correctOptionIndex}
                                                            />

                                                            {quizState.contextText && showReferenceText && (
                                                                <View style={{ marginBottom: 20, padding: 12, backgroundColor: theme.highlight, borderRadius: 8, borderWidth: 1, borderColor: theme.border }}>
                                                                    <InteractiveText
                                                                        rawText={quizState.contextText}
                                                                        onWordPress={() => { }} theme={theme} activeSentence={null}
                                                                        style={{ fontSize: 15, color: theme.text, lineHeight: 24, opacity: 0.9 }}
                                                                    />
                                                                </View>
                                                            )}

                                                            {q.visualUri && (
                                                                <TouchableOpacity onPress={() => setFullScreenImage(q.visualUri)}>
                                                                    <Image source={{ uri: q.visualUri }} style={{ width: '100%', height: 220, borderRadius: 12, marginBottom: 20, backgroundColor: theme.inputBg }} resizeMode="contain" />
                                                                </TouchableOpacity>
                                                            )}

                                                            {q.visualPrompt && !q.visualUri && (
                                                                <View style={{ width: '100%', height: 220, borderRadius: 12, marginBottom: 20, backgroundColor: theme.inputBg, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, borderStyle: 'dashed' }}>
                                                                    {q.isGeneratingVisual ? (
                                                                        <View style={{ alignItems: 'center' }}>
                                                                            <ActivityIndicator size="large" color={primaryColor} />
                                                                            <Text style={{ marginTop: 10, color: theme.secondary, fontSize: 12, fontWeight: 'bold' }}>Generating Diagram...</Text>
                                                                        </View>
                                                                    ) : (
                                                                        <TouchableOpacity onPress={() => handleGenerateQuizVisual(quizState.currentIndex, true)} style={{ alignItems: 'center' }}>
                                                                            <ImageIcon size={32} color={theme.secondary} style={{ opacity: 0.5 }} />
                                                                            <Text style={{ marginTop: 8, color: theme.secondary, fontSize: 12 }}>Tap to load diagram</Text>
                                                                        </TouchableOpacity>
                                                                    )}
                                                                </View>
                                                            )}

                                                            <ParsedText
                                                                text={q.question} theme={theme} onExpand={handleExpandTable}
                                                                style={{ fontSize: 20, fontWeight: 'bold', color: theme.text, lineHeight: 30, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                            />
                                                        </ScrollView>

                                                        {/* RIGHT: Interaction Area */}
                                                        <View style={{ flex: 0.8, backgroundColor: theme.uiBg }}>
                                                            <View style={{ borderBottomWidth: 1, borderBottomColor: theme.border, paddingBottom: 0 }}>
                                                                {/* FIXED: Use stable QuestionSlider component */}
                                                                <QuestionSlider
                                                                    questions={quizState.questions}
                                                                    currentIndex={quizState.currentIndex}
                                                                    onJump={jumpToQuestion}
                                                                    theme={theme}
                                                                    isExamMode={quizState.isExamMode}
                                                                />
                                                            </View>

                                                            <ScrollView contentContainerStyle={{ padding: 20, paddingBottom: 100 }}>
                                                                <QuizOptionsList
                                                                    options={q.options}
                                                                    selected={q.selected}
                                                                    correctOptionIndex={q.correctOptionIndex}
                                                                    showResult={showResult}
                                                                    isExamMode={quizState.isExamMode}
                                                                    theme={theme}
                                                                    onSelect={(optIdx: number) => handleQuizOptionSelect(quizState.currentIndex, optIdx)}
                                                                    fontFamily={displaySettings.fontFamily}
                                                                    textStyles={displaySettings.textStyles}
                                                                    getTypographyStyle={getTypographyStyle}
                                                                />

                                                                {showResult && (
                                                                    <View style={{ marginTop: 20, paddingTop: 15, borderTopWidth: 1, borderTopColor: theme.border }}>
                                                                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                                                            <Lightbulb size={18} color="#f59e0b" style={{ marginRight: 8 }} />
                                                                            <Text style={{ fontWeight: 'bold', color: theme.secondary, fontSize: 14, textTransform: 'uppercase' }}>Explanation</Text>
                                                                        </View>
                                                                        <ParsedText
                                                                            text={q.explanation} theme={theme} onExpand={handleExpandTable}
                                                                            style={{ color: theme.text, lineHeight: 24, fontSize: 15, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                                        />
                                                                    </View>
                                                                )}
                                                            </ScrollView>

                                                            <View style={{ position: 'absolute', bottom: 0, left: 0, right: 0, padding: 15, borderTopWidth: 1, borderColor: theme.border, backgroundColor: theme.bg }}>
                                                                <QuizNavButtons
                                                                    currentIndex={quizState.currentIndex}
                                                                    totalQuestions={quizState.questions.length}
                                                                    isExamMode={quizState.isExamMode}
                                                                    theme={theme}
                                                                    onPrevious={handlePreviousQuestion}
                                                                    onReview={handleReviewAndNext}
                                                                    onNext={() => {
                                                                        if (quizState.currentIndex === quizState.questions.length - 1) {
                                                                            Alert.alert(
                                                                                quizState.isExamMode ? "Finish Exam" : "Finish Quiz",
                                                                                "Are you sure you want to submit and finish?",
                                                                                [{ text: "Cancel", style: "cancel" }, { text: "Finish", onPress: handleNextQuestion }]
                                                                            );
                                                                        } else {
                                                                            handleNextQuestion();
                                                                        }
                                                                    }}
                                                                />
                                                            </View>
                                                        </View>
                                                    </View>
                                                );
                                            }

                                            // --- EXISTING PORTRAIT LAYOUT ---
                                            return (
                                                <>
                                                    {!quizState.isExamMode && (
                                                        <View style={{ backgroundColor: theme.uiBg, borderBottomWidth: 1, borderBottomColor: theme.border, paddingVertical: 12 }}>
                                                            {/* FIXED: Use stable QuestionSlider component */}
                                                            <QuestionSlider
                                                                questions={quizState.questions}
                                                                currentIndex={quizState.currentIndex}
                                                                onJump={jumpToQuestion}
                                                                theme={theme}
                                                                isExamMode={quizState.isExamMode}
                                                            />
                                                        </View>
                                                    )}
                                                    <ScrollView contentContainerStyle={{ padding: 20, paddingBottom: 200 }}>
                                                        <View style={{
                                                            backgroundColor: theme.uiBg,
                                                            borderRadius: 16,
                                                            padding: 20,
                                                            borderWidth: 1,
                                                            borderColor: theme.border,
                                                            shadowColor: "#000",
                                                            shadowOffset: { width: 0, height: 2 },
                                                            shadowOpacity: 0.05,
                                                            shadowRadius: 4,
                                                            elevation: 2
                                                        }}>
                                                            <QuizContentHeader
                                                                currentIndex={quizState.currentIndex}
                                                                contextText={quizState.contextText}
                                                                showReferenceText={showReferenceText}
                                                                setShowReferenceText={setShowReferenceText}
                                                                visualUri={q.visualUri}
                                                                isGeneratingVisual={q.isGeneratingVisual}
                                                                onGenerateVisual={() => handleGenerateQuizVisual(quizState.currentIndex, true)}
                                                                theme={theme}
                                                                primaryColor={primaryColor}
                                                                showResult={showResult}
                                                                qSelected={q.selected}
                                                                qCorrectIndex={q.correctOptionIndex}
                                                            />

                                                            {quizState.contextText && showReferenceText && (
                                                                <View style={{ marginBottom: 20, padding: 12, backgroundColor: theme.highlight, borderRadius: 8, borderWidth: 1, borderColor: theme.border }}>
                                                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8, justifyContent: 'space-between' }}>
                                                                        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                                                                            <FileText size={14} color={theme.secondary} style={{ marginRight: 6 }} />
                                                                            <Text style={{ fontSize: 11, fontWeight: 'bold', color: theme.secondary, textTransform: 'uppercase' }}>Reference Text</Text>
                                                                        </View>
                                                                        <TouchableOpacity onPress={() => setShowFullScreenReference(true)} style={{ padding: 4 }}>
                                                                            <Maximize2 size={16} color={theme.secondary} />
                                                                        </TouchableOpacity>
                                                                    </View>
                                                                    <ScrollView style={{ maxHeight: 300 }} nestedScrollEnabled={true}>
                                                                        <InteractiveText
                                                                            rawText={quizState.contextText}
                                                                            onWordPress={() => { }} theme={theme} activeSentence={null}
                                                                            style={{ fontSize: 15, color: theme.text, lineHeight: 24, opacity: 0.9 }}
                                                                        />
                                                                    </ScrollView>
                                                                </View>
                                                            )}

                                                            {q.visualUri && (
                                                                <TouchableOpacity onPress={() => setFullScreenImage(q.visualUri)}>
                                                                    <Image source={{ uri: q.visualUri }} style={{ width: '100%', height: 220, borderRadius: 12, marginBottom: 20, backgroundColor: theme.inputBg }} resizeMode="contain" />
                                                                </TouchableOpacity>
                                                            )}

                                                            {q.visualPrompt && !q.visualUri && (
                                                                <View style={{ width: '100%', height: 220, borderRadius: 12, marginBottom: 20, backgroundColor: theme.inputBg, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: theme.border, borderStyle: 'dashed' }}>
                                                                    {q.isGeneratingVisual ? (
                                                                        <View style={{ alignItems: 'center' }}>
                                                                            <ActivityIndicator size="large" color={primaryColor} />
                                                                            <Text style={{ marginTop: 10, color: theme.secondary, fontSize: 12, fontWeight: 'bold' }}>Generating Diagram...</Text>
                                                                        </View>
                                                                    ) : (
                                                                        <TouchableOpacity onPress={() => handleGenerateQuizVisual(quizState.currentIndex, true)} style={{ alignItems: 'center' }}>
                                                                            <ImageIcon size={32} color={theme.secondary} style={{ opacity: 0.5 }} />
                                                                            <Text style={{ marginTop: 8, color: theme.secondary, fontSize: 12 }}>Tap to load diagram</Text>
                                                                        </TouchableOpacity>
                                                                    )}
                                                                </View>
                                                            )}

                                                            <View style={{ marginBottom: 25 }}>
                                                                <ParsedText
                                                                    text={q.question} theme={theme} onExpand={handleExpandTable}
                                                                    style={{ fontSize: 20, fontWeight: 'bold', color: theme.text, lineHeight: 30, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                                />
                                                            </View>

                                                            <QuizOptionsList
                                                                options={q.options}
                                                                selected={q.selected}
                                                                correctOptionIndex={q.correctOptionIndex}
                                                                showResult={showResult}
                                                                isExamMode={quizState.isExamMode}
                                                                theme={theme}
                                                                onSelect={(optIdx: number) => handleQuizOptionSelect(quizState.currentIndex, optIdx)}
                                                                fontFamily={displaySettings.fontFamily}
                                                                textStyles={displaySettings.textStyles}
                                                                getTypographyStyle={getTypographyStyle}
                                                            />

                                                            {showResult && (
                                                                <View style={{ marginTop: 25, paddingTop: 20, borderTopWidth: 1, borderTopColor: theme.border }}>
                                                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                                                        <Lightbulb size={18} color="#f59e0b" style={{ marginRight: 8 }} />
                                                                        <Text style={{ fontWeight: 'bold', color: theme.secondary, fontSize: 14, textTransform: 'uppercase' }}>Explanation</Text>
                                                                    </View>
                                                                    <ParsedText
                                                                        text={q.explanation} theme={theme} onExpand={handleExpandTable}
                                                                        style={{ color: theme.text, lineHeight: 24, fontSize: 16, ...getTypographyStyle(displaySettings.fontFamily, displaySettings.textStyles) }}
                                                                    />

                                                                    {q.visualUri && (
                                                                        <TouchableOpacity onPress={() => setFullScreenImage(q.visualUri)}>
                                                                            <Image source={{ uri: q.visualUri }} style={{ width: '100%', height: 200, borderRadius: 8, marginTop: 15, backgroundColor: theme.inputBg }} resizeMode="contain" />
                                                                        </TouchableOpacity>
                                                                    )}
                                                                    {!q.visualUri && q.visualPrompt && (displaySettings.imageGenerationEnabled || quizState.tempImageGenEnabled) && (
                                                                        <TouchableOpacity
                                                                            onPress={() => handleGenerateQuizVisual(quizState.currentIndex, true)}
                                                                            disabled={q.isGeneratingVisual}
                                                                            style={{ marginTop: 15, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', padding: 12, backgroundColor: theme.highlight, borderRadius: 8, borderWidth: 1, borderColor: theme.border }}
                                                                        >
                                                                            {q.isGeneratingVisual ? <ActivityIndicator size="small" color={primaryColor} /> : <ImageIcon size={16} color={primaryColor} style={{ marginRight: 8 }} />}
                                                                            <Text style={{ color: primaryColor, fontWeight: 'bold', fontSize: 14 }}>{q.isGeneratingVisual ? "Generating Diagram..." : "Show Visual Explanation"}</Text>
                                                                        </TouchableOpacity>
                                                                    )}
                                                                </View>
                                                            )}
                                                        </View>
                                                    </ScrollView>

                                                    <View style={{
                                                        position: 'absolute', bottom: 0, left: 0, right: 0,
                                                        backgroundColor: theme.bg, borderTopWidth: 1, borderTopColor: theme.border,
                                                    }}>
                                                        {quizState.isExamMode && (
                                                            <View style={{ borderBottomWidth: 1, borderBottomColor: theme.border }}>
                                                                {/* FIXED: Use stable QuestionSlider component for Exam Mode as well */}
                                                                <QuestionSlider
                                                                    questions={quizState.questions}
                                                                    currentIndex={quizState.currentIndex}
                                                                    onJump={jumpToQuestion}
                                                                    theme={theme}
                                                                    isExamMode={quizState.isExamMode}
                                                                />
                                                            </View>
                                                        )}
                                                        <View style={{ padding: 20, paddingTop: 10 }}>
                                                            <QuizNavButtons
                                                                currentIndex={quizState.currentIndex}
                                                                totalQuestions={quizState.questions.length}
                                                                isExamMode={quizState.isExamMode}
                                                                theme={theme}
                                                                onPrevious={handlePreviousQuestion}
                                                                onReview={handleReviewAndNext}
                                                                onNext={() => {
                                                                    if (quizState.currentIndex === quizState.questions.length - 1) {
                                                                        Alert.alert(
                                                                            quizState.isExamMode ? "Finish Exam" : "Finish Quiz",
                                                                            "Are you sure you want to submit and finish?",
                                                                            [{ text: "Cancel", style: "cancel" }, { text: "Finish", onPress: handleNextQuestion }]
                                                                        );
                                                                    } else {
                                                                        handleNextQuestion();
                                                                    }
                                                                }}
                                                            />
                                                        </View>
                                                    </View>
                                                </>
                                            );
                                        })()}
                                    </View>
                                )}
                            </View>
                        )}
                    </View>

                    {/* RENDER GLOBAL MINI PLAYER */}
                    {renderMiniPlayer()}

                    {/* UPDATED: Show Footer in Idle OR Examiner Setup Mode */}
                    {(appMode === 'idle' || (appMode === 'setup' && selectedScenario?.id === 'examiner')) && (
                        <View style={[styles.footer, { backgroundColor: theme.bg, borderTopColor: theme.border }]}>
                            <TouchableOpacity onPress={() => { setActiveTab('story'); setAppMode('idle'); }} style={styles.tabItem}>
                                <BookAudio size={28} color={activeTab === 'story' ? theme.bubbleUser : theme.secondary} />
                                <Text style={{ color: activeTab === 'story' ? theme.bubbleUser : theme.secondary, fontSize: 11, marginTop: 2, fontWeight: activeTab === 'story' ? '600' : '400' }}>Studio</Text>
                            </TouchableOpacity>

                            <TouchableOpacity onPress={() => { setActiveTab('dictionary'); setAppMode('idle'); setVisibleWordCount(25); }} style={styles.tabItem}>
                                <BookA size={28} color={activeTab === 'dictionary' ? theme.bubbleUser : theme.secondary} />
                                <Text style={{ color: activeTab === 'dictionary' ? theme.bubbleUser : theme.secondary, fontSize: 11, marginTop: 2, fontWeight: activeTab === 'dictionary' ? '600' : '400' }}>Dictionary</Text>
                            </TouchableOpacity>

                            {/* Quiz Button (Moved from Home Screen Grid) */}
                            <TouchableOpacity
                                onPress={() => {
                                    // Find examiner tool and trigger setup
                                    const allTools = getAllTools();
                                    const tool = allTools.find(t => t.id === 'examiner');
                                    if (tool) {
                                        setSelectedScenario(tool);
                                        // Use remembered subject for examiner
                                        const targetSubject = lastQuizSubject || "General";
                                        saveSchoolConfig({ input: "", subject: targetSubject });
                                        setAppMode('setup');
                                    }
                                }}
                                style={styles.tabItem}
                            >
                                <BrainCircuit size={28} color={(appMode === 'setup' && selectedScenario?.id === 'examiner') ? theme.bubbleUser : theme.secondary} />
                                <Text style={{ color: (appMode === 'setup' && selectedScenario?.id === 'examiner') ? theme.bubbleUser : theme.secondary, fontSize: 11, marginTop: 2, fontWeight: (appMode === 'setup' && selectedScenario?.id === 'examiner') ? '600' : '400' }}>Quiz</Text>
                            </TouchableOpacity>



                            <TouchableOpacity onPress={() => { setActiveTab('notes'); setAppMode('idle'); }} style={styles.tabItem}>
                                <NotebookPen size={28} color={activeTab === 'notes' ? theme.bubbleUser : theme.secondary} />
                                <Text style={{ color: activeTab === 'notes' ? theme.bubbleUser : theme.secondary, fontSize: 11, marginTop: 2, fontWeight: activeTab === 'notes' ? '600' : '400' }}>Notes</Text>
                            </TouchableOpacity>
                            <TouchableOpacity onPress={() => { setActiveTab('library'); setAppMode('idle'); }} style={styles.tabItem}>
                                <Library size={28} color={activeTab === 'library' ? theme.bubbleUser : theme.secondary} />
                                <Text style={{ color: activeTab === 'library' ? theme.bubbleUser : theme.secondary, fontSize: 11, marginTop: 2, fontWeight: activeTab === 'library' ? '600' : '400' }}>Library</Text>
                            </TouchableOpacity>
                        </View>
                    )}

                </View>

                <Modal visible={showAppearance} transparent animationType="slide" onRequestClose={() => setShowAppearance(false)}>
                    <View style={styles.modalOverlay}>
                        <TouchableOpacity
                            style={StyleSheet.absoluteFill}
                            activeOpacity={1}
                            onPress={() => setShowAppearance(false)}
                        />
                        <View style={[styles.modalContent, { backgroundColor: theme.bg, maxHeight: '85%', padding: 0 }]}>
                            {/* FIXED: Added height: 'auto' to override fixed header height, preventing clipping of the title/icon due to padding */}
                            <View style={[styles.header, { height: 'auto', backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20, paddingTop: 20, paddingBottom: 15, borderTopLeftRadius: 24, borderTopRightRadius: 24 }]}>
                                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10, flex: 1 }}>
                                    <View style={{ width: 32, height: 32, borderRadius: 10, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                                        <Palette size={18} color={primaryColor} />
                                    </View>
                                    <Text style={[styles.modalTitle, { color: theme.text, fontSize: 20 }]}>Appearance</Text>
                                </View>
                                <TouchableOpacity onPress={() => setShowAppearance(false)} style={{ padding: 8, backgroundColor: theme.buttonBg, borderRadius: 20 }}>
                                    <X size={20} color={theme.text} />
                                </TouchableOpacity>
                            </View>

                            <ScrollView contentContainerStyle={{ padding: 20, paddingBottom: 40 }} showsVerticalScrollIndicator={false}>



                                <View style={styles.divider} />

                                {/* VISUAL THEME SECTION */}
                                <View style={styles.appearanceSection}>
                                    <Text style={[styles.appearanceSectionTitle, { color: theme.secondary }]}>VISUAL THEME</Text>
                                    <ScrollView
                                        horizontal
                                        showsHorizontalScrollIndicator={false}
                                        style={{ marginBottom: 20 }}
                                        contentContainerStyle={{ gap: 12 }}
                                    >
                                        {[
                                            { id: 'forest', label: 'Forest', bg: '#f0fdf4', text: '#14532d', icon: Leaf },
                                            { id: 'coffee', label: 'Coffee', bg: '#201a16', text: '#d6c4b0', icon: Coffee },
                                            { id: 'nord', label: 'Nord', bg: '#2e3440', text: '#d8dee9', icon: Cpu },
                                            { id: 'slate', label: 'Slate', bg: '#f8fafc', text: '#334155', icon: Feather },
                                            { id: 'ocean', label: 'Ocean', bg: '#f0f9ff', text: '#0c4a6e', icon: Globe },
                                            { id: 'sepia', label: 'Sepia', bg: '#f8f1e3', text: '#5b4636', icon: BookOpen },
                                            { id: 'night', label: 'Night', bg: '#121212', text: '#e5e5e5', icon: Moon },
                                            { id: 'lavender', label: 'Lavender', bg: '#faf5ff', text: '#581c87', icon: Flower },
                                            { id: 'day', label: 'Day', bg: '#ffffff', text: '#1a1a1a', icon: Sun },
                                            { id: 'yellow', label: 'Sunny', bg: '#fefce8', text: '#422006', icon: CloudSun },
                                            { id: 'pink', label: 'Pink', bg: '#fdf2f8', text: '#831843', icon: Heart },
                                            { id: 'midnight', label: 'Midnight', bg: '#0f172a', text: '#cbd5e1', icon: MoonStar },
                                        ].map((t) => {
                                            const isActive = displaySettings.theme === t.id;
                                            return (
                                                <TouchableOpacity
                                                    key={t.id}
                                                    onPress={() => {
                                                        // Toggle logic: Modern -> Classic, Classic -> Modern, Others -> Modern
                                                        const currentFont = displaySettings.fontFamily;
                                                        let nextFont = 'Modern';
                                                        if (currentFont === 'Modern') {
                                                            nextFont = 'Classic';
                                                        }
                                                        saveSettings({ theme: t.id, fontFamily: nextFont });
                                                    }}
                                                    style={{
                                                        width: 100,
                                                        height: 110,
                                                        borderRadius: 16,
                                                        backgroundColor: t.bg,
                                                        borderWidth: isActive ? 2 : 1,
                                                        borderColor: isActive ? primaryColor : theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        shadowColor: "#000",
                                                        shadowOffset: { width: 0, height: 2 },
                                                        shadowOpacity: 0.1,
                                                        shadowRadius: 4,
                                                        elevation: 3
                                                    }}
                                                >
                                                    <t.icon size={24} color={isActive ? primaryColor : t.text} style={{ marginBottom: 8 }} />
                                                    <Text style={{ color: t.text, fontWeight: 'bold', fontSize: 13 }}>{t.label}</Text>
                                                    {isActive && <View style={{ position: 'absolute', top: 8, right: 8, width: 8, height: 8, borderRadius: 4, backgroundColor: primaryColor }} />}
                                                </TouchableOpacity>
                                            );
                                        })}
                                    </ScrollView>

                                    <Text style={[styles.appearanceSectionTitle, { color: theme.secondary }]}>FONT FAMILY</Text>

                                    <ScrollView
                                        horizontal
                                        showsHorizontalScrollIndicator={false}
                                        style={{ marginBottom: 20 }}
                                        contentContainerStyle={{ gap: 10, alignItems: 'center' }}
                                    >
                                        {['Modern', 'Classic', 'Typewriter', 'Rounded', 'Elegant', 'Compact', 'Minimalist', 'Casual'].map((f) => {
                                            const isActive = displaySettings.fontFamily === f;
                                            return (
                                                <TouchableOpacity
                                                    key={f}
                                                    onPress={() => saveSettings({ fontFamily: f })}
                                                    style={{
                                                        paddingHorizontal: 16,
                                                        paddingVertical: 10,
                                                        borderRadius: 20,
                                                        backgroundColor: isActive ? primaryColor : theme.buttonBg,
                                                        borderWidth: 1,
                                                        borderColor: isActive ? primaryColor : theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        minWidth: 80
                                                    }}
                                                >
                                                    <Text style={{
                                                        color: isActive ? 'white' : theme.text,
                                                        fontWeight: 'bold',
                                                        fontFamily: getFontFamily(f),
                                                        fontSize: 14
                                                    }}>
                                                        {f === 'Typewriter' ? 'Mono' : f}
                                                    </Text>
                                                </TouchableOpacity>
                                            );
                                        })}
                                    </ScrollView>

                                    <Text style={[styles.appearanceSectionTitle, { color: theme.secondary }]}>TEXT STYLE</Text>

                                    <ScrollView
                                        horizontal
                                        showsHorizontalScrollIndicator={false}
                                        style={{ marginBottom: 20 }}
                                        contentContainerStyle={{ gap: 10, alignItems: 'center' }}
                                    >
                                        {['Bold', 'Italic', 'Underlined', 'Strikethrough'].map((f) => {
                                            const isActive = (displaySettings.textStyles || []).includes(f);

                                            // Determine label style
                                            let labelStyle = {
                                                color: isActive ? 'white' : theme.text,
                                                fontSize: 14,
                                                fontFamily: getFontFamily(displaySettings.fontFamily), // Use current family
                                                // Apply preview style for modifier types
                                                fontWeight: f === 'Bold' ? 'bold' : 'normal',
                                                fontStyle: f === 'Italic' ? 'italic' : 'normal',
                                                textDecorationLine: f === 'Underlined' ? 'underline' : (f === 'Strikethrough' ? 'line-through' : 'none'),
                                                letterSpacing: 0
                                            };

                                            return (
                                                <TouchableOpacity
                                                    key={f}
                                                    onPress={() => {
                                                        const current = displaySettings.textStyles || [];
                                                        let newStyles;
                                                        if (current.includes(f)) {
                                                            newStyles = current.filter((s: string) => s !== f);
                                                        } else {
                                                            newStyles = [...current, f];
                                                        }
                                                        saveSettings({ textStyles: newStyles });
                                                    }}
                                                    style={{
                                                        paddingHorizontal: 16,
                                                        paddingVertical: 10,
                                                        borderRadius: 20,
                                                        backgroundColor: isActive ? primaryColor : theme.buttonBg,
                                                        borderWidth: 1,
                                                        borderColor: isActive ? primaryColor : theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        minWidth: 80
                                                    }}
                                                >
                                                    <Text style={labelStyle as any}>
                                                        {f}
                                                    </Text>
                                                </TouchableOpacity>
                                            );
                                        })}
                                    </ScrollView>

                                    <CleanSlider
                                        label="TEXT SIZE"
                                        value={displaySettings.fontSize}
                                        min={0.8} max={1.8}
                                        onValueChange={(val: number) => saveSettings({ fontSize: val })}
                                        theme={theme}
                                    />
                                </View>

                                <View style={styles.divider} />

                                {/* NEW: LAYOUT SECTION */}
                                <View style={styles.appearanceSection}>
                                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 15, gap: 8 }}>
                                        <LayoutGrid size={16} color={primaryColor} />
                                        <Text style={[styles.appearanceSectionTitle, { color: theme.secondary, marginBottom: 0 }]}>LAYOUT</Text>
                                    </View>

                                    <View style={{ backgroundColor: theme.uiBg, borderRadius: 16, padding: 16, borderWidth: 1, borderColor: theme.border }}>
                                        {/* Tap to Define Toggle */}
                                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
                                            <View style={{ flex: 1, marginRight: 10 }}>
                                                <Text style={{ fontSize: 15, fontWeight: '600', color: theme.text }}>Tap to Define</Text>
                                                <Text style={{ fontSize: 12, color: theme.secondary }}>Look up words by tapping them</Text>
                                            </View>
                                            <TouchableOpacity
                                                activeOpacity={0.8}
                                                onPress={() => saveSettings({ tapToDefine: !displaySettings.tapToDefine })}
                                                style={{
                                                    width: 60,
                                                    height: 32,
                                                    backgroundColor: displaySettings.tapToDefine ? '#22c55e' : theme.buttonBg,
                                                    borderRadius: 16,
                                                    borderWidth: 1,
                                                    borderColor: displaySettings.tapToDefine ? '#22c55e' : theme.border,
                                                    flexDirection: 'row',
                                                    alignItems: 'center',
                                                    paddingHorizontal: 4,
                                                    justifyContent: displaySettings.tapToDefine ? 'flex-end' : 'flex-start'
                                                }}
                                            >
                                                {displaySettings.tapToDefine && (
                                                    <Text style={{ color: 'white', fontSize: 10, fontWeight: 'bold', marginRight: 6 }}>ON</Text>
                                                )}
                                                <View style={{
                                                    width: 24,
                                                    height: 24,
                                                    borderRadius: 12,
                                                    backgroundColor: 'white',
                                                    shadowColor: "#000",
                                                    shadowOffset: { width: 0, height: 1 },
                                                    shadowOpacity: 0.2,
                                                    shadowRadius: 1,
                                                    elevation: 2
                                                }} />
                                                {!displaySettings.tapToDefine && (
                                                    <Text style={{ color: theme.secondary, fontSize: 10, fontWeight: 'bold', marginLeft: 6 }}>OFF</Text>
                                                )}
                                            </TouchableOpacity>
                                        </View>

                                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                                            <View style={{ flex: 1, marginRight: 10 }}>
                                                <Text style={{ fontSize: 15, fontWeight: '600', color: theme.text }}>Recent Words Flashcards</Text>
                                                <Text style={{ fontSize: 12, color: theme.secondary }}>Show recent words on Home</Text>
                                            </View>
                                            <TouchableOpacity
                                                activeOpacity={0.8}
                                                onPress={() => saveSettings({ showPersonalDictionary: !displaySettings.showPersonalDictionary })}
                                                style={{
                                                    width: 60,
                                                    height: 32,
                                                    backgroundColor: displaySettings.showPersonalDictionary ? '#22c55e' : theme.buttonBg,
                                                    borderRadius: 16,
                                                    borderWidth: 1,
                                                    borderColor: displaySettings.showPersonalDictionary ? '#22c55e' : theme.border,
                                                    flexDirection: 'row',
                                                    alignItems: 'center',
                                                    paddingHorizontal: 4,
                                                    justifyContent: displaySettings.showPersonalDictionary ? 'flex-end' : 'flex-start'
                                                }}
                                            >
                                                {displaySettings.showPersonalDictionary && (
                                                    <Eye size={12} color="white" style={{ marginRight: 6 }} />
                                                )}
                                                <View style={{
                                                    width: 24,
                                                    height: 24,
                                                    borderRadius: 12,
                                                    backgroundColor: 'white',
                                                    shadowColor: "#000",
                                                    shadowOffset: { width: 0, height: 1 },
                                                    shadowOpacity: 0.2,
                                                    shadowRadius: 1,
                                                    elevation: 2
                                                }} />
                                                {!displaySettings.showPersonalDictionary && (
                                                    <EyeOff size={12} color={theme.secondary} style={{ marginLeft: 6 }} />
                                                )}
                                            </TouchableOpacity>
                                        </View>
                                    </View>
                                </View>

                            </ScrollView>
                        </View>
                    </View>
                </Modal>

                {/* NEW: Role Creator Modal */}
                <Modal visible={showRoleCreator} transparent animationType="slide" onRequestClose={() => setShowRoleCreator(false)}>
                    <View style={styles.modalOverlay}>
                        <TouchableOpacity
                            style={StyleSheet.absoluteFill}
                            activeOpacity={1}
                            onPress={() => setShowRoleCreator(false)}
                        />
                        <View style={[styles.modalContent, { backgroundColor: theme.bg, height: '70%', padding: 0 }]}>
                            <View style={[styles.header, { height: 'auto', backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20, paddingTop: 20, paddingBottom: 15, borderTopLeftRadius: 24, borderTopRightRadius: 24 }]}>
                                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10, flex: 1 }}>
                                    <View style={{ width: 32, height: 32, borderRadius: 10, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                                        <UserPlus size={18} color={primaryColor} />
                                    </View>
                                    <Text style={[styles.modalTitle, { color: theme.text, fontSize: 20 }]}>Create Role</Text>
                                </View>
                                <TouchableOpacity onPress={() => setShowRoleCreator(false)} style={{ padding: 8, backgroundColor: theme.buttonBg, borderRadius: 20 }}>
                                    <X size={20} color={theme.text} />
                                </TouchableOpacity>
                            </View>

                            <KeyboardAvoidingView
                                behavior={Platform.OS === "ios" ? "padding" : "height"}
                                style={{ flex: 1 }}
                            >
                                <ScrollView contentContainerStyle={{ padding: 20 }} keyboardShouldPersistTaps="handled">
                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>Button Title</Text>
                                    <View style={{ marginBottom: 20 }}>
                                        <TextInput
                                            style={[styles.input, { backgroundColor: theme.inputBg, color: theme.text, borderColor: theme.border, marginBottom: 0, paddingRight: 45 }]}
                                            placeholder="e.g. Math Teacher, Fitness Coach"
                                            placeholderTextColor={theme.secondary}
                                            value={newRoleData.title}
                                            onChangeText={(t) => setNewRoleData({ ...newRoleData, title: t })}
                                            onFocus={() => setActiveRoleField('title')}
                                            maxLength={15}
                                        />
                                        {renderMicButton('role_title', { position: 'absolute', right: 6, top: 6, backgroundColor: theme.uiBg })}
                                    </View>

                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>Instructions (System Prompt)</Text>
                                    <View style={{ marginBottom: 20 }}>
                                        <TextInput
                                            style={[styles.textArea, { backgroundColor: theme.inputBg, color: theme.text, borderColor: theme.border, height: 120, marginBottom: 0 }]}
                                            placeholder="Describe who the AI should be.&#10;e.g. 'You are a kind Math Teacher. Solve problems step-by-step and explain clearly.'"
                                            placeholderTextColor={theme.secondary}
                                            value={newRoleData.instructions}
                                            onChangeText={(t) => setNewRoleData({ ...newRoleData, instructions: t })}
                                            onFocus={() => setActiveRoleField('instructions')}
                                            multiline
                                        />
                                        {renderMicButton('role_instructions', { position: 'absolute', bottom: 10, right: 10, backgroundColor: theme.uiBg })}
                                    </View>

                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 12, textTransform: 'uppercase' }}>Choose Icon</Text>
                                    <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10, marginBottom: 30 }}>
                                        {Object.keys(ICON_MAP).map((iconKey) => {
                                            const IconComp = ICON_MAP[iconKey];
                                            const isSelected = newRoleData.icon === iconKey;
                                            return (
                                                <TouchableOpacity
                                                    key={iconKey}
                                                    onPress={() => setNewRoleData({ ...newRoleData, icon: iconKey })}
                                                    style={{
                                                        width: 50, height: 50,
                                                        borderRadius: 12,
                                                        backgroundColor: isSelected ? primaryColor : theme.buttonBg,
                                                        alignItems: 'center', justifyContent: 'center',
                                                        borderWidth: 1,
                                                        borderColor: isSelected ? primaryColor : theme.border
                                                    }}
                                                >
                                                    <IconComp size={24} color={isSelected ? 'white' : theme.text} />
                                                </TouchableOpacity>
                                            );
                                        })}
                                    </View>

                                    <TouchableOpacity
                                        onPress={handleAddCustomRole}
                                        style={[styles.primaryBtn, { backgroundColor: primaryColor, marginBottom: 20 }]}
                                    >
                                        <Text style={styles.primaryBtnText}>Create Button</Text>
                                    </TouchableOpacity>
                                </ScrollView>
                            </KeyboardAvoidingView>
                        </View>
                    </View>
                </Modal>

                {/* NEW: Prompt Creator Modal */}
                <Modal visible={showPromptCreator} transparent animationType="slide" onRequestClose={() => setShowPromptCreator(false)}>
                    <View style={styles.modalOverlay}>
                        <TouchableOpacity
                            style={StyleSheet.absoluteFill}
                            activeOpacity={1}
                            onPress={() => setShowPromptCreator(false)}
                        />
                        <View style={[styles.modalContent, { backgroundColor: theme.bg, height: '70%', padding: 0 }]}>
                            <View style={[styles.header, { height: 'auto', backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20, paddingTop: 20, paddingBottom: 15, borderTopLeftRadius: 24, borderTopRightRadius: 24 }]}>
                                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10, flex: 1 }}>
                                    <View style={{ width: 32, height: 32, borderRadius: 10, backgroundColor: theme.highlight, alignItems: 'center', justifyContent: 'center' }}>
                                        <Lightbulb size={18} color={primaryColor} />
                                    </View>
                                    <Text style={[styles.modalTitle, { color: theme.text, fontSize: 20 }]}>Add Quick Idea</Text>
                                </View>
                                <TouchableOpacity onPress={() => setShowPromptCreator(false)} style={{ padding: 8, backgroundColor: theme.buttonBg, borderRadius: 20 }}>
                                    <X size={20} color={theme.text} />
                                </TouchableOpacity>
                            </View>

                            <KeyboardAvoidingView
                                behavior={Platform.OS === "ios" ? "padding" : "height"}
                                style={{ flex: 1 }}
                            >
                                <ScrollView contentContainerStyle={{ padding: 20 }} keyboardShouldPersistTaps="handled">
                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>Button Label (Short)</Text>
                                    <View style={{ marginBottom: 20 }}>
                                        <TextInput
                                            style={[styles.input, { backgroundColor: theme.inputBg, color: theme.text, borderColor: theme.border, marginBottom: 0, paddingRight: 45 }]}
                                            placeholder="e.g. Explain, Summarize, Code"
                                            placeholderTextColor={theme.secondary}
                                            value={newPromptData.label}
                                            onChangeText={(t) => setNewPromptData({ ...newPromptData, label: t })}
                                            onFocus={() => setActivePromptField('label')}
                                            maxLength={15}
                                        />
                                        {renderMicButton('prompt_label', { position: 'absolute', right: 6, top: 6, backgroundColor: theme.uiBg })}
                                    </View>

                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 11, marginBottom: 8, textTransform: 'uppercase' }}>The Prompt</Text>
                                    <View style={{ marginBottom: 20 }}>
                                        <TextInput
                                            style={[styles.textArea, { backgroundColor: theme.inputBg, color: theme.text, borderColor: theme.border, height: 120, marginBottom: 0 }]}
                                            placeholder="What should the AI do?&#10;e.g. 'Explain this concept simply using examples.'"
                                            placeholderTextColor={theme.secondary}
                                            value={newPromptData.prompt}
                                            onChangeText={(t) => setNewPromptData({ ...newPromptData, prompt: t })}
                                            onFocus={() => setActivePromptField('prompt')}
                                            multiline
                                        />
                                        {renderMicButton('prompt_content', { position: 'absolute', bottom: 10, right: 10, backgroundColor: theme.uiBg })}
                                    </View>

                                    <TouchableOpacity
                                        onPress={handleSaveCustomPrompt}
                                        style={[styles.primaryBtn, { backgroundColor: primaryColor, marginBottom: 20 }]}
                                    >
                                        <Text style={styles.primaryBtnText}>
                                            {selectedScenario?.id === 'examiner' ? "Add Topic" : "Add to Role"}
                                        </Text>
                                    </TouchableOpacity>
                                </ScrollView>
                            </KeyboardAvoidingView>
                        </View>
                    </View>
                </Modal>

                <Modal visible={showWordModal} transparent animationType="slide" onRequestClose={() => setShowWordModal(false)}>
                    <View style={styles.modalOverlay}>
                        <TouchableOpacity
                            style={StyleSheet.absoluteFill}
                            activeOpacity={1}
                            onPress={() => setShowWordModal(false)}
                        />
                        <View style={[styles.modalContent, { backgroundColor: theme.bg, height: '70%', padding: 0 }]}>
                            <View style={[styles.header, { backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20, borderTopLeftRadius: 24, borderTopRightRadius: 24 }]}>
                                <TouchableOpacity
                                    onPress={handleCycleLanguage}
                                    style={{ flexDirection: 'row', alignItems: 'center', gap: 6, width: 70 }}
                                >
                                    <Languages size={18} color={theme.secondary} />
                                    <Text style={{ fontSize: 13, fontWeight: 'bold', color: theme.secondary }}>
                                        {modalLanguage.substring(0, 3).toUpperCase()}
                                    </Text>
                                </TouchableOpacity>

                                <View style={{ width: 40, height: 4, backgroundColor: theme.border, borderRadius: 2, opacity: 0.5 }} />
                                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 5, width: 70, justifyContent: 'flex-end' }}>
                                    <TouchableOpacity onPress={() => setShowWordModal(false)} style={{ padding: 5 }}>
                                        <X size={24} color={theme.text} />
                                    </TouchableOpacity>
                                </View>
                            </View>
                            <View style={{ flex: 1, padding: 20 }}>
                                {isDefining ? (
                                    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                                        <ActivityIndicator size="large" color={primaryColor} />
                                        <Text style={{ marginTop: 20, color: theme.secondary, fontWeight: 'bold' }}>Defining...</Text>
                                    </View>
                                ) : (
                                    <>
                                        {wordData ? (
                                            renderDefinitionContent(
                                                wordData,
                                                selectedWord.word,
                                                isWordSaved,
                                                toggleSaveWord,
                                                false,
                                                handleWordQuiz,
                                                () => handleRefreshDefinition(selectedWord.word)
                                            )
                                        ) : (
                                            <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                                                <Text style={{ color: theme.secondary }}>Definition not found.</Text>
                                            </View>
                                        )}
                                    </>
                                )}
                            </View>
                        </View>
                    </View>
                </Modal>

                <Modal visible={showImageSourceModal} transparent animationType="fade" onRequestClose={() => setShowImageSourceModal(false)}>
                    <TouchableOpacity
                        style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center', padding: 20 }}
                        activeOpacity={1}
                        onPress={() => setShowImageSourceModal(false)}
                    >
                        <View style={{ backgroundColor: theme.bg, width: '85%', borderRadius: 20, padding: 24, alignItems: 'center', shadowColor: "#000", shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.3, shadowRadius: 8, elevation: 10 }}>
                            <Text style={{ fontSize: 20, fontWeight: 'bold', color: theme.text, marginBottom: 25 }}>Add Content</Text>

                            <TouchableOpacity onPress={onCameraPress} style={{ flexDirection: 'row', alignItems: 'center', width: '100%', padding: 16, borderRadius: 16, backgroundColor: theme.buttonBg, marginBottom: 12, borderWidth: 1, borderColor: theme.border }}>
                                <View style={{ width: 40, alignItems: 'center' }}>
                                    <Camera size={24} color={primaryColor} />
                                </View>
                                <View>
                                    <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Take Photo</Text>
                                    <Text style={{ fontSize: 12, color: theme.secondary, marginTop: 2 }}>Capture & Crop</Text>
                                </View>
                            </TouchableOpacity>

                            <TouchableOpacity onPress={onGalleryMultiplePress} style={{ flexDirection: 'row', alignItems: 'center', width: '100%', padding: 16, borderRadius: 16, backgroundColor: theme.buttonBg, marginBottom: 12, borderWidth: 1, borderColor: theme.border }}>
                                <View style={{ width: 40, alignItems: 'center' }}>
                                    <ImageIcon size={24} color={primaryColor} />
                                </View>
                                <View>
                                    <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>Gallery</Text>
                                    <Text style={{ fontSize: 12, color: theme.secondary, marginTop: 2 }}>Select One or More</Text>
                                </View>
                            </TouchableOpacity>

                            <TouchableOpacity onPress={() => onDocumentPress()} style={{ flexDirection: 'row', alignItems: 'center', width: '100%', padding: 16, borderRadius: 16, backgroundColor: theme.buttonBg, marginBottom: 5, borderWidth: 1, borderColor: theme.border }}>
                                <View style={{ width: 40, alignItems: 'center' }}>
                                    <FileIcon size={24} color={primaryColor} />
                                </View>
                                <View>
                                    <Text style={{ fontSize: 16, fontWeight: 'bold', color: theme.text }}>PDF Document</Text>
                                    <Text style={{ fontSize: 12, color: theme.secondary, marginTop: 2 }}>Analyze Text in Files</Text>
                                </View>
                            </TouchableOpacity>
                        </View>
                    </TouchableOpacity>
                </Modal>

                <Modal visible={showVisionDraft} animationType="slide" presentationStyle="overFullScreen" statusBarTranslucent={true} onRequestClose={() => setShowVisionDraft(false)}>
                    <SafeAreaView style={[styles.fullScreenModal, { backgroundColor: theme.bg }]}>
                        <View style={[styles.header, { backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20 }]}>
                            <Text style={{ fontSize: 18, fontWeight: 'bold', color: theme.text }}>Vision Analysis</Text>
                            <TouchableOpacity onPress={() => setShowVisionDraft(false)} style={{ padding: 5 }}>
                                <X size={24} color={theme.text} />
                            </TouchableOpacity>
                        </View>

                        <KeyboardAvoidingView behavior={Platform.OS === 'ios' ? 'padding' : 'height'} style={{ flex: 1 }}>
                            <ScrollView contentContainerStyle={{ padding: 20 }}>
                                <View style={{ marginBottom: 20 }}>
                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 12, textTransform: 'uppercase', marginBottom: 10 }}>Selected Items ({visionDraft.uris.length})</Text>
                                    <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={{ gap: 10 }}>
                                        {visionDraft.uris.map((uri: string, idx: number) => (
                                            <View key={idx} style={{ position: 'relative' }}>
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        // Preserve current mode (quiz or vision) so editor saves back correctly
                                                        openEditorForExistingImage(uri, idx);
                                                    }}
                                                    activeOpacity={0.9}
                                                    style={{
                                                        width: 140,
                                                        height: 140,
                                                        borderRadius: 12,
                                                        backgroundColor: theme.buttonBg,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        overflow: 'hidden'
                                                    }}
                                                >
                                                    {isPdf(uri) ? (
                                                        <View style={{ alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%', backgroundColor: '#ffe4e6' }}>
                                                            <FileText size={48} color="#e11d48" />
                                                            <Text style={{ fontSize: 10, color: "#be123c", marginTop: 8, fontWeight: 'bold' }}>PDF DOCUMENT</Text>
                                                        </View>
                                                    ) : (
                                                        <Image source={{ uri: uri }} style={{ width: '100%', height: '100%' }} resizeMode="cover" />
                                                    )}
                                                </TouchableOpacity>
                                                <TouchableOpacity
                                                    onPress={() => {
                                                        const newUris = visionDraft.uris.filter((_: string, i: number) => i !== idx);
                                                        setVisionDraft((prev: any) => ({ ...prev, uris: newUris }));
                                                    }}
                                                    style={{
                                                        position: 'absolute', top: 5, right: 5,
                                                        backgroundColor: 'rgba(0,0,0,0.6)', borderRadius: 12, padding: 4
                                                    }}
                                                >
                                                    <X size={14} color="white" />
                                                </TouchableOpacity>
                                            </View>
                                        ))}

                                        <TouchableOpacity
                                            onPress={() => {
                                                // FIXED: Don't reset to 'vision', preserve 'quiz' mode if active
                                                setShowImageSourceModal(true);
                                            }}
                                            style={{
                                                width: 140, height: 140,
                                                borderRadius: 12,
                                                backgroundColor: theme.buttonBg,
                                                borderWidth: 1,
                                                borderColor: theme.border,
                                                borderStyle: 'dashed',
                                                alignItems: 'center',
                                                justifyContent: 'center'
                                            }}
                                        >
                                            <Plus size={24} color={theme.secondary} />
                                            <Text style={{ marginTop: 8, fontSize: 12, fontWeight: '600', color: theme.secondary }}>Add More</Text>
                                        </TouchableOpacity>
                                    </ScrollView>
                                </View>

                                <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 12, textTransform: 'uppercase', marginBottom: 10 }}>Your Question (Optional)</Text>
                                <View style={[styles.searchBar, { backgroundColor: theme.inputBg, borderColor: theme.border, marginBottom: 0, minHeight: 50, maxHeight: 120 }]}>
                                    <TextInput
                                        style={[styles.searchInput, { color: theme.text, marginLeft: 10, flex: 1 }]}
                                        placeholder="What should I explain about these items?"
                                        placeholderTextColor={theme.secondary}
                                        value={visionDraft.prompt}
                                        onChangeText={(t) => setVisionDraft((prev: any) => ({ ...prev, prompt: t }))}
                                        multiline
                                    />
                                    <TouchableOpacity
                                        onPress={() => handleVoiceToggle('vision_prompt')}
                                        style={{
                                            width: 38,
                                            height: 38,
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            marginRight: 4
                                        }}
                                    >
                                        {isTranscribing && voiceTarget === 'vision_prompt' ? (
                                            <ActivityIndicator size="small" color={theme.text} />
                                        ) : (
                                            <Animated.View style={{ opacity: voiceTarget === 'vision_prompt' ? recordingOpacity : 1 }}>
                                                <Mic size={20} color={(isRecording && voiceTarget === 'vision_prompt') ? primaryColor : theme.text} />
                                            </Animated.View>
                                        )}
                                    </TouchableOpacity>
                                    <TouchableOpacity
                                        onPress={() => processVisionRequest()}
                                        disabled={visionDraft.uris.length === 0}
                                        style={{
                                            width: 38,
                                            height: 38,
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            opacity: visionDraft.uris.length === 0 ? 0.3 : 1
                                        }}
                                    >
                                        <ArrowRight size={20} color={visionDraft.uris.length > 0 ? primaryColor : theme.text} />
                                    </TouchableOpacity>
                                </View>

                                {/* NEW: Question Count Input for Quiz Mode */}
                                {imagePickerMode === 'quiz' && (
                                    <View style={{ marginTop: 15 }}>
                                        <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 12, textTransform: 'uppercase', marginBottom: 8 }}>Number of Questions</Text>
                                        <TextInput
                                            style={[styles.input, {
                                                backgroundColor: theme.inputBg,
                                                color: theme.text,
                                                borderColor: theme.border,
                                                marginBottom: 0,
                                                height: 50
                                            }]}
                                            placeholder="Default: 10"
                                            placeholderTextColor={theme.secondary}
                                            value={schoolConfig.length}
                                            keyboardType="number-pad"
                                            onChangeText={(text) => {
                                                const numeric = text.replace(/[^0-9]/g, '');
                                                saveSchoolConfig({ length: numeric });
                                            }}
                                        />
                                    </View>
                                )}

                                {/* NEW: Custom Prompts Section */}
                                <View style={{ marginTop: 25 }}>
                                    <EditableSelectionList
                                        label="MY PROMPTS"
                                        items={customVisionPrompts}
                                        selectedItem={visionDraft.prompt}
                                        onSelect={(val: string) => {
                                            setVisionDraft((prev: any) => ({ ...prev, prompt: val }));
                                            saveVisionPromptToHistory(val);
                                        }}
                                        onAdd={addCustomVisionPrompt}
                                        onDelete={removeCustomVisionPrompt}
                                        theme={theme}
                                        placeholder="Add custom prompt..."
                                        formatItem={(item: string) => {
                                            // Try to find matching label in all lists from UI DATA (Translated)
                                            const allActions = [
                                                ...(uiData.visionActions || []),
                                                ...(uiData.documentActions || []),
                                                ...(uiData.quizVisionActions || []),
                                                ...(uiData.quizDocumentActions || []),
                                                ...(uiData.storyVisionActions || []),
                                                ...(uiData.storyDocumentActions || []),
                                                ...(uiData.searchVisionActions || []),
                                                ...(uiData.searchDocumentActions || []),
                                                ...(uiData.writerVisionActions || []),
                                                ...(uiData.writerDocumentActions || []),
                                                ...(uiData.doctorVisionActions || []),
                                                ...(uiData.doctorDocumentActions || []),
                                                ...(uiData.greetingsVisionActions || []),
                                                ...(uiData.wordHelpVisionActions || []),
                                                ...(uiData.editorialVisionActions || []),
                                                ...(uiData.customRoleVisionActions || []),
                                                ...(uiData.mathVisionActions || [])
                                            ];
                                            const quickAction = allActions.find(q => q.prompt === item);
                                            if (quickAction) return quickAction.label;
                                            return item.length > 20 ? item.split(' ').slice(0, 3).join(' ') + '...' : item;
                                        }}
                                    />
                                </View>

                                <View style={{ marginTop: 5 }}>
                                    <Text style={{ color: theme.secondary, fontWeight: '700', fontSize: 12, textTransform: 'uppercase', marginBottom: 10 }}>Quick Prompts</Text>
                                    <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'space-between', gap: 8 }}>
                                        {(() => {
                                            const isDocumentMode = (visionDraft as any).uris.some((uri: any) => isPdf(uri));
                                            // Use dynamic uiData references
                                            let activeQuickActions = isDocumentMode ? uiData.documentActions : uiData.visionActions;

                                            // OVERRIDE: Based on mode
                                            if (imagePickerMode === 'quiz') {
                                                activeQuickActions = isDocumentMode ? uiData.quizDocumentActions : uiData.quizVisionActions;
                                            } else if (imagePickerMode === 'story') {
                                                activeQuickActions = isDocumentMode ? uiData.storyDocumentActions : uiData.storyVisionActions;
                                            } else if (imagePickerMode === 'vision') {
                                                activeQuickActions = isDocumentMode ? uiData.searchDocumentActions : uiData.searchVisionActions;

                                            } else if (imagePickerMode === 'custom') {
                                                // NEW: Custom Role Quick Actions
                                                activeQuickActions = uiData.customRoleVisionActions;
                                            } else if (imagePickerMode === 'math') {
                                                // NEW: Math specific quick actions
                                                activeQuickActions = uiData.mathVisionActions;
                                            }

                                            return activeQuickActions.map((action: any, idx: number) => (
                                                <TouchableOpacity
                                                    key={idx}
                                                    onPress={() => {
                                                        let promptToUse = action.prompt;
                                                        if (action.label === 'Translate') {
                                                            promptToUse = `Translate the content to ${displaySettings.language}.`;
                                                        }

                                                        // NEW: Dynamic Role Replacement for Custom Roles
                                                        if (imagePickerMode === 'custom' && selectedScenario) {
                                                            promptToUse = promptToUse.replace('[ROLE]', selectedScenario.title);
                                                        }

                                                        setVisionDraft((prev: any) => ({ ...prev, prompt: promptToUse }));
                                                    }}
                                                    style={{
                                                        backgroundColor: theme.buttonBg,
                                                        width: '47%',
                                                        paddingVertical: 14,
                                                        paddingHorizontal: 8,
                                                        borderRadius: 12,
                                                        borderWidth: 1,
                                                        borderColor: theme.border,
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        marginBottom: 4
                                                    }}
                                                >
                                                    <Text style={{ color: theme.text, fontSize: 13, fontWeight: '600', textAlign: 'center' }}>{action.label}</Text>
                                                </TouchableOpacity>
                                            ));
                                        })()}
                                    </View>
                                </View>
                            </ScrollView>
                        </KeyboardAvoidingView>
                    </SafeAreaView>
                </Modal>

                {/* NEW: Unsaved Changes Modal */}
                <Modal visible={showUnsavedChangesModal} transparent animationType="fade" onRequestClose={() => setShowUnsavedChangesModal(false)}>
                    <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.6)', justifyContent: 'center', padding: 20 }}>
                        <View style={{
                            backgroundColor: theme.bg,
                            borderRadius: 24,
                            padding: 24,
                            alignItems: 'center',
                            shadowColor: "#000",
                            shadowOffset: { width: 0, height: 8 },
                            shadowOpacity: 0.4,
                            shadowRadius: 12,
                            elevation: 10,
                            borderWidth: 1,
                            borderColor: theme.border
                        }}>
                            <View style={{
                                width: 64, height: 64, borderRadius: 32,
                                backgroundColor: isDay ? '#fef3c7' : 'rgba(245, 158, 11, 0.2)',
                                alignItems: 'center', justifyContent: 'center',
                                marginBottom: 20
                            }}>
                                <AlertTriangle size={32} color="#d97706" fill={isDay ? "#d97706" : "transparent"} />
                            </View>

                            <Text style={{ fontSize: 20, fontWeight: 'bold', color: theme.text, marginBottom: 10, textAlign: 'center' }}>Unsaved Changes</Text>

                            <Text style={{ fontSize: 15, color: theme.secondary, textAlign: 'center', marginBottom: 25, lineHeight: 22 }}>
                                You have edited this note. Closing it now will discard your changes.
                            </Text>

                            <View style={{ width: '100%', gap: 12 }}>
                                {/* Horizontal Buttons Container */}
                                <View style={{ flexDirection: 'row', gap: 12 }}>
                                    <TouchableOpacity
                                        onPress={() => {
                                            setShowUnsavedChangesModal(false);
                                            discardNoteChanges();
                                        }}
                                        style={{
                                            flex: 1,
                                            paddingVertical: 14,
                                            borderRadius: 16,
                                            backgroundColor: isDay ? '#fee2e2' : 'rgba(239, 68, 68, 0.15)',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            borderWidth: 1,
                                            borderColor: isDay ? '#fecaca' : 'rgba(239, 68, 68, 0.3)'
                                        }}
                                    >
                                        <Text style={{ fontWeight: 'bold', color: '#dc2626', fontSize: 15 }}>Discard</Text>
                                    </TouchableOpacity>

                                    <TouchableOpacity
                                        onPress={() => {
                                            setShowUnsavedChangesModal(false);
                                            handleSaveNote();
                                        }}
                                        style={{
                                            flex: 1,
                                            paddingVertical: 14,
                                            borderRadius: 16,
                                            backgroundColor: primaryColor,
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            shadowColor: primaryColor,
                                            shadowOffset: { width: 0, height: 4 },
                                            shadowOpacity: 0.3,
                                            shadowRadius: 6,
                                            elevation: 4,
                                            flexDirection: 'row',
                                            gap: 6
                                        }}
                                    >
                                        <Save size={18} color="white" />
                                        <Text style={{ fontWeight: 'bold', color: 'white', fontSize: 15 }}>Save</Text>
                                    </TouchableOpacity>
                                </View>

                                <TouchableOpacity
                                    onPress={() => setShowUnsavedChangesModal(false)}
                                    style={{
                                        paddingVertical: 14,
                                        alignItems: 'center',
                                        width: '100%'
                                    }}
                                >
                                    <Text style={{ fontWeight: '600', color: theme.secondary, fontSize: 15 }}>Keep Editing</Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    </View>
                </Modal>

                {/* NEW: Reset Warning Modal */}
                <Modal visible={showResetWarning} transparent animationType="fade" onRequestClose={() => setShowResetWarning(false)}>
                    <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', padding: 20 }}>
                        <View style={{ backgroundColor: theme.bg, borderRadius: 24, padding: 24, alignItems: 'center', shadowColor: "#000", shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.3, shadowRadius: 8, elevation: 10 }}>
                            <View style={{ width: 64, height: 64, borderRadius: 32, backgroundColor: '#fee2e2', alignItems: 'center', justifyContent: 'center', marginBottom: 20 }}>
                                <AlertTriangle size={32} color="#dc2626" />
                            </View>

                            <Text style={{ fontSize: 20, fontWeight: 'bold', color: theme.text, marginBottom: 10, textAlign: 'center' }}>Reset All Data?</Text>

                            <Text style={{ fontSize: 14, color: theme.secondary, textAlign: 'center', marginBottom: 20, lineHeight: 22, paddingHorizontal: 10 }}>
                                This will <Text style={{ fontWeight: 'bold', color: '#dc2626' }}>permanently delete ALL data</Text> including Search History, Notes, Dictionary,Saved Questions, Words, Flashcards and restore all Settings to default.
                            </Text>

                            <View style={{ width: '100%', backgroundColor: theme.uiBg, padding: 16, borderRadius: 16, marginBottom: 25, borderLeftWidth: 4, borderLeftColor: '#22c55e', borderWidth: 1, borderColor: theme.border }}>
                                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6 }}>
                                    <CheckCircle size={16} color="#16a34a" style={{ marginRight: 8 }} />
                                    <Text style={{ fontSize: 13, fontWeight: 'bold', color: theme.text, textTransform: 'uppercase' }}>Auto-Backup</Text>
                                </View>
                                <Text style={{ fontSize: 13, color: theme.secondary, lineHeight: 20 }}>Your <Text style={{ fontWeight: 'bold', color: theme.text }}>Notes</Text> will be automatically backed up to device storage before reset.</Text>
                            </View>

                            <View style={{ flexDirection: 'row', gap: 12, width: '100%' }}>
                                <TouchableOpacity
                                    onPress={() => setShowResetWarning(false)}
                                    style={{ flex: 1, paddingVertical: 14, borderRadius: 14, backgroundColor: theme.buttonBg, alignItems: 'center', borderWidth: 1, borderColor: theme.border }}
                                >
                                    <Text style={{ fontWeight: 'bold', color: theme.text, fontSize: 15 }}>Cancel</Text>
                                </TouchableOpacity>

                                <TouchableOpacity
                                    onPress={performLibraryReset}
                                    style={{ flex: 1, paddingVertical: 14, borderRadius: 14, backgroundColor: '#dc2626', alignItems: 'center', shadowColor: "#dc2626", shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.2, shadowRadius: 4, elevation: 4 }}
                                >
                                    <Text style={{ fontWeight: 'bold', color: 'white', fontSize: 15 }}>Reset Now</Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    </View>
                </Modal>

                <ZoomableImageModal visible={!!fullScreenImage} uri={fullScreenImage} onClose={() => setFullScreenImage(null)} />

                {/* NEW: Full Screen Reference Text Modal */}
                <Modal visible={showFullScreenReference} animationType="slide" onRequestClose={() => setShowFullScreenReference(false)}>
                    <SafeAreaView style={[styles.fullScreenModal, { backgroundColor: theme.bg }]}>
                        <View style={[styles.header, { backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20 }]}>
                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                                <FileText size={20} color={primaryColor} />
                                <Text style={[styles.modalTitle, { color: theme.text, fontSize: 18 }]}>Reference Text</Text>
                            </View>
                            <TouchableOpacity onPress={() => setShowFullScreenReference(false)} style={{ padding: 8 }}>
                                <X size={24} color={theme.text} />
                            </TouchableOpacity>
                        </View>

                        <ScrollView style={{ flex: 1 }} contentContainerStyle={{ padding: 20 }}>
                            <InteractiveText
                                rawText={quizState?.contextText || ""}
                                onWordPress={() => { }}
                                theme={theme}
                                activeSentence={null}
                                style={{ fontSize: 18, color: theme.text, lineHeight: 28 }}
                            />
                        </ScrollView>
                    </SafeAreaView>
                </Modal>

                {/* NEW: Expanded Table Modal */}
                <Modal visible={!!expandedTableData} animationType="slide" onRequestClose={() => setExpandedTableData(null)}>
                    <SafeAreaView style={[styles.fullScreenModal, { backgroundColor: theme.bg }]}>
                        <View style={[styles.header, { backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20 }]}>
                            <Text style={[styles.modalTitle, { color: theme.text, fontSize: 18 }]}>Data Table</Text>
                            <View style={{ flexDirection: 'row', gap: 10 }}>
                                <TouchableOpacity
                                    onPress={() => setIsTableLandscape(!isTableLandscape)}
                                    style={{
                                        padding: 8,
                                        backgroundColor: theme.buttonBg,
                                        borderRadius: 20,
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        gap: 4
                                    }}
                                >
                                    <Smartphone
                                        size={20}
                                        color={theme.text}
                                        style={{ transform: [{ rotate: isTableLandscape ? '90deg' : '0deg' }] }}
                                    />
                                    <Text style={{ fontSize: 12, fontWeight: 'bold', color: theme.text }}>
                                        {isTableLandscape ? "Landscape" : "Portrait"}
                                    </Text>
                                </TouchableOpacity>
                                <TouchableOpacity onPress={() => setExpandedTableData(null)} style={{ padding: 8 }}>
                                    <X size={24} color={theme.text} />
                                </TouchableOpacity>
                            </View>
                        </View>

                        <ScrollView style={{ flex: 1 }} contentContainerStyle={{ padding: 20 }}>
                            {expandedTableData && (
                                <SimpleTable
                                    rows={expandedTableData}
                                    theme={theme}
                                    isFullScreen={true}
                                    fontSize={displaySettings.fontSize}
                                />
                            )}
                        </ScrollView>
                    </SafeAreaView>
                </Modal>

                {/* NEW: Image Editor Popup Modal - Full Screen with Free Crop */}
                <Modal visible={showImageEditor} animationType="slide" onRequestClose={() => setShowImageEditor(false)}>
                    <SafeAreaView style={[styles.fullScreenModal, { backgroundColor: theme.bg }]}>
                        <View style={[styles.header, { backgroundColor: theme.bg, justifyContent: 'space-between', borderBottomWidth: 1, borderColor: theme.border, paddingHorizontal: 20 }]}>
                            <Text style={[styles.modalTitle, { color: theme.text, fontSize: 18 }]}>Edit Image</Text>
                            <TouchableOpacity onPress={() => setShowImageEditor(false)} style={{ padding: 5 }}>
                                <X size={24} color={theme.text} />
                            </TouchableOpacity>
                        </View>

                        <View style={{ flex: 1, padding: 20, justifyContent: 'space-between' }}>
                            <View
                                style={{ flex: 1, backgroundColor: '#000', borderRadius: 12, position: 'relative', zIndex: 1 }} // Removed overflow: 'hidden' to allow handles
                                onLayout={(e: any) => setEditorContainerSize({ width: e.nativeEvent.layout.width, height: e.nativeEvent.layout.height })}
                            >
                                {editorTarget && (
                                    <>
                                        {/* Base Image Container - Overflow Hidden here for corner radius */}
                                        <View style={{ ...StyleSheet.absoluteFillObject, overflow: 'hidden', borderRadius: 12 }}>
                                            <Image
                                                source={{ uri: editorTarget.uri }}
                                                style={{
                                                    width: '100%',
                                                    height: '100%',
                                                    transform: [{ rotate: `${editorRotation}deg` }],
                                                    opacity: 0.6 // Dim background
                                                }}
                                                resizeMode="contain"
                                            />
                                        </View>

                                        {/* Interactive Crop Overlay - ZIndex above image */}
                                        {cropRegion && (
                                            <View style={{
                                                position: 'absolute',
                                                left: cropRegion.x,
                                                top: cropRegion.y,
                                                width: cropRegion.width,
                                                height: cropRegion.height,
                                                borderColor: 'white',
                                                borderWidth: 2,
                                                backgroundColor: 'transparent',
                                                zIndex: 10
                                            }}>
                                                {/* Bright Image Selection - Only visual trick */}
                                                <View style={{ flex: 1, overflow: 'hidden' }}>
                                                    <Image
                                                        source={{ uri: editorTarget.uri }}
                                                        style={{
                                                            width: displayedImageRect?.width,
                                                            height: displayedImageRect?.height,
                                                            position: 'absolute',
                                                            left: (displayedImageRect?.x ?? 0) - (cropRegion?.x ?? 0),
                                                            top: (displayedImageRect?.y ?? 0) - (cropRegion?.y ?? 0),
                                                            transform: [{ rotate: `${editorRotation}deg` }]
                                                        }}
                                                        resizeMode="contain"
                                                    />
                                                </View>

                                                {/* Grid Lines */}
                                                <View style={{ position: 'absolute', left: '33%', top: 0, bottom: 0, width: 1, backgroundColor: 'rgba(255,255,255,0.5)' }} />
                                                <View style={{ position: 'absolute', right: '33%', top: 0, bottom: 0, width: 1, backgroundColor: 'rgba(255,255,255,0.5)' }} />
                                                <View style={{ position: 'absolute', top: '33%', left: 0, right: 0, height: 1, backgroundColor: 'rgba(255,255,255,0.5)' }} />
                                                <View style={{ position: 'absolute', bottom: '33%', left: 0, right: 0, height: 1, backgroundColor: 'rgba(255,255,255,0.5)' }} />

                                                {/* Corner Handles - Increased hit slop area visually */}
                                                {/* Top Left */}
                                                <View
                                                    {...tlResponder.panHandlers}
                                                    style={{ position: 'absolute', top: -20, left: -20, padding: 20, zIndex: 20 }}
                                                >
                                                    <View style={{ width: 24, height: 24, borderTopWidth: 4, borderLeftWidth: 4, borderColor: primaryColor, backgroundColor: 'transparent' }} />
                                                </View>

                                                {/* Top Right */}
                                                <View
                                                    {...trResponder.panHandlers}
                                                    style={{ position: 'absolute', top: -20, right: -20, padding: 20, zIndex: 20 }}
                                                >
                                                    <View style={{ width: 24, height: 24, borderTopWidth: 4, borderRightWidth: 4, borderColor: primaryColor, backgroundColor: 'transparent' }} />
                                                </View>

                                                {/* Bottom Left */}
                                                <View
                                                    {...blResponder.panHandlers}
                                                    style={{ position: 'absolute', bottom: -20, left: -20, padding: 20, zIndex: 20 }}
                                                >
                                                    <View style={{ width: 24, height: 24, borderBottomWidth: 4, borderLeftWidth: 4, borderColor: primaryColor, backgroundColor: 'transparent' }} />
                                                </View>

                                                {/* Bottom Right */}
                                                <View
                                                    {...brResponder.panHandlers}
                                                    style={{ position: 'absolute', bottom: -20, right: -20, padding: 20, zIndex: 20 }}
                                                >
                                                    <View style={{ width: 24, height: 24, borderBottomWidth: 4, borderRightWidth: 4, borderColor: primaryColor, backgroundColor: 'transparent' }} />
                                                </View>
                                            </View>
                                        )}
                                    </>
                                )}
                            </View>

                            <View style={{ width: '100%', gap: 15, marginTop: 20 }}>
                                <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <Text style={{ color: theme.secondary, fontWeight: 'bold', fontSize: 12, textTransform: 'uppercase' }}>Rotation</Text>
                                    <Text style={{ color: theme.text, fontWeight: 'bold' }}>{editorRotation}Â°</Text>
                                </View>

                                <TouchableOpacity
                                    onPress={() => setEditorRotation(prev => (prev + 90) % 360)}
                                    style={{
                                        paddingVertical: 14,
                                        borderRadius: 12,
                                        backgroundColor: theme.buttonBg,
                                        alignItems: 'center',
                                        borderWidth: 1,
                                        borderColor: theme.border,
                                        flexDirection: 'row',
                                        justifyContent: 'center',
                                        gap: 10
                                    }}
                                >
                                    <RefreshCcw size={20} color={theme.text} />
                                    <Text style={{ color: theme.text, fontWeight: '600', fontSize: 16 }}>Rotate 90Â°</Text>
                                </TouchableOpacity>

                                <Text style={{ textAlign: 'center', color: theme.secondary, fontSize: 12, marginTop: 5 }}>
                                    Drag corners to crop freely
                                </Text>
                            </View>
                        </View>

                        <View style={{ padding: 20, borderTopWidth: 1, borderTopColor: theme.border }}>
                            <TouchableOpacity
                                onPress={processEditorSave}
                                style={[styles.primaryBtn, { backgroundColor: primaryColor, flexDirection: 'row', gap: 10 }]}
                            >
                                <Check size={20} color="white" />
                                <Text style={styles.primaryBtnText}>Done</Text>
                            </TouchableOpacity>
                        </View>
                    </SafeAreaView>
                </Modal>



                {/* NEW: Toast Notification Component */}
                {toastMessage && (
                    <Animated.View
                        style={{
                            position: 'absolute',
                            bottom: 100,
                            alignSelf: 'center',
                            backgroundColor: theme.id === 'day' ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.9)',
                            paddingHorizontal: 20,
                            paddingVertical: 12,
                            borderRadius: 25,
                            zIndex: 9999,
                            shadowColor: "#000",
                            shadowOffset: { width: 0, height: 4 },
                            shadowOpacity: 0.3,
                            shadowRadius: 4,
                            elevation: 10,
                            maxWidth: '90%'
                        }}
                    >
                        <Text style={{
                            color: theme.id === 'day' ? 'white' : 'black',
                            fontWeight: 'bold',
                            fontSize: 14,
                            textAlign: 'center'
                        }}>
                            {toastMessage}
                        </Text>
                    </Animated.View>
                )}

            </SafeAreaView>

            {/* Onboarding Modal */}
            <OnboardingModal
                visible={isSettingsLoaded && displaySettings.isOnboarded === false && isInOnboardingPreview === false}
                theme={theme}
                onSave={async (userData: any) => {
                    // 1. Save Profile Settings provisionally
                    await saveSettings({ ...userData });

                    // 2. Transition to Reader Mode Preview
                    setIsInOnboardingPreview(true);
                    setAppMode("reader");
                    setReadingSession({
                        id: "onboarding_guide",
                        title: "Welcome Guide",
                        messages: [{ role: 'ai', content: ONBOARDING_GUIDE_MARKDOWN }], // Normalized structure
                        lastOpened: Date.now(),
                        type: 'text'
                    });
                }}
            />
        </SafeAreaProvider >
    );
}